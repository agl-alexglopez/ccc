<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/adaptive_map.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('adaptive__map_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">adaptive_map.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Adaptive Map Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="private__adaptive__map_8h_source.html">private/private_adaptive_map.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for adaptive_map.h:</div>
<div class="dyncontent">
<div class="center"><img src="adaptive__map_8h__incl.png" border="0" usemap="#accc_2adaptive__map_8h" alt=""/></div>
<map name="accc_2adaptive__map_8h" id="accc_2adaptive__map_8h">
<area shape="rect" title="The Adaptive Map Interface." alt="" coords="5,5,157,31"/>
<area shape="rect" href="private__adaptive__map_8h.html" title="The Adaptive Map Private Interface." alt="" coords="55,79,238,119"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="27,167,109,192"/>
<area shape="rect" href="private__types_8h_source.html" title=" " alt="" coords="20,240,193,265"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="adaptive__map_8h__dep__incl.png" border="0" usemap="#accc_2adaptive__map_8hdep" alt=""/></div>
<map name="accc_2adaptive__map_8hdep" id="accc_2adaptive__map_8hdep">
<area shape="rect" title="The Adaptive Map Interface." alt="" coords="5,5,157,31"/>
<area shape="rect" href="private__traits_8h_source.html" title=" " alt="" coords="10,79,153,119"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="35,167,128,192"/>
</map>
</div>
</div>
<p><a href="adaptive__map_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Adaptive Map Interface. </p>
<p>An adaptive map offers storage and retrieval of elements sorted on the user specified key. Once allocated, this container will not move elements in memory making this container assume pointer stability. Because the data structure is self-optimizing it is not a suitable map when strict sub-linear runtime bounds are needed. Also, searching the map is not a const thread-safe operation as indicated by the function signatures. The map is optimized upon every new search, attempting to adapt to the usage pattern. In many cases the self-optimizing structure of the map can be beneficial when considering non-uniform access patterns. In the best case, repeated searches of the same value yield an <code>O(1)</code> access and many other frequently searched values will be obtained in constant time.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>CCC_</code> prefix. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Initialize the container with memory, callbacks, and permissions. </p>
</td></tr>
<tr class="memitem:ab34ca82a0748237e96162762b9d7d2fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ab34ca82a0748237e96162762b9d7d2fb">CCC_adaptive_map_initialize</a>(struct_name,  type_intruder_field_name,  type_key_field_name,  key_order,  allocate,  context)</td></tr>
<tr class="memdesc:ab34ca82a0748237e96162762b9d7d2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the adaptive map at runtime or compile time.  <br /></td></tr>
<tr class="separator:ab34ca82a0748237e96162762b9d7d2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7874b40de99cc78375eb87e5b6dfe5d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a7874b40de99cc78375eb87e5b6dfe5d7">CCC_adaptive_map_from</a>(type_intruder_field_name,  type_key_field_name,  compare,  allocate,  destroy,  context_data,  compound_literal_array...)</td></tr>
<tr class="memdesc:a7874b40de99cc78375eb87e5b6dfe5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a dynamic adaptive map at runtime.  <br /></td></tr>
<tr class="separator:a7874b40de99cc78375eb87e5b6dfe5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Entry Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and operate on container entries for efficient queries when non-trivial control flow is needed. </p>
</td></tr>
<tr class="memitem:a489d1a4248eed36ec884db29afd437ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a489d1a4248eed36ec884db29afd437ba">CCC_adaptive_map_swap_entry_wrap</a>(map_pointer,  type_intruder_pointer,  temp_intruder_pointer)</td></tr>
<tr class="memdesc:a489d1a4248eed36ec884db29afd437ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value wrapping the provided intruder.  <br /></td></tr>
<tr class="separator:a489d1a4248eed36ec884db29afd437ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6162debb2e5dab39637763145d6a15e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ad6162debb2e5dab39637763145d6a15e">CCC_adaptive_map_try_insert_wrap</a>(map_pointer,  type_intruder_pointer)</td></tr>
<tr class="memdesc:ad6162debb2e5dab39637763145d6a15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the key value wrapping type_intruder.  <br /></td></tr>
<tr class="separator:ad6162debb2e5dab39637763145d6a15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b3fa6736c783e094b85b335422d017"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#af0b3fa6736c783e094b85b335422d017">CCC_adaptive_map_try_insert_with</a>(map_pointer,  key,  compound_literal_type...)</td></tr>
<tr class="memdesc:af0b3fa6736c783e094b85b335422d017"><td class="mdescLeft">&#160;</td><td class="mdescRight">lazily insert compound_literal_type into the map at key if key is absent.  <br /></td></tr>
<tr class="separator:af0b3fa6736c783e094b85b335422d017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a398f842fb0da7e8ec83ae3a5b585b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a6a398f842fb0da7e8ec83ae3a5b585b2">CCC_adaptive_map_insert_or_assign_with</a>(map_pointer,  key,  compound_literal_type...)</td></tr>
<tr class="memdesc:a6a398f842fb0da7e8ec83ae3a5b585b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new key value pair or overwrites the existing entry.  <br /></td></tr>
<tr class="separator:a6a398f842fb0da7e8ec83ae3a5b585b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ae3888e95d0da2460bf598305e80d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a71ae3888e95d0da2460bf598305e80d4">CCC_adaptive_map_remove_wrap</a>(map_pointer,  type_output_intruder_pointer)</td></tr>
<tr class="memdesc:a71ae3888e95d0da2460bf598305e80d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key value in the map storing the old value, if present, in the struct containing type_output_intruder provided by the user.  <br /></td></tr>
<tr class="separator:a71ae3888e95d0da2460bf598305e80d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2378a144497ffa75fb0ca22d3a5d1bd6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a2378a144497ffa75fb0ca22d3a5d1bd6">CCC_adaptive_map_entry_wrap</a>(map_pointer,  key_pointer)</td></tr>
<tr class="memdesc:a2378a144497ffa75fb0ca22d3a5d1bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains an entry for the provided key in the map for future use.  <br /></td></tr>
<tr class="separator:a2378a144497ffa75fb0ca22d3a5d1bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40387f8d0ec9b20066d812a2bbb6350e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a40387f8d0ec9b20066d812a2bbb6350e">CCC_adaptive_map_and_modify_with</a>(adaptive_map_entry_pointer,  type_name,  closure_over_T...)</td></tr>
<tr class="memdesc:a40387f8d0ec9b20066d812a2bbb6350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an Occupied entry with a closure over user type T.  <br /></td></tr>
<tr class="separator:a40387f8d0ec9b20066d812a2bbb6350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e4184fc62027a12fb40edeb814dc09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a84e4184fc62027a12fb40edeb814dc09">CCC_adaptive_map_or_insert_with</a>(adaptive_map_entry_pointer,  type_compound_literal...)</td></tr>
<tr class="memdesc:a84e4184fc62027a12fb40edeb814dc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily insert the desired key value into the entry if it is Vacant.  <br /></td></tr>
<tr class="separator:a84e4184fc62027a12fb40edeb814dc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfea2110af8c19d8c0354d87ec3d63ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#adfea2110af8c19d8c0354d87ec3d63ce">CCC_adaptive_map_insert_entry_with</a>(adaptive_map_entry_pointer,  type_compound_literal...)</td></tr>
<tr class="memdesc:adfea2110af8c19d8c0354d87ec3d63ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of the compound literal type_compound_literal to a node.  <br /></td></tr>
<tr class="separator:adfea2110af8c19d8c0354d87ec3d63ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540350b0b0a0a9efbe0d53a0901add56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a540350b0b0a0a9efbe0d53a0901add56">CCC_adaptive_map_remove_entry_wrap</a>(adaptive_map_entry_pointer)</td></tr>
<tr class="memdesc:a540350b0b0a0a9efbe0d53a0901add56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the entry from the map if Occupied.  <br /></td></tr>
<tr class="separator:a540350b0b0a0a9efbe0d53a0901add56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac717c45b9887784c844343cbfe16c270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ac717c45b9887784c844343cbfe16c270">CCC_adaptive_map_swap_entry</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *type_intruder, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *temp_intruder)</td></tr>
<tr class="memdesc:ac717c45b9887784c844343cbfe16c270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value wrapping type_intruder.  <br /></td></tr>
<tr class="separator:ac717c45b9887784c844343cbfe16c270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72bb878c62d32ffe98f895a86c36c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ad72bb878c62d32ffe98f895a86c36c5c">CCC_adaptive_map_try_insert</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *type_intruder)</td></tr>
<tr class="memdesc:ad72bb878c62d32ffe98f895a86c36c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the key value wrapping type_intruder.  <br /></td></tr>
<tr class="separator:ad72bb878c62d32ffe98f895a86c36c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ae0193f6f6ccbcb059146101722933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a49ae0193f6f6ccbcb059146101722933">CCC_adaptive_map_insert_or_assign</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *type_intruder)</td></tr>
<tr class="memdesc:a49ae0193f6f6ccbcb059146101722933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts or overwrites a user struct into the map.  <br /></td></tr>
<tr class="separator:a49ae0193f6f6ccbcb059146101722933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee70c9d6fb770df81b14d96ac89d6375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#aee70c9d6fb770df81b14d96ac89d6375">CCC_adaptive_map_remove</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *type_output_intruder)</td></tr>
<tr class="memdesc:aee70c9d6fb770df81b14d96ac89d6375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key value in the map storing the old value, if present, in the struct containing type_output_intruder provided by the user.  <br /></td></tr>
<tr class="separator:aee70c9d6fb770df81b14d96ac89d6375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8064edb0e5584f888d4e43c1fa06a49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a8064edb0e5584f888d4e43c1fa06a49a">CCC_adaptive_map_entry</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, void const *key)</td></tr>
<tr class="memdesc:a8064edb0e5584f888d4e43c1fa06a49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains an entry for the provided key in the map for future use.  <br /></td></tr>
<tr class="separator:a8064edb0e5584f888d4e43c1fa06a49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3ce74c4d9858a1f1fceda5d5cd6173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#aeb3ce74c4d9858a1f1fceda5d5cd6173">CCC_adaptive_map_and_modify</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> *entry, <a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *modify)</td></tr>
<tr class="memdesc:aeb3ce74c4d9858a1f1fceda5d5cd6173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the provided entry if it is Occupied.  <br /></td></tr>
<tr class="separator:aeb3ce74c4d9858a1f1fceda5d5cd6173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fec3b768adf75198000b979cde05ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ad2fec3b768adf75198000b979cde05ee">CCC_adaptive_map_and_modify_context</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> *entry, <a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *modify, void *context)</td></tr>
<tr class="memdesc:ad2fec3b768adf75198000b979cde05ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the provided entry if it is Occupied.  <br /></td></tr>
<tr class="separator:ad2fec3b768adf75198000b979cde05ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1afeb764311ed566533db8b28312c7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a1a1afeb764311ed566533db8b28312c7">CCC_adaptive_map_or_insert</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *entry, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *type_intruder)</td></tr>
<tr class="memdesc:a1a1afeb764311ed566533db8b28312c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the struct with handle type_intruder if the entry is Vacant.  <br /></td></tr>
<tr class="separator:a1a1afeb764311ed566533db8b28312c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae807800b0d1d9559377a3480491803f6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ae807800b0d1d9559377a3480491803f6">CCC_adaptive_map_insert_entry</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *entry, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *type_intruder)</td></tr>
<tr class="memdesc:ae807800b0d1d9559377a3480491803f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the provided entry invariantly.  <br /></td></tr>
<tr class="separator:ae807800b0d1d9559377a3480491803f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1e5c1c6fea49b448e2dbaed75c6629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#aba1e5c1c6fea49b448e2dbaed75c6629">CCC_adaptive_map_remove_entry</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> *entry)</td></tr>
<tr class="memdesc:aba1e5c1c6fea49b448e2dbaed75c6629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the entry from the map if Occupied.  <br /></td></tr>
<tr class="separator:aba1e5c1c6fea49b448e2dbaed75c6629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c78546439edc27f4ad51e9a561adff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ae2c78546439edc27f4ad51e9a561adff">CCC_adaptive_map_unwrap</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:ae2c78546439edc27f4ad51e9a561adff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps the provided entry to obtain a view into the map element.  <br /></td></tr>
<tr class="separator:ae2c78546439edc27f4ad51e9a561adff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bcfba9d93a2a5643515c87433fb100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ae0bcfba9d93a2a5643515c87433fb100">CCC_adaptive_map_occupied</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:ae0bcfba9d93a2a5643515c87433fb100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vacant or Occupied status of the entry.  <br /></td></tr>
<tr class="separator:ae0bcfba9d93a2a5643515c87433fb100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700a9f403a9d9fdaa4503dadd5d1a55c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a700a9f403a9d9fdaa4503dadd5d1a55c">CCC_adaptive_map_insert_error</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:a700a9f403a9d9fdaa4503dadd5d1a55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the status of the entry should an insertion follow.  <br /></td></tr>
<tr class="separator:a700a9f403a9d9fdaa4503dadd5d1a55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc5756cf4dd57c8a6070bd837e67db1"><td class="memItemLeft" align="right" valign="top">CCC_Entry_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a1bc5756cf4dd57c8a6070bd837e67db1">CCC_adaptive_map_entry_status</a> (<a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:a1bc5756cf4dd57c8a6070bd837e67db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the entry status from a container entry.  <br /></td></tr>
<tr class="separator:a1bc5756cf4dd57c8a6070bd837e67db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iterator Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and manage iterators over the container. </p>
</td></tr>
<tr class="memitem:af78fb101ce25cc81860102ea54ed472a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#af78fb101ce25cc81860102ea54ed472a">CCC_adaptive_map_equal_range_wrap</a>(map_pointer,  begin_and_end_key_pointers...)</td></tr>
<tr class="memdesc:af78fb101ce25cc81860102ea54ed472a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compound literal reference to the desired range. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:af78fb101ce25cc81860102ea54ed472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eace6ad54d8c23331df4776e4b6c53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ab3eace6ad54d8c23331df4776e4b6c53">CCC_adaptive_map_equal_range_reverse_wrap</a>( map_pointer,  reverse_begin_and_reverse_end_key_pointers...)</td></tr>
<tr class="memdesc:ab3eace6ad54d8c23331df4776e4b6c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compound literal reference to the desired range_reverse. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ab3eace6ad54d8c23331df4776e4b6c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15221b12d38837d3b5f7020c8edb4821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Range.html">CCC_Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a15221b12d38837d3b5f7020c8edb4821">CCC_adaptive_map_equal_range</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, void const *begin_key, void const *end_key)</td></tr>
<tr class="memdesc:a15221b12d38837d3b5f7020c8edb4821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterable range of values from [begin_key, end_key). Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a15221b12d38837d3b5f7020c8edb4821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedabb96a996b904e61bb57bce6251227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a87bdc16619e9a0f9585a8102846c20a8">CCC_Range_reverse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#aedabb96a996b904e61bb57bce6251227">CCC_adaptive_map_equal_range_reverse</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, void const *reverse_begin_key, void const *reverse_end_key)</td></tr>
<tr class="memdesc:aedabb96a996b904e61bb57bce6251227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterable range_reverse of values from [begin_key, end_key). Amortized O(lg N).  <br /></td></tr>
<tr class="separator:aedabb96a996b904e61bb57bce6251227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c0ecaa062f31300cdda1b57b67b4a6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ac4c0ecaa062f31300cdda1b57b67b4a6">CCC_adaptive_map_begin</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:ac4c0ecaa062f31300cdda1b57b67b4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start of an inorder traversal of the map. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ac4c0ecaa062f31300cdda1b57b67b4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4462f0a90c1ac21e4db4be90b3243f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#adf4462f0a90c1ac21e4db4be90b3243f">CCC_adaptive_map_reverse_begin</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:adf4462f0a90c1ac21e4db4be90b3243f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start of a reverse inorder traversal of the map. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:adf4462f0a90c1ac21e4db4be90b3243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a39733480ff0e20c1e9fef871cfc420"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a3a39733480ff0e20c1e9fef871cfc420">CCC_adaptive_map_next</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> const *iterator_intruder)</td></tr>
<tr class="memdesc:a3a39733480ff0e20c1e9fef871cfc420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next element in an inorder traversal of the map. O(1).  <br /></td></tr>
<tr class="separator:a3a39733480ff0e20c1e9fef871cfc420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741ec853cfd02c50fedee12d2d3d07fd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a741ec853cfd02c50fedee12d2d3d07fd">CCC_adaptive_map_reverse_next</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map, <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> const *iterator_intruder)</td></tr>
<tr class="memdesc:a741ec853cfd02c50fedee12d2d3d07fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse_next element in a reverse inorder traversal of the map. O(1).  <br /></td></tr>
<tr class="separator:a741ec853cfd02c50fedee12d2d3d07fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e2cb559cbb3ac8b702a74361cd3e48"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ab2e2cb559cbb3ac8b702a74361cd3e48">CCC_adaptive_map_end</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:ab2e2cb559cbb3ac8b702a74361cd3e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end of an inorder traversal of the map. O(1).  <br /></td></tr>
<tr class="separator:ab2e2cb559cbb3ac8b702a74361cd3e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b468c4dd150937d2a29bdda06c787a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a18b468c4dd150937d2a29bdda06c787a">CCC_adaptive_map_reverse_end</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:a18b468c4dd150937d2a29bdda06c787a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse_end of a reverse inorder traversal of the map. O(1).  <br /></td></tr>
<tr class="separator:a18b468c4dd150937d2a29bdda06c787a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Types available in the container interface. </p>
</td></tr>
<tr class="memitem:a3f0d3fec74866606bc401195872efdf3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a3f0d3fec74866606bc401195872efdf3">CCC_Adaptive_map</a></td></tr>
<tr class="memdesc:a3f0d3fec74866606bc401195872efdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A self-optimizing data structure offering amortized O(lg N) search, insert, and erase and pointer stability.  <br /></td></tr>
<tr class="separator:a3f0d3fec74866606bc401195872efdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69a547af78f7449e34ef8bafbe635b7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ab69a547af78f7449e34ef8bafbe635b7">CCC_Adaptive_map_node</a></td></tr>
<tr class="memdesc:ab69a547af78f7449e34ef8bafbe635b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrusive element for the user defined struct being stored in the map.  <br /></td></tr>
<tr class="separator:ab69a547af78f7449e34ef8bafbe635b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6634e04a00bfa7e2b4b274dd7e6aec61"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionCCC__Adaptive__map__entry__wrap.html">CCC_Adaptive_map_entry_wrap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a6634e04a00bfa7e2b4b274dd7e6aec61">CCC_Adaptive_map_entry</a></td></tr>
<tr class="memdesc:a6634e04a00bfa7e2b4b274dd7e6aec61"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container specific entry used to implement the Entry Interface.  <br /></td></tr>
<tr class="separator:a6634e04a00bfa7e2b4b274dd7e6aec61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Membership Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Test membership or obtain references to stored user types directly. </p>
</td></tr>
<tr class="memitem:a56ee19fcf5bfb20ca2c657c7a9355287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a56ee19fcf5bfb20ca2c657c7a9355287">CCC_adaptive_map_contains</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, void const *key)</td></tr>
<tr class="memdesc:a56ee19fcf5bfb20ca2c657c7a9355287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the map for the presence of key.  <br /></td></tr>
<tr class="separator:a56ee19fcf5bfb20ca2c657c7a9355287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8819d24016ca3750039318da7e43da7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#ac8819d24016ca3750039318da7e43da7">CCC_adaptive_map_get_key_value</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, void const *key)</td></tr>
<tr class="memdesc:ac8819d24016ca3750039318da7e43da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference into the map at entry key.  <br /></td></tr>
<tr class="separator:ac8819d24016ca3750039318da7e43da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Destroy the container. </p>
</td></tr>
<tr class="memitem:a6dde8f2788ecd0346acb885f20d068c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a6dde8f2788ecd0346acb885f20d068c1">CCC_adaptive_map_clear</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *map, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy)</td></tr>
<tr class="memdesc:a6dde8f2788ecd0346acb885f20d068c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops every element from the map calling destructor if destructor is non-NULL. O(N).  <br /></td></tr>
<tr class="separator:a6dde8f2788ecd0346acb885f20d068c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain the container state. </p>
</td></tr>
<tr class="memitem:a9d37b5a183942a14f309f959103893df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a9d37b5a183942a14f309f959103893df">CCC_adaptive_map_is_empty</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:a9d37b5a183942a14f309f959103893df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size status of the map.  <br /></td></tr>
<tr class="separator:a9d37b5a183942a14f309f959103893df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55d16b66a2bebbad25b45849c53a920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#af55d16b66a2bebbad25b45849c53a920">CCC_adaptive_map_count</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:af55d16b66a2bebbad25b45849c53a920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of occupied map nodes.  <br /></td></tr>
<tr class="separator:af55d16b66a2bebbad25b45849c53a920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af103d79e696342b118f0beab1d3fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptive__map_8h.html#a1af103d79e696342b118f0beab1d3fb6">CCC_adaptive_map_validate</a> (<a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:a1af103d79e696342b118f0beab1d3fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validation of invariants for the map.  <br /></td></tr>
<tr class="separator:a1af103d79e696342b118f0beab1d3fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a40387f8d0ec9b20066d812a2bbb6350e" name="a40387f8d0ec9b20066d812a2bbb6350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40387f8d0ec9b20066d812a2bbb6350e">&#9670;&#160;</a></span>CCC_adaptive_map_and_modify_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_and_modify_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adaptive_map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">closure_over_T...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="adaptive__map_8h.html#a6634e04a00bfa7e2b4b274dd7e6aec61">CCC_Adaptive_map_entry</a>)                                                  \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_adaptive_map_and_modify_with(adaptive_map_entry_pointer,   \</div>
<div class="line">                                                 type_name, closure_over_T)    \</div>
<div class="line">    }</div>
<div class="ttc" id="aadaptive__map_8h_html_a6634e04a00bfa7e2b4b274dd7e6aec61"><div class="ttname"><a href="adaptive__map_8h.html#a6634e04a00bfa7e2b4b274dd7e6aec61">CCC_Adaptive_map_entry</a></div><div class="ttdeci">union CCC_Adaptive_map_entry_wrap CCC_Adaptive_map_entry</div><div class="ttdoc">A container specific entry used to implement the Entry Interface.</div><div class="ttdef"><b>Definition:</b> adaptive_map.h:74</div></div>
</div><!-- fragment -->
<p>Modify an Occupied entry with a closure over user type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">adaptive_map_entry_pointer</td><td>a pointer to the obtained entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the user type stored in the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">closure_over_T</td><td>the code to be run on the reference to user type T, if Occupied. This may be a semicolon separated list of statements to execute on T or a section of code wrapped in braces {code here} which may be preferred for formatting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the modified entry if it was occupied or a vacant entry if it was vacant. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>T is a reference to the user type stored in the entry guaranteed to be non-NULL if the closure executes.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#define ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="comment">// Increment the count if found otherwise do nothing.</span></div>
<div class="line">Adaptive_map_entry *entry =</div>
<div class="line">    adaptive_map_and_modify_with(</div>
<div class="line">        entry_wrap(&amp;map, &amp;k),</div>
<div class="line">        Word,</div>
<div class="line">        T-&gt;cnt++;</div>
<div class="line">    );</div>
<div class="line"><span class="comment">// Increment the count if found otherwise insert a default value.</span></div>
<div class="line">Word *w =</div>
<div class="line">    adaptive_map_or_insert_with(</div>
<div class="line">        adaptive_map_and_modify_with(</div>
<div class="line">            entry_wrap(&amp;map, &amp;k),</div>
<div class="line">            Word,</div>
<div class="line">            { T-&gt;cnt++; }</div>
<div class="line">        ),</div>
<div class="line">        (Word){.key = k, .cnt = 1}</div>
<div class="line">    );</div>
</div><!-- fragment --><p>Note that any code written is only evaluated if the entry is Occupied and the container can deliver the user type T. This means any function calls are lazily evaluated in the closure scope. </p>

</div>
</div>
<a id="a2378a144497ffa75fb0ca22d3a5d1bd6" name="a2378a144497ffa75fb0ca22d3a5d1bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2378a144497ffa75fb0ca22d3a5d1bd6">&#9670;&#160;</a></span>CCC_adaptive_map_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="adaptive__map_8h.html#a6634e04a00bfa7e2b4b274dd7e6aec61">CCC_Adaptive_map_entry</a>)                                                  \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_adaptive_map_entry((map_pointer), (key_pointer)).private           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Obtains an entry for the provided key in the map for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the map to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>the key used to search the map matching the stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to a specialized entry for use with other functions in the Entry Interface. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the contents of an entry should not be examined or modified. Use the provided functions, only.</dd></dl>
<p>An entry is a search result that provides either an Occupied or Vacant entry in the map. An occupied entry signifies that the search was successful. A Vacant entry means the search was not successful but a handle is gained to where in the map such an element should be inserted.</p>
<p>An entry is rarely useful on its own. It should be passed in a functional style to subsequent calls in the Entry Interface. </p>

</div>
</div>
<a id="ab3eace6ad54d8c23331df4776e4b6c53" name="ab3eace6ad54d8c23331df4776e4b6c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3eace6ad54d8c23331df4776e4b6c53">&#9670;&#160;</a></span>CCC_adaptive_map_equal_range_reverse_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_equal_range_reverse_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reverse_begin_and_reverse_end_key_pointers...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="types_8h.html#a87bdc16619e9a0f9585a8102846c20a8">CCC_Range_reverse</a>)                                                       \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_adaptive_map_equal_range_reverse(                                  \</div>
<div class="line">            map_pointer, reverse_begin_and_reverse_end_key_pointers)           \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
<div class="ttc" id="atypes_8h_html_a87bdc16619e9a0f9585a8102846c20a8"><div class="ttname"><a href="types_8h.html#a87bdc16619e9a0f9585a8102846c20a8">CCC_Range_reverse</a></div><div class="ttdeci">union CCC_Range_reverse_wrap CCC_Range_reverse</div><div class="ttdoc">The result of a range_reverse query on iterable containers.</div><div class="ttdef"><b>Definition:</b> types.h:52</div></div>
</div><!-- fragment -->
<p>Returns a compound literal reference to the desired range_reverse. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse_begin_and_reverse_end_key_pointers</td><td>two pointers, one to the start of the range_reverse and a second to the end of the range_reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the produced range_reverse associated with the enclosing scope. This reference is always non-NULL. </dd></dl>

</div>
</div>
<a id="af78fb101ce25cc81860102ea54ed472a" name="af78fb101ce25cc81860102ea54ed472a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78fb101ce25cc81860102ea54ed472a">&#9670;&#160;</a></span>CCC_adaptive_map_equal_range_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_equal_range_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">begin_and_end_key_pointers...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Range.html">CCC_Range</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_adaptive_map_equal_range(map_pointer, begin_and_end_key_pointers)  \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
<div class="ttc" id="astructCCC__Range_html"><div class="ttname"><a href="structCCC__Range.html">CCC_Range</a></div><div class="ttdef"><b>Definition:</b> private_types.h:112</div></div>
</div><!-- fragment -->
<p>Returns a compound literal reference to the desired range. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_and_end_key_pointers</td><td>two pointers, one to the start of the range and a second to the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the produced range associated with the enclosing scope. This reference is always non-NULL. </dd></dl>

</div>
</div>
<a id="a7874b40de99cc78375eb87e5b6dfe5d7" name="a7874b40de99cc78375eb87e5b6dfe5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7874b40de99cc78375eb87e5b6dfe5d7">&#9670;&#160;</a></span>CCC_adaptive_map_from</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_from</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_intruder_field_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_key_field_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destroy, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal_array...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__adaptive__map_8h.html#a1d7b14b34ad17ca1167262ddc71b2aa9">CCC_private_adaptive_map_from</a>(                                             \</div>
<div class="line">        type_intruder_field_name, type_key_field_name, compare, allocate,      \</div>
<div class="line">        destroy, context_data, compound_literal_array)</div>
<div class="ttc" id="aprivate__adaptive__map_8h_html_a1d7b14b34ad17ca1167262ddc71b2aa9"><div class="ttname"><a href="private__adaptive__map_8h.html#a1d7b14b34ad17ca1167262ddc71b2aa9">CCC_private_adaptive_map_from</a></div><div class="ttdeci">#define CCC_private_adaptive_map_from( private_type_intruder_field_name, private_key_field_name, private_compare, private_allocate, private_destroy, private_context_data, private_compound_literal_array...)</div><div class="ttdef"><b>Definition:</b> private_adaptive_map.h:145</div></div>
</div><!-- fragment -->
<p>Initializes a dynamic adaptive map at runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder_field_name</td><td>the name of the intrusive map elem field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_key_field_name</td><td>the name of the field in user type used as key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the key comparison function (see <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function or NULL if allocation is banned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destructor function used to act on every node in case initialization of new nodes fails and map is emptied in a failure state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>a pointer to any context data for comparison or destruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal_array</td><td>the array of user types to insert into the map (e.g. (struct My_type[]){ {.key = 1, .val = 1}, {.key = 2, .val = 2}}). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the struct initialized adaptive map for direct assignment (e.g. <a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> m = <a class="el" href="adaptive__map_8h.html#a7874b40de99cc78375eb87e5b6dfe5d7" title="Initializes a dynamic adaptive map at runtime.">CCC_adaptive_map_from(...)</a>;) or an empty map if allocation fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If any node allocation fails while copying in the values in the compound literal array of user types, the map is cleared; if a destructor is provided, it is called on each node and they are freed using the provided allocate function. </dd></dl>

</div>
</div>
<a id="ab34ca82a0748237e96162762b9d7d2fb" name="ab34ca82a0748237e96162762b9d7d2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34ca82a0748237e96162762b9d7d2fb">&#9670;&#160;</a></span>CCC_adaptive_map_initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_initialize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">struct_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_intruder_field_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_key_field_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_order, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__adaptive__map_8h.html#adcbaf6d56616ac27ca5b0dd71b91dae2">CCC_private_adaptive_map_initialize</a>(struct_name, type_intruder_field_name, \</div>
<div class="line">                                        type_key_field_name, key_order,        \</div>
<div class="line">                                        allocate, context)</div>
<div class="ttc" id="aprivate__adaptive__map_8h_html_adcbaf6d56616ac27ca5b0dd71b91dae2"><div class="ttname"><a href="private__adaptive__map_8h.html#adcbaf6d56616ac27ca5b0dd71b91dae2">CCC_private_adaptive_map_initialize</a></div><div class="ttdeci">#define CCC_private_adaptive_map_initialize( private_struct_name, private_node_node_field, private_key_node_field, private_key_comparator, private_allocate, private_context_data)</div><div class="ttdef"><b>Definition:</b> private_adaptive_map.h:129</div></div>
</div><!-- fragment -->
<p>Initializes the adaptive map at runtime or compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">struct_name</td><td>the user type wrapping the intrusive element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder_field_name</td><td>the name of the intrusive map element field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_key_field_name</td><td>the name of the field in user type used as key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_order</td><td>the key comparison function (see <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function or NULL if allocation is banned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>a pointer to any context data for comparison or destruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the struct initialized adaptive map for direct assignment (i.e. <a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> m = <a class="el" href="adaptive__map_8h.html#ab34ca82a0748237e96162762b9d7d2fb" title="Initializes the adaptive map at runtime or compile time.">CCC_adaptive_map_initialize(...)</a>;). </dd></dl>

</div>
</div>
<a id="adfea2110af8c19d8c0354d87ec3d63ce" name="adfea2110af8c19d8c0354d87ec3d63ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfea2110af8c19d8c0354d87ec3d63ce">&#9670;&#160;</a></span>CCC_adaptive_map_insert_entry_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_insert_entry_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adaptive_map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__adaptive__map_8h.html#a64f30de6e328019fee42e5fe11f935c5">CCC_private_adaptive_map_insert_entry_with</a>(adaptive_map_entry_pointer,     \</div>
<div class="line">                                               type_compound_literal)</div>
<div class="ttc" id="aprivate__adaptive__map_8h_html_a64f30de6e328019fee42e5fe11f935c5"><div class="ttname"><a href="private__adaptive__map_8h.html#a64f30de6e328019fee42e5fe11f935c5">CCC_private_adaptive_map_insert_entry_with</a></div><div class="ttdeci">#define CCC_private_adaptive_map_insert_entry_with(adaptive_map_entry_pointer, type_compound_literal...)</div><div class="ttdef"><b>Definition:</b> private_adaptive_map.h:321</div></div>
</div><!-- fragment -->
<p>Write the contents of the compound literal type_compound_literal to a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">adaptive_map_entry_pointer</td><td>a pointer to the obtained entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal to write to a new slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly inserted or overwritten user type. NULL is returned if allocation failed or is not allowed when required. </dd></dl>

</div>
</div>
<a id="a6a398f842fb0da7e8ec83ae3a5b585b2" name="a6a398f842fb0da7e8ec83ae3a5b585b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a398f842fb0da7e8ec83ae3a5b585b2">&#9670;&#160;</a></span>CCC_adaptive_map_insert_or_assign_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_insert_or_assign_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal_type...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_adaptive_map_insert_or_assign_with(map_pointer, key,       \</div>
<div class="line">                                                       compound_literal_type)  \</div>
<div class="line">    }</div>
<div class="ttc" id="astructCCC__Entry_html"><div class="ttname"><a href="structCCC__Entry.html">CCC_Entry</a></div><div class="ttdef"><b>Definition:</b> private_types.h:53</div></div>
</div><!-- fragment -->
<p>Inserts a new key value pair or overwrites the existing entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key to be searched in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal_type</td><td>the compound literal to insert or use for overwrite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the entry of the existing or newly inserted value. Occupied indicates the key existed, Vacant indicates the key was absent. Unwrapping in any case provides the current value unless an error occurs that prevents insertion. An insertion error will flag such a case.</dd></dl>
<p>Note that for brevity and convenience the user need not write the key to the lazy value compound literal as well. This function ensures the key in the compound literal matches the searched key. </p>

</div>
</div>
<a id="a84e4184fc62027a12fb40edeb814dc09" name="a84e4184fc62027a12fb40edeb814dc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e4184fc62027a12fb40edeb814dc09">&#9670;&#160;</a></span>CCC_adaptive_map_or_insert_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_or_insert_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adaptive_map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__adaptive__map_8h.html#ac29b717071ba30a39df6a6471a08705f">CCC_private_adaptive_map_or_insert_with</a>(adaptive_map_entry_pointer,        \</div>
<div class="line">                                            type_compound_literal)</div>
<div class="ttc" id="aprivate__adaptive__map_8h_html_ac29b717071ba30a39df6a6471a08705f"><div class="ttname"><a href="private__adaptive__map_8h.html#ac29b717071ba30a39df6a6471a08705f">CCC_private_adaptive_map_or_insert_with</a></div><div class="ttdeci">#define CCC_private_adaptive_map_or_insert_with(adaptive_map_entry_pointer, type_compound_literal...)</div><div class="ttdef"><b>Definition:</b> private_adaptive_map.h:294</div></div>
</div><!-- fragment -->
<p>Lazily insert the desired key value into the entry if it is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">adaptive_map_entry_pointer</td><td>a pointer to the obtained entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal to construct in place if the entry is Vacant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the unwrapped user type in the entry, either the unmodified reference if the entry was Occupied or the newly inserted element if the entry was Vacant. NULL is returned if resizing is required but fails or is not allowed.</dd></dl>
<p>Note that if the compound literal uses any function calls to generate values or other data, such functions will not be called if the entry is Occupied. </p>

</div>
</div>
<a id="a540350b0b0a0a9efbe0d53a0901add56" name="a540350b0b0a0a9efbe0d53a0901add56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540350b0b0a0a9efbe0d53a0901add56">&#9670;&#160;</a></span>CCC_adaptive_map_remove_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_remove_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adaptive_map_entry_pointer</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_adaptive_map_remove_entry((adaptive_map_entry_pointer)).private    \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the entry from the map if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">adaptive_map_entry_pointer</td><td>a pointer to the map entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to an entry containing NULL or a reference to the old entry. If Occupied an entry in the map existed and was removed. If Vacant, no prior entry existed to be removed.</dd></dl>
<p>Note that if allocation is permitted the old element is freed and the entry will contain a NULL reference. If allocation is prohibited the entry can be unwrapped to obtain the old user struct stored in the map and the user may free or use as needed. </p>

</div>
</div>
<a id="a71ae3888e95d0da2460bf598305e80d4" name="a71ae3888e95d0da2460bf598305e80d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ae3888e95d0da2460bf598305e80d4">&#9670;&#160;</a></span>CCC_adaptive_map_remove_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_remove_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_output_intruder_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_adaptive_map_remove((map_pointer), (type_output_intruder_pointer)) \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Removes the key value in the map storing the old value, if present, in the struct containing type_output_intruder provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the adaptive map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output_intruder_pointer</td><td>the handle to the user type wrapping map node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the removed entry. If Occupied it may be unwrapped to obtain the old key value pair. If Vacant the key value pair was not stored in the map. If bad input is provided an input error is set.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in an entry to provide information about the old value.</p>
<p>If allocation has been prohibited upon initialization then the entry returned contains the previously stored user type, if any, and nothing is written to the type_output_intruder. It is then the user's responsibility to manage their previously stored memory as they see fit. </p>

</div>
</div>
<a id="a489d1a4248eed36ec884db29afd437ba" name="a489d1a4248eed36ec884db29afd437ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489d1a4248eed36ec884db29afd437ba">&#9670;&#160;</a></span>CCC_adaptive_map_swap_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_swap_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_intruder_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">temp_intruder_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_adaptive_map_swap_entry((map_pointer), (type_intruder_pointer),    \</div>
<div class="line">                                    (temp_intruder_pointer))                   \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invariantly inserts the key value wrapping the provided intruder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the adaptive map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder_pointer</td><td>the handle to the user type wrapping this handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp_intruder_pointer</td><td>handle to space for swapping in the old value, if present. The same user type stored in the map should wrap temp_intruder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to an entry. If Vacant, no prior element with key existed and the type wrapping temp_intruder remains unchanged. If Occupied the old value is written to the type wrapping temp_intruder and may be unwrapped to view. If more space is needed but allocation fails or has been forbidden, an insert error is set.</dd></dl>
<p>Note that this function may write to the struct containing temp_intruder and wraps it in an entry to provide information about the old value. </p>

</div>
</div>
<a id="af0b3fa6736c783e094b85b335422d017" name="af0b3fa6736c783e094b85b335422d017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b3fa6736c783e094b85b335422d017">&#9670;&#160;</a></span>CCC_adaptive_map_try_insert_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_try_insert_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal_type...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_adaptive_map_try_insert_with(map_pointer, key,             \</div>
<div class="line">                                                 compound_literal_type)        \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>lazily insert compound_literal_type into the map at key if key is absent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the direct key r-value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal_type</td><td>the compound literal specifying the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the entry of the existing or newly inserted value. Occupied indicates the key existed, Vacant indicates the key was absent. Unwrapping in any case provides the current value unless an error occurs that prevents insertion. An insertion error will flag such a case.</dd></dl>
<p>Note that for brevity and convenience the user need not write the key to the lazy value compound literal as well. This function ensures the key in the compound literal matches the searched key. </p>

</div>
</div>
<a id="ad6162debb2e5dab39637763145d6a15e" name="ad6162debb2e5dab39637763145d6a15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6162debb2e5dab39637763145d6a15e">&#9670;&#160;</a></span>CCC_adaptive_map_try_insert_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_adaptive_map_try_insert_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_intruder_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_adaptive_map_try_insert((map_pointer), (type_intruder_pointer))    \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Attempts to insert the key value wrapping type_intruder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder_pointer</td><td>the handle to the user type wrapping map node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to an entry. If Occupied, the entry contains a reference to the key value user type in the map and may be unwrapped. If Vacant the entry contains a reference to the newly inserted entry in the map. If more space is needed but allocation fails or has been forbidden, an insert error is set. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3f0d3fec74866606bc401195872efdf3" name="a3f0d3fec74866606bc401195872efdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0d3fec74866606bc401195872efdf3">&#9670;&#160;</a></span>CCC_Adaptive_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> <a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A self-optimizing data structure offering amortized O(lg N) search, insert, and erase and pointer stability. </p>
<dl class="section warning"><dt>Warning</dt><dd>it is undefined behavior to access an uninitialized container.</dd></dl>
<p>An adaptive map can be initialized on the stack, heap, or data segment at runtime or compile time. </p>

</div>
</div>
<a id="a6634e04a00bfa7e2b4b274dd7e6aec61" name="a6634e04a00bfa7e2b4b274dd7e6aec61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6634e04a00bfa7e2b4b274dd7e6aec61">&#9670;&#160;</a></span>CCC_Adaptive_map_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionCCC__Adaptive__map__entry__wrap.html">CCC_Adaptive_map_entry_wrap</a> <a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container specific entry used to implement the Entry Interface. </p>
<p>The Entry Interface offers efficient search and subsequent insertion, deletion, or value update based on the needs of the user. </p>

</div>
</div>
<a id="ab69a547af78f7449e34ef8bafbe635b7" name="ab69a547af78f7449e34ef8bafbe635b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69a547af78f7449e34ef8bafbe635b7">&#9670;&#160;</a></span>CCC_Adaptive_map_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> <a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intrusive element for the user defined struct being stored in the map. </p>
<p>Note that if allocation is not permitted, insertions functions accepting this type as an argument assume it to exist in pre-allocated memory that will exist with the appropriate lifetime and scope for the user's needs; the container does not allocate or free in this case. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aeb3ce74c4d9858a1f1fceda5d5cd6173" name="aeb3ce74c4d9858a1f1fceda5d5cd6173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3ce74c4d9858a1f1fceda5d5cd6173">&#9670;&#160;</a></span>CCC_adaptive_map_and_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> * CCC_adaptive_map_and_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *&#160;</td>
          <td class="paramname"><em>modify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the provided entry if it is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry obtained from an entry function or macro. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify</td><td>an update function in which the context argument is unused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated entry if it was Occupied or the unmodified vacant entry.</dd></dl>
<p>This function is intended to make the function chaining in the Entry Interface more succinct if the entry will be modified in place based on its own value without the need of the context argument a CCC_Type_modifier can provide. </p>

</div>
</div>
<a id="ad2fec3b768adf75198000b979cde05ee" name="ad2fec3b768adf75198000b979cde05ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fec3b768adf75198000b979cde05ee">&#9670;&#160;</a></span>CCC_adaptive_map_and_modify_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> * CCC_adaptive_map_and_modify_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *&#160;</td>
          <td class="paramname"><em>modify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the provided entry if it is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry obtained from an entry function or macro. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify</td><td>an update function that requires context data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>context data required for the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated entry if it was Occupied or the unmodified vacant entry.</dd></dl>
<p>This function makes full use of a CCC_Type_modifier capability, meaning a complete CCC_update object will be passed to the update function callback. </p>

</div>
</div>
<a id="ac4c0ecaa062f31300cdda1b57b67b4a6" name="ac4c0ecaa062f31300cdda1b57b67b4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c0ecaa062f31300cdda1b57b67b4a6">&#9670;&#160;</a></span>CCC_adaptive_map_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the start of an inorder traversal of the map. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the oldest minimum element of the map. </dd></dl>

</div>
</div>
<a id="a6dde8f2788ecd0346acb885f20d068c1" name="a6dde8f2788ecd0346acb885f20d068c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dde8f2788ecd0346acb885f20d068c1">&#9670;&#160;</a></span>CCC_adaptive_map_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_adaptive_map_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops every element from the map calling destructor if destructor is non-NULL. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>a destructor function if required. NULL if unneeded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an input error if map points to NULL otherwise OK.</dd></dl>
<p>Note that if the map has been given permission to allocate, the destructor will be called on each element before it uses the provided allocator to free the element. Therefore, the destructor should not free the element or a double free will occur.</p>
<p>If the container has not been given allocation permission, then the destructor may free elements or not depending on how and when the user wishes to free elements of the map according to their own memory management schemes. </p>

</div>
</div>
<a id="a56ee19fcf5bfb20ca2c657c7a9355287" name="a56ee19fcf5bfb20ca2c657c7a9355287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ee19fcf5bfb20ca2c657c7a9355287">&#9670;&#160;</a></span>CCC_adaptive_map_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_adaptive_map_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the map for the presence of key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>pointer to the key matching the key type of the user struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the struct containing key is stored, false if not. Error if map or key is NULL. </dd></dl>

</div>
</div>
<a id="af55d16b66a2bebbad25b45849c53a920" name="af55d16b66a2bebbad25b45849c53a920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55d16b66a2bebbad25b45849c53a920">&#9670;&#160;</a></span>CCC_adaptive_map_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_adaptive_map_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the count of occupied map nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size or an argument error is set if map is NULL. </dd></dl>

</div>
</div>
<a id="ab2e2cb559cbb3ac8b702a74361cd3e48" name="ab2e2cb559cbb3ac8b702a74361cd3e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e2cb559cbb3ac8b702a74361cd3e48">&#9670;&#160;</a></span>CCC_adaptive_map_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the end of an inorder traversal of the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newest maximum element of the map. </dd></dl>

</div>
</div>
<a id="a8064edb0e5584f888d4e43c1fa06a49a" name="a8064edb0e5584f888d4e43c1fa06a49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8064edb0e5584f888d4e43c1fa06a49a">&#9670;&#160;</a></span>CCC_adaptive_map_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> CCC_adaptive_map_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains an entry for the provided key in the map for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key used to search the map matching the stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a specialized entry for use with other functions in the Entry Interface. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the contents of an entry should not be examined or modified. Use the provided functions, only.</dd></dl>
<p>An entry is a search result that provides either an Occupied or Vacant entry in the map. An occupied entry signifies that the search was successful. A Vacant entry means the search was not successful but a handle is gained to where in the map such an element should be inserted.</p>
<p>An entry is rarely useful on its own. It should be passed in a functional style to subsequent calls in the Entry Interface. </p>

</div>
</div>
<a id="a1bc5756cf4dd57c8a6070bd837e67db1" name="a1bc5756cf4dd57c8a6070bd837e67db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc5756cf4dd57c8a6070bd837e67db1">&#9670;&#160;</a></span>CCC_adaptive_map_entry_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCC_Entry_status CCC_adaptive_map_entry_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the entry status from a container entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>a pointer to the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the status stored in the entry after the required action on the container completes. If entry is NULL an entry input error is returned so ensure e is non-NULL to avoid an inaccurate status returned.</dd></dl>
<p>Note that this function can be useful for debugging or if more detailed messages are needed for logging purposes. See <a class="el" href="types_8h.html#ad07b2e77418d28789f9eb6723d2b59b7" title="Obtain a string message with a description of the entry status.">CCC_entry_status_message()</a> in <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">ccc/types.h</a> for more information on detailed entry statuses. </p>

</div>
</div>
<a id="a15221b12d38837d3b5f7020c8edb4821" name="a15221b12d38837d3b5f7020c8edb4821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15221b12d38837d3b5f7020c8edb4821">&#9670;&#160;</a></span>CCC_adaptive_map_equal_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Range.html">CCC_Range</a> CCC_adaptive_map_equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>begin_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>end_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterable range of values from [begin_key, end_key). Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_key</td><td>a pointer to the key intended as the start of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_key</td><td>a pointer to the key intended as the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range containing the first element NOT LESS than the begin_key and the first element GREATER than end_key.</dd></dl>
<p>Note that due to the variety of values that can be returned in the range, using the provided range iteration functions from <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a> is recommended for example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">struct</span> Val *i = range_begin(&amp;range);</div>
<div class="line">     i != range_end(&amp;range);</div>
<div class="line">     i = next(&amp;map, &amp;i-&gt;type_intruder))</div>
<div class="line">{}</div>
</div><!-- fragment --><p>This avoids any possible errors in handling an end range element that is in the map versus the end map sentinel. </p>

</div>
</div>
<a id="aedabb96a996b904e61bb57bce6251227" name="aedabb96a996b904e61bb57bce6251227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedabb96a996b904e61bb57bce6251227">&#9670;&#160;</a></span>CCC_adaptive_map_equal_range_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a87bdc16619e9a0f9585a8102846c20a8">CCC_Range_reverse</a> CCC_adaptive_map_equal_range_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>reverse_begin_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>reverse_end_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterable range_reverse of values from [begin_key, end_key). Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse_begin_key</td><td>a pointer to the key intended as the start of the range_reverse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse_end_key</td><td>a pointer to the key intended as the end of the range_reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range_reverse containing the first element NOT GREATER than the begin_key and the first element LESS than reverse_end_key.</dd></dl>
<p>Note that due to the variety of values that can be returned in the range_reverse, using the provided range_reverse iteration functions from <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a> is recommended for example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">struct</span> Val *i = range_reverse_begin(&amp;range_reverse);</div>
<div class="line">     i != range_reverse_end(&amp;range_reverse);</div>
<div class="line">     i = reverse_next(&amp;map, &amp;i-&gt;type_intruder))</div>
<div class="line">{}</div>
</div><!-- fragment --><p>This avoids any possible errors in handling an reverse_end range_reverse element that is in the map versus the end map sentinel. </p>

</div>
</div>
<a id="ac8819d24016ca3750039318da7e43da7" name="ac8819d24016ca3750039318da7e43da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8819d24016ca3750039318da7e43da7">&#9670;&#160;</a></span>CCC_adaptive_map_get_key_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_get_key_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference into the map at entry key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the adaptive map to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key to search matching stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the map entry if it is present, else NULL. </dd></dl>

</div>
</div>
<a id="ae807800b0d1d9559377a3480491803f6" name="ae807800b0d1d9559377a3480491803f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae807800b0d1d9559377a3480491803f6">&#9670;&#160;</a></span>CCC_adaptive_map_insert_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *&#160;</td>
          <td class="paramname"><em>type_intruder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the provided entry invariantly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry returned from a call obtaining an entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder</td><td>a handle to the struct the user intends to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inserted element or NULL upon allocation failure.</dd></dl>
<p>This method can be used when the old value in the map does not need to be preserved. See the regular insert method if the old value is of interest. </p>

</div>
</div>
<a id="a700a9f403a9d9fdaa4503dadd5d1a55c" name="a700a9f403a9d9fdaa4503dadd5d1a55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700a9f403a9d9fdaa4503dadd5d1a55c">&#9670;&#160;</a></span>CCC_adaptive_map_insert_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_adaptive_map_insert_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the status of the entry should an insertion follow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry from a query to the table via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an entry obtained from an insertion attempt failed to insert due to an allocation failure when allocation success was expected. Error if entry is NULL. </dd></dl>

</div>
</div>
<a id="a49ae0193f6f6ccbcb059146101722933" name="a49ae0193f6f6ccbcb059146101722933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ae0193f6f6ccbcb059146101722933">&#9670;&#160;</a></span>CCC_adaptive_map_insert_or_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_adaptive_map_insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *&#160;</td>
          <td class="paramname"><em>type_intruder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts or overwrites a user struct into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder</td><td>the handle to the wrapping user struct key value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry. If Occupied an entry was overwritten by the new key value. If Vacant no prior map entry existed.</dd></dl>
<p>Note that this function can be used when the old user type is not needed but the information regarding its presence is helpful. </p>

</div>
</div>
<a id="a9d37b5a183942a14f309f959103893df" name="a9d37b5a183942a14f309f959103893df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d37b5a183942a14f309f959103893df">&#9670;&#160;</a></span>CCC_adaptive_map_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_adaptive_map_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size status of the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty else false. Error if map is NULL. </dd></dl>

</div>
</div>
<a id="a3a39733480ff0e20c1e9fef871cfc420" name="a3a39733480ff0e20c1e9fef871cfc420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a39733480ff0e20c1e9fef871cfc420">&#9670;&#160;</a></span>CCC_adaptive_map_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> const *&#160;</td>
          <td class="paramname"><em>iterator_intruder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next element in an inorder traversal of the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator_intruder</td><td>a pointer to the intrusive map element of the current iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next user type stored in the map in an inorder traversal. </dd></dl>

</div>
</div>
<a id="ae0bcfba9d93a2a5643515c87433fb100" name="ae0bcfba9d93a2a5643515c87433fb100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bcfba9d93a2a5643515c87433fb100">&#9670;&#160;</a></span>CCC_adaptive_map_occupied()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_adaptive_map_occupied </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Vacant or Occupied status of the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry from a query to the map via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry is occupied, false if not. Error if entry is NULL. </dd></dl>

</div>
</div>
<a id="a1a1afeb764311ed566533db8b28312c7" name="a1a1afeb764311ed566533db8b28312c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1afeb764311ed566533db8b28312c7">&#9670;&#160;</a></span>CCC_adaptive_map_or_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_or_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *&#160;</td>
          <td class="paramname"><em>type_intruder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the struct with handle type_intruder if the entry is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry obtained via function or macro call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder</td><td>the handle to the struct to be inserted to a Vacant entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to entry in the map invariantly. NULL on error.</dd></dl>
<p>Because this functions takes an entry and inserts if it is Vacant, the only reason NULL shall be returned is when an insertion error occurs, usually due to a user struct allocation failure.</p>
<p>If no allocation is permitted, this function assumes the user struct wrapping type_intruder has been allocated with the appropriate lifetime and scope by the user. </p>

</div>
</div>
<a id="aee70c9d6fb770df81b14d96ac89d6375" name="aee70c9d6fb770df81b14d96ac89d6375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee70c9d6fb770df81b14d96ac89d6375">&#9670;&#160;</a></span>CCC_adaptive_map_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_adaptive_map_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *&#160;</td>
          <td class="paramname"><em>type_output_intruder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the key value in the map storing the old value, if present, in the struct containing type_output_intruder provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the adaptive map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output_intruder</td><td>the handle to the user type wrapping map node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed entry. If Occupied it may be unwrapped to obtain the old key value pair. If Vacant the key value pair was not stored in the map. If bad input is provided an input error is set.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in an entry to provide information about the old value.</p>
<p>If allocation has been prohibited upon initialization then the entry returned contains the previously stored user type, if any, and nothing is written to the type_output_intruder. It is then the user's responsibility to manage their previously stored memory as they see fit. </p>

</div>
</div>
<a id="aba1e5c1c6fea49b448e2dbaed75c6629" name="aba1e5c1c6fea49b448e2dbaed75c6629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1e5c1c6fea49b448e2dbaed75c6629">&#9670;&#160;</a></span>CCC_adaptive_map_remove_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_adaptive_map_remove_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the entry from the map if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>a pointer to the map entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry containing NULL or a reference to the old entry. If Occupied an entry in the map existed and was removed. If Vacant, no prior entry existed to be removed.</dd></dl>
<p>Note that if allocation is permitted the old element is freed and the entry will contain a NULL reference. If allocation is prohibited the entry can be unwrapped to obtain the old user struct stored in the map and the user may free or use as needed. </p>

</div>
</div>
<a id="adf4462f0a90c1ac21e4db4be90b3243f" name="adf4462f0a90c1ac21e4db4be90b3243f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4462f0a90c1ac21e4db4be90b3243f">&#9670;&#160;</a></span>CCC_adaptive_map_reverse_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_reverse_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the start of a reverse inorder traversal of the map. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the oldest maximum element of the map. </dd></dl>

</div>
</div>
<a id="a18b468c4dd150937d2a29bdda06c787a" name="a18b468c4dd150937d2a29bdda06c787a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b468c4dd150937d2a29bdda06c787a">&#9670;&#160;</a></span>CCC_adaptive_map_reverse_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_reverse_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse_end of a reverse inorder traversal of the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newest minimum element of the map. </dd></dl>

</div>
</div>
<a id="a741ec853cfd02c50fedee12d2d3d07fd" name="a741ec853cfd02c50fedee12d2d3d07fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741ec853cfd02c50fedee12d2d3d07fd">&#9670;&#160;</a></span>CCC_adaptive_map_reverse_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_reverse_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> const *&#160;</td>
          <td class="paramname"><em>iterator_intruder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse_next element in a reverse inorder traversal of the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator_intruder</td><td>a pointer to the intrusive map element of the current iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reverse_next user type stored in the map in a reverse inorder traversal. </dd></dl>

</div>
</div>
<a id="ac717c45b9887784c844343cbfe16c270" name="ac717c45b9887784c844343cbfe16c270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac717c45b9887784c844343cbfe16c270">&#9670;&#160;</a></span>CCC_adaptive_map_swap_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_adaptive_map_swap_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *&#160;</td>
          <td class="paramname"><em>type_intruder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *&#160;</td>
          <td class="paramname"><em>temp_intruder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts the key value wrapping type_intruder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the adaptive map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder</td><td>the handle to the user type wrapping map node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp_intruder</td><td>handle to space for swapping in the old value, if present. The user must provide this additional type (e.g. <code>&amp;(my_type){}</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry. If Vacant, no prior element with key existed and the type wrapping swap_intruder remains unchanged. If Occupied the old value is written to the type wrapping swap_intruder and may be unwrapped to view. If more space is needed but allocation fails or has been forbidden, an insert error is set.</dd></dl>
<p>Note that this function may write to the struct containing temp_intruder and wraps it in an entry to provide information about the old value. </p>

</div>
</div>
<a id="ad72bb878c62d32ffe98f895a86c36c5c" name="ad72bb878c62d32ffe98f895a86c36c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72bb878c62d32ffe98f895a86c36c5c">&#9670;&#160;</a></span>CCC_adaptive_map_try_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_adaptive_map_try_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__node.html">CCC_Adaptive_map_node</a> *&#160;</td>
          <td class="paramname"><em>type_intruder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert the key value wrapping type_intruder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder</td><td>the handle to the user type wrapping map node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry. If Occupied, the entry contains a reference to the key value user type in the map and may be unwrapped. If Vacant the entry contains a reference to the newly inserted entry in the map. If more space is needed but allocation fails, an insert error is set. </dd></dl>

</div>
</div>
<a id="ae2c78546439edc27f4ad51e9a561adff" name="ae2c78546439edc27f4ad51e9a561adff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c78546439edc27f4ad51e9a561adff">&#9670;&#160;</a></span>CCC_adaptive_map_unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_adaptive_map_unwrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map__entry.html">CCC_Adaptive_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwraps the provided entry to obtain a view into the map element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry from a query to the map via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view into the table entry if one is present, or NULL. </dd></dl>

</div>
</div>
<a id="a1af103d79e696342b118f0beab1d3fb6" name="a1af103d79e696342b118f0beab1d3fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af103d79e696342b118f0beab1d3fb6">&#9670;&#160;</a></span>CCC_adaptive_map_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_adaptive_map_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Adaptive__map.html">CCC_Adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validation of invariants for the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all invariants hold, false if corruption occurs. Error if map is NULL. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="adaptive__map_8h.html">adaptive_map.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
