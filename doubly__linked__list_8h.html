<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/doubly_linked_list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('doubly__linked__list_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">doubly_linked_list.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Doubly Linked List Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;impl_doubly_linked_list.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for doubly_linked_list.h:</div>
<div class="dyncontent">
<div class="center"><img src="doubly__linked__list_8h__incl.png" border="0" usemap="#accc_2doubly__linked__list_8h" alt=""/></div>
<map name="accc_2doubly__linked__list_8h" id="accc_2doubly__linked__list_8h">
<area shape="rect" title="The Doubly Linked List Interface." alt="" coords="47,5,223,31"/>
<area shape="rect" href="impl__doubly__linked__list_8h_source.html" title=" " alt="" coords="5,79,153,119"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="100,167,171,192"/>
<area shape="rect" href="impl__types_8h_source.html" title=" " alt="" coords="82,240,189,265"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="doubly__linked__list_8h__dep__incl.png" border="0" usemap="#accc_2doubly__linked__list_8hdep" alt=""/></div>
<map name="accc_2doubly__linked__list_8hdep" id="accc_2doubly__linked__list_8hdep">
<area shape="rect" title="The Doubly Linked List Interface." alt="" coords="5,5,181,31"/>
<area shape="rect" href="impl__traits_8h_source.html" title=" " alt="" coords="30,79,157,104"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="47,152,140,177"/>
</map>
</div>
</div>
<p><a href="doubly__linked__list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a50ff4422f52bc1a5c2c926dc88a01e3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a50ff4422f52bc1a5c2c926dc88a01e3e">ccc_dll_init</a>(list_name,  struct_name,  list_elem_field,  alloc_fn,  cmp_fn,  aux_data)</td></tr>
<tr class="memdesc:a50ff4422f52bc1a5c2c926dc88a01e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a doubly linked list with its l-value name, type containing the dll elems, the field of the dll elem, allocation function, compare function and any auxilliary data needed for comparison, printing, or destructors.  <br /></td></tr>
<tr class="separator:a50ff4422f52bc1a5c2c926dc88a01e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaceb2c981b30f064750203fcb938e774"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_dll_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a></td></tr>
<tr class="memdesc:aaceb2c981b30f064750203fcb938e774"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container offering bidirectional, insert, removal, and iteration.  <br /></td></tr>
<tr class="separator:aaceb2c981b30f064750203fcb938e774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ab05fc0a5ac5f5d8ff31103209edf0"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_dll_elem_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a></td></tr>
<tr class="memdesc:ae6ab05fc0a5ac5f5d8ff31103209edf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A doubly linked list intrusive element to embedded in a user type.  <br /></td></tr>
<tr class="separator:ae6ab05fc0a5ac5f5d8ff31103209edf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Insert and Remove Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Add or remove elements from the doubly linked list. </p>
</td></tr>
<tr class="memitem:a67936dadaece25c50d68e3dae247f686"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a67936dadaece25c50d68e3dae247f686">ccc_dll_emplace_back</a>(list_ptr,  type_initializer...)&#160;&#160;&#160;    ccc_impl_dll_emplace_back(list_ptr, type_initializer)</td></tr>
<tr class="memdesc:a67936dadaece25c50d68e3dae247f686"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes contents of type initializer directly to allocated memory at the back of the list. O(1).  <br /></td></tr>
<tr class="separator:a67936dadaece25c50d68e3dae247f686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c4d94d92918c9742aa1626ca724aa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a18c4d94d92918c9742aa1626ca724aa4">ccc_dll_emplace_front</a>(list_ptr,  type_initializer...)&#160;&#160;&#160;    ccc_impl_dll_emplace_front(list_ptr, type_initializer)</td></tr>
<tr class="memdesc:a18c4d94d92918c9742aa1626ca724aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes contents of type initializer directly to allocated memory at the front of the list. O(1).  <br /></td></tr>
<tr class="separator:a18c4d94d92918c9742aa1626ca724aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21312b92a33769a08c7e9cd334800a7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#ac21312b92a33769a08c7e9cd334800a7">ccc_dll_push_front</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem)</td></tr>
<tr class="memdesc:ac21312b92a33769a08c7e9cd334800a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push user type wrapping elem to the front of the list. O(1).  <br /></td></tr>
<tr class="separator:ac21312b92a33769a08c7e9cd334800a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327884c1903e8729e7a6ca0377f4c185"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a327884c1903e8729e7a6ca0377f4c185">ccc_dll_push_back</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem)</td></tr>
<tr class="memdesc:a327884c1903e8729e7a6ca0377f4c185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push user type wrapping elem to the back of the list. O(1).  <br /></td></tr>
<tr class="separator:a327884c1903e8729e7a6ca0377f4c185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee123c04ee8e032cb1b7888bdfcbb049"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#aee123c04ee8e032cb1b7888bdfcbb049">ccc_dll_insert</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *pos_elem, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem)</td></tr>
<tr class="memdesc:aee123c04ee8e032cb1b7888bdfcbb049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert user type wrapping elem before pos_elem. O(1).  <br /></td></tr>
<tr class="separator:aee123c04ee8e032cb1b7888bdfcbb049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eabf4c75464bc9e78f470fa7e942a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a89eabf4c75464bc9e78f470fa7e942a3">ccc_dll_pop_front</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l)</td></tr>
<tr class="memdesc:a89eabf4c75464bc9e78f470fa7e942a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the user type at the front of the list. O(1).  <br /></td></tr>
<tr class="separator:a89eabf4c75464bc9e78f470fa7e942a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387ada0e3dcfb0df8d4fc3a8845cb536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a387ada0e3dcfb0df8d4fc3a8845cb536">ccc_dll_pop_back</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l)</td></tr>
<tr class="memdesc:a387ada0e3dcfb0df8d4fc3a8845cb536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the user type at the back of the list. O(1).  <br /></td></tr>
<tr class="separator:a387ada0e3dcfb0df8d4fc3a8845cb536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a34b6601d56dc2e59508341d77a66d9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a4a34b6601d56dc2e59508341d77a66d9">ccc_dll_extract</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem)</td></tr>
<tr class="memdesc:a4a34b6601d56dc2e59508341d77a66d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element following an extracted element from the list without deallocating regardless of allocation permission provided to the container. O(1).  <br /></td></tr>
<tr class="separator:a4a34b6601d56dc2e59508341d77a66d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b8eb3d76d4db7d57e14ca7a6a28d4d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a23b8eb3d76d4db7d57e14ca7a6a28d4d">ccc_dll_erase</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem)</td></tr>
<tr class="memdesc:a23b8eb3d76d4db7d57e14ca7a6a28d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element following an erased element from the list. O(1).  <br /></td></tr>
<tr class="separator:a23b8eb3d76d4db7d57e14ca7a6a28d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7be6724b298934f812c010ed682396f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#ad7be6724b298934f812c010ed682396f">ccc_dll_erase_range</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem_begin, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem_end)</td></tr>
<tr class="memdesc:ad7be6724b298934f812c010ed682396f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element following an extracted range of elements from the list. O(N).  <br /></td></tr>
<tr class="separator:ad7be6724b298934f812c010ed682396f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2764a280b24c06ad3d0c10c20f095576"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a2764a280b24c06ad3d0c10c20f095576">ccc_dll_extract_range</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem_begin, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *elem_end)</td></tr>
<tr class="memdesc:a2764a280b24c06ad3d0c10c20f095576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element following an extracted range of elements from the list without deallocating regardless of allocation permission provided to the container. O(N).  <br /></td></tr>
<tr class="separator:a2764a280b24c06ad3d0c10c20f095576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286ba34e3d6237153d0bb9ab293706f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a286ba34e3d6237153d0bb9ab293706f3">ccc_dll_splice</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *pos_sll, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *pos, <a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *to_cut_sll, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *to_cut)</td></tr>
<tr class="memdesc:a286ba34e3d6237153d0bb9ab293706f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repositions to_cut before pos. Only list pointers are modified. O(1).  <br /></td></tr>
<tr class="separator:a286ba34e3d6237153d0bb9ab293706f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1e8eb64e99bab7cf3892a8683f30b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a3f1e8eb64e99bab7cf3892a8683f30b0">ccc_dll_splice_range</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *pos_sll, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *pos, <a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *to_cut_sll, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *begin, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *end)</td></tr>
<tr class="memdesc:a3f1e8eb64e99bab7cf3892a8683f30b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repositions begin to end before pos. Only list pointers are modified O(N).  <br /></td></tr>
<tr class="separator:a3f1e8eb64e99bab7cf3892a8683f30b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Deallocate the container. </p>
</td></tr>
<tr class="memitem:ae92a3623c7bdfdd9ace703e2e18879d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#ae92a3623c7bdfdd9ace703e2e18879d5">ccc_dll_clear</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *l, <a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *fn)</td></tr>
<tr class="memdesc:ae92a3623c7bdfdd9ace703e2e18879d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the contents of the list freeing elements, if given allocation permission. O(N).  <br /></td></tr>
<tr class="separator:ae92a3623c7bdfdd9ace703e2e18879d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iteration Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Iterate through the doubly linked list. </p>
</td></tr>
<tr class="memitem:a6659ba404965e290896edf2db6f85520"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a6659ba404965e290896edf2db6f85520">ccc_dll_begin</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:a6659ba404965e290896edf2db6f85520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the user type at the start of the list or NULL if empty. O(1).  <br /></td></tr>
<tr class="separator:a6659ba404965e290896edf2db6f85520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41ce312d610eff4154f1e08b96862d2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#ab41ce312d610eff4154f1e08b96862d2">ccc_dll_rbegin</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:ab41ce312d610eff4154f1e08b96862d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the user type at the end of the list or NULL if empty. O(1).  <br /></td></tr>
<tr class="separator:ab41ce312d610eff4154f1e08b96862d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a97c4b1eb78dbb1056f83726a32fec5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a9a97c4b1eb78dbb1056f83726a32fec5">ccc_dll_next</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> const *elem)</td></tr>
<tr class="memdesc:a9a97c4b1eb78dbb1056f83726a32fec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the user type following the element known to be in the list. O(1).  <br /></td></tr>
<tr class="separator:a9a97c4b1eb78dbb1056f83726a32fec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2226a51c3cf014707df4eb3bd057e8cb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a2226a51c3cf014707df4eb3bd057e8cb">ccc_dll_rnext</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l, <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> const *elem)</td></tr>
<tr class="memdesc:a2226a51c3cf014707df4eb3bd057e8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the user type following the element known to be in the list moving from back to front. O(1).  <br /></td></tr>
<tr class="separator:a2226a51c3cf014707df4eb3bd057e8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49ed9a729d52de6624f37e1931b7f8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#aeb49ed9a729d52de6624f37e1931b7f8">ccc_dll_end</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:aeb49ed9a729d52de6624f37e1931b7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end sentinel with no accessible fields. O(1).  <br /></td></tr>
<tr class="separator:aeb49ed9a729d52de6624f37e1931b7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad294dc09ecea5d46a8b69a88d184f924"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#ad294dc09ecea5d46a8b69a88d184f924">ccc_dll_rend</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:ad294dc09ecea5d46a8b69a88d184f924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start sentinel with no accessible fields. O(1).  <br /></td></tr>
<tr class="separator:ad294dc09ecea5d46a8b69a88d184f924"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain state from the doubly linked list. </p>
</td></tr>
<tr class="memitem:a4f7f1c337174a8c19091ab34d25587ff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a4f7f1c337174a8c19091ab34d25587ff">ccc_dll_front</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:a4f7f1c337174a8c19091ab34d25587ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user type at the front of the list. O(1).  <br /></td></tr>
<tr class="separator:a4f7f1c337174a8c19091ab34d25587ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea7c774a00b9e84da26660d20a0b1ac"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#abea7c774a00b9e84da26660d20a0b1ac">ccc_dll_back</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:abea7c774a00b9e84da26660d20a0b1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user type at the back of the list. O(1).  <br /></td></tr>
<tr class="separator:abea7c774a00b9e84da26660d20a0b1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd9b16a6fe36296e4d95e2791b31a9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a1cd9b16a6fe36296e4d95e2791b31a9e">ccc_dll_begin_elem</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:a1cd9b16a6fe36296e4d95e2791b31a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the list element at the front of the list which may be the sentinel. O(1).  <br /></td></tr>
<tr class="separator:a1cd9b16a6fe36296e4d95e2791b31a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4285ea65140865e2509f0ac1674be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a4af4285ea65140865e2509f0ac1674be">ccc_dll_end_elem</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:a4af4285ea65140865e2509f0ac1674be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the list element at the back of the list which may be the sentinel. O(1).  <br /></td></tr>
<tr class="separator:a4af4285ea65140865e2509f0ac1674be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcc2bddcba3de980eff5c3142ba3687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a5bcc2bddcba3de980eff5c3142ba3687">ccc_dll_end_sentinel</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:a5bcc2bddcba3de980eff5c3142ba3687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the sentinel at the back of the list. O(1).  <br /></td></tr>
<tr class="separator:a5bcc2bddcba3de980eff5c3142ba3687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0c0cfacb09e26c29cb9652a5dc2eb5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#afe0c0cfacb09e26c29cb9652a5dc2eb5">ccc_dll_size</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:afe0c0cfacb09e26c29cb9652a5dc2eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the list. O(1).  <br /></td></tr>
<tr class="separator:afe0c0cfacb09e26c29cb9652a5dc2eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413ff34f19dbeebcacad61d3a8ef389e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a413ff34f19dbeebcacad61d3a8ef389e">ccc_dll_is_empty</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:a413ff34f19dbeebcacad61d3a8ef389e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the size of the list is equal to 0. O(1).  <br /></td></tr>
<tr class="separator:a413ff34f19dbeebcacad61d3a8ef389e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0946ef0b3b52c324fbb3438f77d3dd50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly__linked__list_8h.html#a0946ef0b3b52c324fbb3438f77d3dd50">ccc_dll_validate</a> (<a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *l)</td></tr>
<tr class="memdesc:a0946ef0b3b52c324fbb3438f77d3dd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates internal state of the list.  <br /></td></tr>
<tr class="separator:a0946ef0b3b52c324fbb3438f77d3dd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Doubly Linked List Interface. </p>
<p>A doubly linked list offers efficient push, pop, extract, and erase operations for elements stored in the list. Notably, for single elements the list can offer O(1) push front/back, pop front/back, and removal of elements in arbitrary positions in the list. The cost of this efficiency is higher memory footprint.</p>
<p>This container offers pointer stability. Also, if the container is not permitted to allocate all insertion code assumes that the user has allocated memory appropriately for the element to be inserted; it will not allocate or free in this case. If allocation is permitted upon initialization the container will manage the memory as expected on insert or erase operations as defined by the interface; memory is allocated for insertions and freed for removals.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define DOUBLY_LINKED_LIST_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>ccc_</code> prefix. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a67936dadaece25c50d68e3dae247f686" name="a67936dadaece25c50d68e3dae247f686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67936dadaece25c50d68e3dae247f686">&#9670;&#160;</a></span>ccc_dll_emplace_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_dll_emplace_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_initializer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_dll_emplace_back(list_ptr, type_initializer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes contents of type initializer directly to allocated memory at the back of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list_ptr</td><td>the address of the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_initializer</td><td>the r-value initializer of the type to be inserted in the list. This should match the type containing dll elements as a struct member for this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the inserted element or NULL if allocation is not allowed or fails.</dd></dl>
<p>Note that it does not make sense to use this method if the list has been initialized without an allocation function. If the user does not allow allocation, the contents of new elements to be inserted has been determined by the user prior to any inserts into the list. </p>

</div>
</div>
<a id="a18c4d94d92918c9742aa1626ca724aa4" name="a18c4d94d92918c9742aa1626ca724aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c4d94d92918c9742aa1626ca724aa4">&#9670;&#160;</a></span>ccc_dll_emplace_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_dll_emplace_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_initializer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_dll_emplace_front(list_ptr, type_initializer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes contents of type initializer directly to allocated memory at the front of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list_ptr</td><td>the address of the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_initializer</td><td>the r-value initializer of the type to be inserted in the list. This should match the type containing dll elements as a struct member for this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the inserted element or NULL if allocation is not allowed or fails.</dd></dl>
<p>Note that it does not make sense to use this method if the list has been initialized without an allocation function. If the user does not allow allocation, the contents of new elements to be inserted has been determined by the user prior to any inserts into the list. </p>

</div>
</div>
<a id="a50ff4422f52bc1a5c2c926dc88a01e3e" name="a50ff4422f52bc1a5c2c926dc88a01e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ff4422f52bc1a5c2c926dc88a01e3e">&#9670;&#160;</a></span>ccc_dll_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_dll_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">struct_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list_elem_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alloc_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmp_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">aux_data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ccc_impl_dll_init(list_name, struct_name, list_elem_field, alloc_fn,       \</div>
<div class="line">                      cmp_fn, aux_data)</div>
</div><!-- fragment -->
<p>Initialize a doubly linked list with its l-value name, type containing the dll elems, the field of the dll elem, allocation function, compare function and any auxilliary data needed for comparison, printing, or destructors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list_name</td><td>the name of the list being initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">struct_name</td><td>the type containing the intrusive dll element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list_elem_field</td><td>name of the dll element in the containing type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_fn</td><td>the optional allocation function or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_fn</td><td>the ccc_cmp_fn used to compare list elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux_data</td><td>any auxilliary data that will be needed for comparison, printing, or destruction of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized list. Assign to the list directly on the right hand side of an equality operator. Initialization can occur at runtime or compile time (e.g. ccc_doubly_linked l = <a class="el" href="doubly__linked__list_8h.html#a50ff4422f52bc1a5c2c926dc88a01e3e" title="Initialize a doubly linked list with its l-value name, type containing the dll elems,...">ccc_dll_init(...)</a>;). </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae6ab05fc0a5ac5f5d8ff31103209edf0" name="ae6ab05fc0a5ac5f5d8ff31103209edf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ab05fc0a5ac5f5d8ff31103209edf0">&#9670;&#160;</a></span>ccc_dll_elem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_dll_elem_ <a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A doubly linked list intrusive element to embedded in a user type. </p>
<p>It can be used in an allocating or non allocating container. If allocation is prohibited the container assumes the element is wrapped in pre-allocated memory with the appropriate lifetime and scope for the user's needs; the container does not allocate or free in this case. If allocation is allowed the container will handle copying the data wrapping the element to allocations and deallocating when necessary. </p>

</div>
</div>
<a id="aaceb2c981b30f064750203fcb938e774" name="aaceb2c981b30f064750203fcb938e774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceb2c981b30f064750203fcb938e774">&#9670;&#160;</a></span>ccc_doubly_linked_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_dll_ <a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container offering bidirectional, insert, removal, and iteration. </p>
<dl class="section warning"><dt>Warning</dt><dd>it is undefined behavior to use an uninitialized container.</dd></dl>
<p>A doubly linked list may be stored in the stack, heap, or data segment. Once Initialized it is passed by reference to all functions. A doubly linked list can be initialized at compile time or runtime. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abea7c774a00b9e84da26660d20a0b1ac" name="abea7c774a00b9e84da26660d20a0b1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea7c774a00b9e84da26660d20a0b1ac">&#9670;&#160;</a></span>ccc_dll_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the user type at the back of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type at the back of the list. NULL if empty. </dd></dl>

</div>
</div>
<a id="a6659ba404965e290896edf2db6f85520" name="a6659ba404965e290896edf2db6f85520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6659ba404965e290896edf2db6f85520">&#9670;&#160;</a></span>ccc_dll_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the user type at the start of the list or NULL if empty. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type or NULL if empty or bad input. </dd></dl>

</div>
</div>
<a id="a1cd9b16a6fe36296e4d95e2791b31a9e" name="a1cd9b16a6fe36296e4d95e2791b31a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd9b16a6fe36296e4d95e2791b31a9e">&#9670;&#160;</a></span>ccc_dll_begin_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> * ccc_dll_begin_elem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a handle to the list element at the front of the list which may be the sentinel. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the list element at the beginning of the list which may be the sentinel but will not be NULL unless a NULL pointer is provided as l. </dd></dl>

</div>
</div>
<a id="ae92a3623c7bdfdd9ace703e2e18879d5" name="ae92a3623c7bdfdd9ace703e2e18879d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92a3623c7bdfdd9ace703e2e18879d5">&#9670;&#160;</a></span>ccc_dll_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_dll_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the contents of the list freeing elements, if given allocation permission. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>a destructor function to run on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the clearing was a success or an input error if l or fn is NULL.</dd></dl>
<p>Note that if the list is initialized with allocation permission it will free elements for the user and the destructor function should only perform auxiliary cleanup, otherwise a double free will occur.</p>
<p>If the list has not been given allocation permission the user should free the list elements with the destructor if they wish to do so. The implementation ensures the function is called after the element is removed. Otherwise, the user must manage their elements at their discretion after the list is emptied in this function. </p>

</div>
</div>
<a id="aeb49ed9a729d52de6624f37e1931b7f8" name="aeb49ed9a729d52de6624f37e1931b7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49ed9a729d52de6624f37e1931b7f8">&#9670;&#160;</a></span>ccc_dll_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the end sentinel with no accessible fields. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the end sentinel with no accessible fields. </dd></dl>

</div>
</div>
<a id="a4af4285ea65140865e2509f0ac1674be" name="a4af4285ea65140865e2509f0ac1674be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af4285ea65140865e2509f0ac1674be">&#9670;&#160;</a></span>ccc_dll_end_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> * ccc_dll_end_elem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a handle to the list element at the back of the list which may be the sentinel. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the list element at the end of the list which may be the sentinel but will not be NULL unless a NULL pointer is provided as l. </dd></dl>

</div>
</div>
<a id="a5bcc2bddcba3de980eff5c3142ba3687" name="a5bcc2bddcba3de980eff5c3142ba3687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcc2bddcba3de980eff5c3142ba3687">&#9670;&#160;</a></span>ccc_dll_end_sentinel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> * ccc_dll_end_sentinel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a handle to the sentinel at the back of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sentinel at the end of the list which will not be NULL unless a NULL pointer is provided as l. </dd></dl>

</div>
</div>
<a id="a23b8eb3d76d4db7d57e14ca7a6a28d4d" name="a23b8eb3d76d4db7d57e14ca7a6a28d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b8eb3d76d4db7d57e14ca7a6a28d4d">&#9670;&#160;</a></span>ccc_dll_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element following an erased element from the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>the handle of an element known to be in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element in the list following elem or NULL if the element is the last. NULL is returned if bad input is provided or the elem is not in the list. </dd></dl>

</div>
</div>
<a id="ad7be6724b298934f812c010ed682396f" name="ad7be6724b298934f812c010ed682396f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7be6724b298934f812c010ed682396f">&#9670;&#160;</a></span>ccc_dll_erase_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_erase_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element following an extracted range of elements from the list. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_begin</td><td>the handle of an element known to be in the list at the start of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_end</td><td>the handle of an element known to be in the list at the end of the range following elem_begin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element in the list following elem_end or NULL if the element is the last. NULL is returned if bad input is provided or the elem is not in the list.</dd></dl>
<p>Note that if the user does not permit the container to allocate they may iterate through the extracted range in the same way one iterates through a normal list using the iterator function. If allocation is allowed, all elements from elem_begin to elem_end will be erased and references invalidated. </p>

</div>
</div>
<a id="a4a34b6601d56dc2e59508341d77a66d9" name="a4a34b6601d56dc2e59508341d77a66d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a34b6601d56dc2e59508341d77a66d9">&#9670;&#160;</a></span>ccc_dll_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element following an extracted element from the list without deallocating regardless of allocation permission provided to the container. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>the handle of an element known to be in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element in the list following elem or NULL if the element is the last. NULL is returned if bad input is provided or the elem is not in the list. </dd></dl>

</div>
</div>
<a id="a2764a280b24c06ad3d0c10c20f095576" name="a2764a280b24c06ad3d0c10c20f095576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2764a280b24c06ad3d0c10c20f095576">&#9670;&#160;</a></span>ccc_dll_extract_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_extract_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element following an extracted range of elements from the list without deallocating regardless of allocation permission provided to the container. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_begin</td><td>the handle of an element known to be in the list at the start of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_end</td><td>the handle of an element known to be in the list at the end of the range following elem_begin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element in the list following elem_end or NULL if the element is the last. NULL is returned if bad input is provided or the elem is not in the list.</dd></dl>
<p>Note that the user may iterate through the extracted range in the same way one iterates through a normal list using the iterator function. </p>

</div>
</div>
<a id="a4f7f1c337174a8c19091ab34d25587ff" name="a4f7f1c337174a8c19091ab34d25587ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7f1c337174a8c19091ab34d25587ff">&#9670;&#160;</a></span>ccc_dll_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the user type at the front of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type at the front of the list. NULL if empty. </dd></dl>

</div>
</div>
<a id="aee123c04ee8e032cb1b7888bdfcbb049" name="aee123c04ee8e032cb1b7888bdfcbb049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee123c04ee8e032cb1b7888bdfcbb049">&#9670;&#160;</a></span>ccc_dll_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>pos_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert user type wrapping elem before pos_elem. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_elem</td><td>a pointer to the list element before which elem inserts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the list element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element inserted or NULL if bad input is provided or allocation fails. </dd></dl>

</div>
</div>
<a id="a413ff34f19dbeebcacad61d3a8ef389e" name="a413ff34f19dbeebcacad61d3a8ef389e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413ff34f19dbeebcacad61d3a8ef389e">&#9670;&#160;</a></span>ccc_dll_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_dll_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if the size of the list is equal to 0. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size is 0 or l is NULL, else false. </dd></dl>

</div>
</div>
<a id="a9a97c4b1eb78dbb1056f83726a32fec5" name="a9a97c4b1eb78dbb1056f83726a32fec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a97c4b1eb78dbb1056f83726a32fec5">&#9670;&#160;</a></span>ccc_dll_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> const *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the user type following the element known to be in the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a handle to the list element known to be in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element following elem or NULL if no elements follow or bad input is provided. </dd></dl>

</div>
</div>
<a id="a387ada0e3dcfb0df8d4fc3a8845cb536" name="a387ada0e3dcfb0df8d4fc3a8845cb536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387ada0e3dcfb0df8d4fc3a8845cb536">&#9670;&#160;</a></span>ccc_dll_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_dll_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the user type at the back of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an ok result if the pop was successful or an error if bad input is provided or the list is empty. </dd></dl>

</div>
</div>
<a id="a89eabf4c75464bc9e78f470fa7e942a3" name="a89eabf4c75464bc9e78f470fa7e942a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89eabf4c75464bc9e78f470fa7e942a3">&#9670;&#160;</a></span>ccc_dll_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_dll_pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the user type at the front of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an ok result if the pop was successful or an error if bad input is provided or the list is empty. </dd></dl>

</div>
</div>
<a id="a327884c1903e8729e7a6ca0377f4c185" name="a327884c1903e8729e7a6ca0377f4c185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327884c1903e8729e7a6ca0377f4c185">&#9670;&#160;</a></span>ccc_dll_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push user type wrapping elem to the back of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the list element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element inserted or NULL if bad input is provided or allocation fails. </dd></dl>

</div>
</div>
<a id="ac21312b92a33769a08c7e9cd334800a7" name="ac21312b92a33769a08c7e9cd334800a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21312b92a33769a08c7e9cd334800a7">&#9670;&#160;</a></span>ccc_dll_push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push user type wrapping elem to the front of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the list element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element inserted or NULL if bad input is provided or allocation fails. </dd></dl>

</div>
</div>
<a id="ab41ce312d610eff4154f1e08b96862d2" name="ab41ce312d610eff4154f1e08b96862d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41ce312d610eff4154f1e08b96862d2">&#9670;&#160;</a></span>ccc_dll_rbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the user type at the end of the list or NULL if empty. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type or NULL if empty or bad input. </dd></dl>

</div>
</div>
<a id="ad294dc09ecea5d46a8b69a88d184f924" name="ad294dc09ecea5d46a8b69a88d184f924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad294dc09ecea5d46a8b69a88d184f924">&#9670;&#160;</a></span>ccc_dll_rend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the start sentinel with no accessible fields. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start sentinel with no accessible fields. </dd></dl>

</div>
</div>
<a id="a2226a51c3cf014707df4eb3bd057e8cb" name="a2226a51c3cf014707df4eb3bd057e8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2226a51c3cf014707df4eb3bd057e8cb">&#9670;&#160;</a></span>ccc_dll_rnext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_dll_rnext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> const *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the user type following the element known to be in the list moving from back to front. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a handle to the list element known to be in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element following elem from back to front or NULL if no elements follow or bad input is provided. </dd></dl>

</div>
</div>
<a id="afe0c0cfacb09e26c29cb9652a5dc2eb5" name="afe0c0cfacb09e26c29cb9652a5dc2eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0c0cfacb09e26c29cb9652a5dc2eb5">&#9670;&#160;</a></span>ccc_dll_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_dll_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the list or 0 if empty or l is NULL. </dd></dl>

</div>
</div>
<a id="a286ba34e3d6237153d0bb9ab293706f3" name="a286ba34e3d6237153d0bb9ab293706f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286ba34e3d6237153d0bb9ab293706f3">&#9670;&#160;</a></span>ccc_dll_splice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_dll_splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>pos_sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>to_cut_sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>to_cut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repositions to_cut before pos. Only list pointers are modified. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_sll</td><td>the list to which pos belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>the position before which to_cut will be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_cut_sll</td><td>the list to which to_cut belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_cut</td><td>the element to cut. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the splice is successful or an error if bad input is provided. </dd></dl>

</div>
</div>
<a id="a3f1e8eb64e99bab7cf3892a8683f30b0" name="a3f1e8eb64e99bab7cf3892a8683f30b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1e8eb64e99bab7cf3892a8683f30b0">&#9670;&#160;</a></span>ccc_dll_splice_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_dll_splice_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>pos_sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>to_cut_sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repositions begin to end before pos. Only list pointers are modified O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_sll</td><td>the list to which pos belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>the position before which to_cut will be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_cut_sll</td><td>the list to which the range belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>the start of the list to splice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the end of the list to splice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the splice is successful or an error if bad input is provided. </dd></dl>

</div>
</div>
<a id="a0946ef0b3b52c324fbb3438f77d3dd50" name="a0946ef0b3b52c324fbb3438f77d3dd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0946ef0b3b52c324fbb3438f77d3dd50">&#9670;&#160;</a></span>ccc_dll_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_dll_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates internal state of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if invariants hold, false if not. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="doubly__linked__list_8h.html">doubly_linked_list.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
