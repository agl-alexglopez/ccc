<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/flat_priority_queue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('flat__priority__queue_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">flat_priority_queue.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Flat Priority Queue Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="buffer_8h_source.html">buffer.h</a>&quot;</code><br />
<code>#include &quot;impl/impl_flat_priority_queue.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for flat_priority_queue.h:</div>
<div class="dyncontent">
<div class="center"><img src="flat__priority__queue_8h__incl.png" border="0" usemap="#accc_2flat__priority__queue_8h" alt=""/></div>
<map name="accc_2flat__priority__queue_8h" id="accc_2flat__priority__queue_8h">
<area shape="rect" title="The Flat Priority Queue Interface." alt="" coords="5,5,187,31"/>
<area shape="rect" href="buffer_8h.html" title="The Buffer Interface." alt="" coords="133,167,203,192"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="137,313,220,339"/>
<area shape="rect" href="impl__flat__priority__queue_8h_source.html" title=" " alt="" coords="134,79,301,119"/>
<area shape="rect" href="impl__buffer_8h_source.html" title=" " alt="" coords="55,240,195,265"/>
<area shape="rect" href="impl__types_8h_source.html" title=" " alt="" coords="109,387,248,412"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="flat__priority__queue_8h__dep__incl.png" border="0" usemap="#accc_2flat__priority__queue_8hdep" alt=""/></div>
<map name="accc_2flat__priority__queue_8hdep" id="accc_2flat__priority__queue_8hdep">
<area shape="rect" title="The Flat Priority Queue Interface." alt="" coords="5,5,187,31"/>
<area shape="rect" href="impl__traits_8h_source.html" title=" " alt="" coords="15,79,177,104"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="49,152,143,177"/>
</map>
</div>
</div>
<p><a href="flat__priority__queue_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Flat Priority Queue Interface. </p>
<p>A flat priority queue is a contiguous container storing elements in heap order. This offers tightly packed data for efficient push, pop, min/max operations in O(lg N) time.</p>
<p>A flat priority queue can use memory sources from the stack, heap, or data segment and can be initialized at compile or runtime. The container offers efficient initialization options such as an <code>O(N)</code> heap building initializer. The flat priority queue also offers a destructive heap sort option if the user desires an in-place strict <code>O(N * log(N))</code> and <code>O(1)</code> space sort that does not use recursion.</p>
<p>Many functions in the interface request a temporary argument be passed as a swap slot. This is because a flat priority queue is backed by a binary heap and swaps elements to maintain its properties. Because the user may decide the flat priority queue has no allocation permission, the user must provide this swap slot. An easy way to do this in C99 and later is with anonymous compound literal references. For example, if we have a <code>int</code> flat priority queue we can provide a temporary slot inline to a function as follows.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="flat__priority__queue_8h.html#a68b14ac07255f984b838843fd0a3e761">ccc_fpq_pop</a>(&amp;pq, &amp;(<span class="keywordtype">int</span>){0});</div>
<div class="ttc" id="aflat__priority__queue_8h_html_a68b14ac07255f984b838843fd0a3e761"><div class="ttname"><a href="flat__priority__queue_8h.html#a68b14ac07255f984b838843fd0a3e761">ccc_fpq_pop</a></div><div class="ttdeci">ccc_result ccc_fpq_pop(ccc_flat_priority_queue *fpq, void *tmp)</div><div class="ttdoc">Pop the front element (min or max) element in the fpq. O(lgN).</div></div>
</div><!-- fragment --><p>Any user defined struct can also use this technique.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="flat__priority__queue_8h.html#a68b14ac07255f984b838843fd0a3e761">ccc_fpq_pop</a>(&amp;pq, &amp;(<span class="keyword">struct</span> my_type){});</div>
</div><!-- fragment --><p>This is the preferred method because the storage remains anonymous and inaccessible to other code in the calling scope.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>ccc_</code> prefix. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Initialize the container with memory, callbacks, and permissions. </p>
</td></tr>
<tr class="memitem:abb90b4408d828e1f2820858c6523f289"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#abb90b4408d828e1f2820858c6523f289">ccc_fpq_init</a>(mem_ptr,  any_type_name,  cmp_order,  cmp_fn,  alloc_fn,  aux_data,  capacity)</td></tr>
<tr class="memdesc:abb90b4408d828e1f2820858c6523f289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a fpq as a min or max heap.  <br /></td></tr>
<tr class="separator:abb90b4408d828e1f2820858c6523f289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3542f48eda623e55b72e8ef4cc7ae3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a7a3542f48eda623e55b72e8ef4cc7ae3">ccc_fpq_heapify_init</a>(mem_ptr,  any_type_name,  cmp_order,  cmp_fn,  alloc_fn,  aux_data,  capacity,  size)</td></tr>
<tr class="memdesc:a7a3542f48eda623e55b72e8ef4cc7ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial order an array of elements as a min or max heap. O(N).  <br /></td></tr>
<tr class="separator:a7a3542f48eda623e55b72e8ef4cc7ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65d783f01bd17614486b178bb2c7015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#ad65d783f01bd17614486b178bb2c7015">ccc_fpq_copy</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *dst, <a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *src, <a class="el" href="types_8h.html#a3e73202894869d2840fb21ff912bbd96">ccc_any_alloc_fn</a> *fn)</td></tr>
<tr class="memdesc:ad65d783f01bd17614486b178bb2c7015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the fpq from src to newly initialized dst.  <br /></td></tr>
<tr class="separator:ad65d783f01bd17614486b178bb2c7015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad4f0ed5e05f3582d37c8306b57358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#ab1ad4f0ed5e05f3582d37c8306b57358">ccc_fpq_reserve</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, size_t to_add, <a class="el" href="types_8h.html#a3e73202894869d2840fb21ff912bbd96">ccc_any_alloc_fn</a> *fn)</td></tr>
<tr class="memdesc:ab1ad4f0ed5e05f3582d37c8306b57358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for at least to_add more elements.  <br /></td></tr>
<tr class="separator:ab1ad4f0ed5e05f3582d37c8306b57358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Insert and Remove Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Insert or remove elements from the flat priority queue. </p>
</td></tr>
<tr class="memitem:a1c8103699b633d1da090dd867b46d1ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a1c8103699b633d1da090dd867b46d1ec">ccc_fpq_emplace</a>(fpq,  val_initializer...)&#160;&#160;&#160;    ccc_impl_fpq_emplace(fpq, val_initializer)</td></tr>
<tr class="memdesc:a1c8103699b633d1da090dd867b46d1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a type directly to a priority queue slot. O(lgN).  <br /></td></tr>
<tr class="separator:a1c8103699b633d1da090dd867b46d1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6637e9dc9b06d7026319cc8498ec4d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#ae6637e9dc9b06d7026319cc8498ec4d9">ccc_fpq_update_w</a>(fpq_ptr,  any_type_ptr,  update_closure_over_T...)&#160;&#160;&#160;    ccc_impl_fpq_update_w(fpq_ptr, any_type_ptr, update_closure_over_T)</td></tr>
<tr class="memdesc:ae6637e9dc9b06d7026319cc8498ec4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the user type stored in the priority queue directly. O(lgN).  <br /></td></tr>
<tr class="separator:ae6637e9dc9b06d7026319cc8498ec4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f154ea0ca88725a32a07bd57886e54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a22f154ea0ca88725a32a07bd57886e54">ccc_fpq_increase_w</a>(fpq_ptr,  any_type_ptr,  increase_closure_over_T...)&#160;&#160;&#160;    ccc_impl_fpq_increase_w(fpq_ptr, any_type_ptr, increase_closure_over_T)</td></tr>
<tr class="memdesc:a22f154ea0ca88725a32a07bd57886e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the user type stored in the priority queue directly. O(lgN).  <br /></td></tr>
<tr class="separator:a22f154ea0ca88725a32a07bd57886e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab50c378df48872ce942ac89e4a11c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#abab50c378df48872ce942ac89e4a11c9">ccc_fpq_decrease_w</a>(fpq_ptr,  any_type_ptr,  decrease_closure_over_T...)&#160;&#160;&#160;    ccc_impl_fpq_decrease_w(fpq_ptr, any_type_ptr, decrease_closure_over_T)</td></tr>
<tr class="memdesc:abab50c378df48872ce942ac89e4a11c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the user type stored in the priority queue directly. O(lgN).  <br /></td></tr>
<tr class="separator:abab50c378df48872ce942ac89e4a11c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096f3b99abc3d0a612593403fab5c5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a096f3b99abc3d0a612593403fab5c5b0">ccc_fpq_heapify</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void *tmp, void *input_array, size_t input_n, size_t input_sizeof_type)</td></tr>
<tr class="memdesc:a096f3b99abc3d0a612593403fab5c5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy input array into the fpq, organizing into heap. O(N).  <br /></td></tr>
<tr class="separator:a096f3b99abc3d0a612593403fab5c5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29efc554db0ce8b27e13e09f39835ca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a29efc554db0ce8b27e13e09f39835ca5">ccc_fpq_heapify_inplace</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void *tmp, size_t n)</td></tr>
<tr class="memdesc:a29efc554db0ce8b27e13e09f39835ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order n elements of the underlying fpq buffer as an fpq.  <br /></td></tr>
<tr class="separator:a29efc554db0ce8b27e13e09f39835ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25b1b64e02e35686cc1a138b20208b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#ae25b1b64e02e35686cc1a138b20208b4">ccc_fpq_alloc</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, size_t new_capacity, <a class="el" href="types_8h.html#a3e73202894869d2840fb21ff912bbd96">ccc_any_alloc_fn</a> *fn)</td></tr>
<tr class="memdesc:ae25b1b64e02e35686cc1a138b20208b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Many allocate memory for the fpq.  <br /></td></tr>
<tr class="separator:ae25b1b64e02e35686cc1a138b20208b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799aff19d6b94ce1a4aeee4b491b23fe"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a799aff19d6b94ce1a4aeee4b491b23fe">ccc_fpq_push</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void const *elem, void *tmp)</td></tr>
<tr class="memdesc:a799aff19d6b94ce1a4aeee4b491b23fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes element pointed to at e into fpq. O(lgN).  <br /></td></tr>
<tr class="separator:a799aff19d6b94ce1a4aeee4b491b23fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b14ac07255f984b838843fd0a3e761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a68b14ac07255f984b838843fd0a3e761">ccc_fpq_pop</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void *tmp)</td></tr>
<tr class="memdesc:a68b14ac07255f984b838843fd0a3e761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the front element (min or max) element in the fpq. O(lgN).  <br /></td></tr>
<tr class="separator:a68b14ac07255f984b838843fd0a3e761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8343add4d01790de653f7b0f58afcfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#ae8343add4d01790de653f7b0f58afcfb">ccc_fpq_erase</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void *elem, void *tmp)</td></tr>
<tr class="memdesc:ae8343add4d01790de653f7b0f58afcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element e that is a handle to the stored fpq element.  <br /></td></tr>
<tr class="separator:ae8343add4d01790de653f7b0f58afcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c11b1f31545af6406fc77fa670de9ad"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a1c11b1f31545af6406fc77fa670de9ad">ccc_fpq_update</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void *elem, void *tmp, <a class="el" href="types_8h.html#ada79c0d2b3cfeee31b9990c23a187d12">ccc_any_type_update_fn</a> *fn, void *aux)</td></tr>
<tr class="memdesc:a1c11b1f31545af6406fc77fa670de9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update e that is a handle to the stored fpq element. O(lgN).  <br /></td></tr>
<tr class="separator:a1c11b1f31545af6406fc77fa670de9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfb11ac2654304582dce575ae738861"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a3cfb11ac2654304582dce575ae738861">ccc_fpq_increase</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void *elem, void *tmp, <a class="el" href="types_8h.html#ada79c0d2b3cfeee31b9990c23a187d12">ccc_any_type_update_fn</a> *fn, void *aux)</td></tr>
<tr class="memdesc:a3cfb11ac2654304582dce575ae738861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase e that is a handle to the stored fpq element. O(lgN).  <br /></td></tr>
<tr class="separator:a3cfb11ac2654304582dce575ae738861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39a2c39c54275a2ff29b82a13d4a089"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#aa39a2c39c54275a2ff29b82a13d4a089">ccc_fpq_decrease</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void *elem, void *tmp, <a class="el" href="types_8h.html#ada79c0d2b3cfeee31b9990c23a187d12">ccc_any_type_update_fn</a> *fn, void *aux)</td></tr>
<tr class="memdesc:aa39a2c39c54275a2ff29b82a13d4a089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease e that is a handle to the stored fpq element. O(lgN).  <br /></td></tr>
<tr class="separator:aa39a2c39c54275a2ff29b82a13d4a089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Types available in the container interface. </p>
</td></tr>
<tr class="memitem:a5fd5a6ed6546b30a2f61de13d7f97817"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_fpq&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a></td></tr>
<tr class="memdesc:a5fd5a6ed6546b30a2f61de13d7f97817"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container offering direct storage and sorting of user data by heap order.  <br /></td></tr>
<tr class="separator:a5fd5a6ed6546b30a2f61de13d7f97817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Deallocate the container or destroy the heap invariants. </p>
</td></tr>
<tr class="memitem:a46f0ae8fcbfd9f3d6cb1667c5e428826"><td class="memItemLeft" align="right" valign="top">ccc_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a46f0ae8fcbfd9f3d6cb1667c5e428826">ccc_fpq_heapsort</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, void *tmp)</td></tr>
<tr class="memdesc:a46f0ae8fcbfd9f3d6cb1667c5e428826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the fpq by sorting its data and returning the underlying buffer. The data is sorted in <code>O(N * log(N))</code> time and <code>O(1)</code> space.  <br /></td></tr>
<tr class="separator:a46f0ae8fcbfd9f3d6cb1667c5e428826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae67e38b248056c21865d20978d42bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a8ae67e38b248056c21865d20978d42bf">ccc_fpq_clear</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, <a class="el" href="types_8h.html#a97f231bd3df31cb2730e3304d4cc1dd2">ccc_any_type_destructor_fn</a> *fn)</td></tr>
<tr class="memdesc:a8ae67e38b248056c21865d20978d42bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the fpq calling fn on every element if provided. O(1)-O(N).  <br /></td></tr>
<tr class="separator:a8ae67e38b248056c21865d20978d42bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8a4c0c941d14f8a721cc529eb64fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a7f8a4c0c941d14f8a721cc529eb64fce">ccc_fpq_clear_and_free</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, <a class="el" href="types_8h.html#a97f231bd3df31cb2730e3304d4cc1dd2">ccc_any_type_destructor_fn</a> *fn)</td></tr>
<tr class="memdesc:a7f8a4c0c941d14f8a721cc529eb64fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the fpq calling fn on every element if provided and frees the underlying buffer. O(1)-O(N).  <br /></td></tr>
<tr class="separator:a7f8a4c0c941d14f8a721cc529eb64fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2387a268f99be1f8cf3672e964af4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#aca2387a268f99be1f8cf3672e964af4a">ccc_fpq_clear_and_free_reserve</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *fpq, <a class="el" href="types_8h.html#a97f231bd3df31cb2730e3304d4cc1dd2">ccc_any_type_destructor_fn</a> *destructor, <a class="el" href="types_8h.html#a3e73202894869d2840fb21ff912bbd96">ccc_any_alloc_fn</a> *alloc)</td></tr>
<tr class="memdesc:aca2387a268f99be1f8cf3672e964af4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the fpq and frees the underlying buffer that was previously dynamically reserved with the reserve function.  <br /></td></tr>
<tr class="separator:aca2387a268f99be1f8cf3672e964af4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain state from the container. </p>
</td></tr>
<tr class="memitem:a51c6495321c6d46093b06ef01f0c6360"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a51c6495321c6d46093b06ef01f0c6360">ccc_fpq_front</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *fpq)</td></tr>
<tr class="memdesc:a51c6495321c6d46093b06ef01f0c6360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the front (min or max) element in the fpq. O(1).  <br /></td></tr>
<tr class="separator:a51c6495321c6d46093b06ef01f0c6360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c76f3d7e3ed207ff526c07b759ce4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a80a7915df3bc36e01a3a0775eebc0938">ccc_tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a0c76f3d7e3ed207ff526c07b759ce4c5">ccc_fpq_is_empty</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *fpq)</td></tr>
<tr class="memdesc:a0c76f3d7e3ed207ff526c07b759ce4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the fpq is empty false if not. O(1).  <br /></td></tr>
<tr class="separator:a0c76f3d7e3ed207ff526c07b759ce4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c1ca80feb4ade1bdf383e7cb21f735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structccc__ucount.html">ccc_ucount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#af0c1ca80feb4ade1bdf383e7cb21f735">ccc_fpq_count</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *fpq)</td></tr>
<tr class="memdesc:af0c1ca80feb4ade1bdf383e7cb21f735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of the fpq active slots.  <br /></td></tr>
<tr class="separator:af0c1ca80feb4ade1bdf383e7cb21f735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1180cd15477e5b1f0a2ebc3b5bc015a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structccc__ucount.html">ccc_ucount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#af1180cd15477e5b1f0a2ebc3b5bc015a">ccc_fpq_capacity</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *fpq)</td></tr>
<tr class="memdesc:af1180cd15477e5b1f0a2ebc3b5bc015a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the fpq representing total possible slots.  <br /></td></tr>
<tr class="separator:af1180cd15477e5b1f0a2ebc3b5bc015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005d37789d5cc821356252292cba646b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a005d37789d5cc821356252292cba646b">ccc_fpq_data</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *fpq)</td></tr>
<tr class="memdesc:a005d37789d5cc821356252292cba646b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the base of the backing array. O(1).  <br /></td></tr>
<tr class="separator:a005d37789d5cc821356252292cba646b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9aa3fe7a477f99fb0abc69bbdf67f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a80a7915df3bc36e01a3a0775eebc0938">ccc_tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#abd9aa3fe7a477f99fb0abc69bbdf67f0">ccc_fpq_validate</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *fpq)</td></tr>
<tr class="memdesc:abd9aa3fe7a477f99fb0abc69bbdf67f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies the internal invariants of the fpq hold.  <br /></td></tr>
<tr class="separator:abd9aa3fe7a477f99fb0abc69bbdf67f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422acb75de11ece2ae4d9725fc4a468b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#afa7f5d9756840807860490d28e345955">ccc_threeway_cmp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__priority__queue_8h.html#a422acb75de11ece2ae4d9725fc4a468b">ccc_fpq_order</a> (<a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *fpq)</td></tr>
<tr class="memdesc:a422acb75de11ece2ae4d9725fc4a468b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the order used to initialize the fpq.  <br /></td></tr>
<tr class="separator:a422acb75de11ece2ae4d9725fc4a468b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="abab50c378df48872ce942ac89e4a11c9" name="abab50c378df48872ce942ac89e4a11c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab50c378df48872ce942ac89e4a11c9">&#9670;&#160;</a></span>ccc_fpq_decrease_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fpq_decrease_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fpq_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">any_type_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">decrease_closure_over_T...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_fpq_decrease_w(fpq_ptr, any_type_ptr, decrease_closure_over_T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the user type stored in the priority queue directly. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq_ptr</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">any_type_ptr</td><td>a pointer to the user type being updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decrease_closure_over_T</td><td>the semicolon separated statements to execute on the user type at T (optionally wrapping {code here} in braces may help with formatting). This closure may safely modify the key used to track the user element's priority in the priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at its new position in the fpq on success, NULL if parameters are invalid or fpq is empty. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the user must ensure any_type_ptr is in the fpq.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_priority_queue fpq = build_rand_int_fpq();</div>
<div class="line">(void)fpq_decrease_w(&amp;fpq, get_rand_fpq_elem(&amp;fpq), { (*T)--; });</div>
</div><!-- fragment --><p>Note that if this priority queue is min or max, the runtime is the same. </p>

</div>
</div>
<a id="a1c8103699b633d1da090dd867b46d1ec" name="a1c8103699b633d1da090dd867b46d1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8103699b633d1da090dd867b46d1ec">&#9670;&#160;</a></span>ccc_fpq_emplace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fpq_emplace</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fpq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val_initializer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_fpq_emplace(fpq, val_initializer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a type directly to a priority queue slot. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_initializer</td><td>the compound literal or direct scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the inserted element or NULL if allocation failed. </dd></dl>

</div>
</div>
<a id="a7a3542f48eda623e55b72e8ef4cc7ae3" name="a7a3542f48eda623e55b72e8ef4cc7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3542f48eda623e55b72e8ef4cc7ae3">&#9670;&#160;</a></span>ccc_fpq_heapify_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fpq_heapify_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mem_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">any_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmp_order, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmp_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alloc_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">aux_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ccc_impl_fpq_heapify_init(mem_ptr, any_type_name, cmp_order, cmp_fn,       \</div>
<div class="line">                              alloc_fn, aux_data, capacity, size)</div>
</div><!-- fragment -->
<p>Partial order an array of elements as a min or max heap. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_ptr</td><td>a pointer to an array of user types or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">any_type_name</td><td>the name of the user type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_order</td><td>CCC_LES or CCC_GRT for min or max heap, respectively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_fn</td><td>the user defined comparison function for user types. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_fn</td><td>the allocation function or NULL if no allocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux_data</td><td>any auxiliary data needed for destruction of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the capacity of contiguous elements at mem_ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size &lt;= capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized priority queue on the right hand side of an equality operator. (i.e. ccc_flat_priority_queue q = <a class="el" href="flat__priority__queue_8h.html#a7a3542f48eda623e55b72e8ef4cc7ae3" title="Partial order an array of elements as a min or max heap. O(N).">ccc_fpq_heapify_init(...)</a>;). </dd></dl>

</div>
</div>
<a id="a22f154ea0ca88725a32a07bd57886e54" name="a22f154ea0ca88725a32a07bd57886e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f154ea0ca88725a32a07bd57886e54">&#9670;&#160;</a></span>ccc_fpq_increase_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fpq_increase_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fpq_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">any_type_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">increase_closure_over_T...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_fpq_increase_w(fpq_ptr, any_type_ptr, increase_closure_over_T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the user type stored in the priority queue directly. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq_ptr</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">any_type_ptr</td><td>a pointer to the user type being updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">increase_closure_over_T</td><td>the semicolon separated statements to execute on the user type at T (optionally wrapping {code here} in braces may help with formatting). This closure may safely modify the key used to track the user element's priority in the priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at its new position in the fpq on success, NULL if parameters are invalid or fpq is empty. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the user must ensure any_type_ptr is in the fpq.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_priority_queue fpq = build_rand_int_fpq();</div>
<div class="line">(void)fpq_increase_w(&amp;fpq, get_rand_fpq_elem(&amp;fpq), { (*T)++; });</div>
</div><!-- fragment --><p>Note that if this priority queue is min or max, the runtime is the same. </p>

</div>
</div>
<a id="abb90b4408d828e1f2820858c6523f289" name="abb90b4408d828e1f2820858c6523f289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb90b4408d828e1f2820858c6523f289">&#9670;&#160;</a></span>ccc_fpq_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fpq_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mem_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">any_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmp_order, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmp_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alloc_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">aux_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ccc_impl_fpq_init(mem_ptr, any_type_name, cmp_order, cmp_fn, alloc_fn,     \</div>
<div class="line">                      aux_data, capacity)</div>
</div><!-- fragment -->
<p>Initialize a fpq as a min or max heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_ptr</td><td>a pointer to an array of user types or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">any_type_name</td><td>the name of the user type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_order</td><td>CCC_LES or CCC_GRT for min or max heap, respectively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_fn</td><td>the user defined comarison function for user types. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_fn</td><td>the allocation function or NULL if no allocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux_data</td><td>any auxiliary data needed for destruction of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the capacity of contiguous elements at mem_ptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized priority queue on the right hand side of an equality operator. (i.e. ccc_flat_priority_queue q = <a class="el" href="flat__priority__queue_8h.html#abb90b4408d828e1f2820858c6523f289" title="Initialize a fpq as a min or max heap.">ccc_fpq_init(...)</a>;). </dd></dl>

</div>
</div>
<a id="ae6637e9dc9b06d7026319cc8498ec4d9" name="ae6637e9dc9b06d7026319cc8498ec4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6637e9dc9b06d7026319cc8498ec4d9">&#9670;&#160;</a></span>ccc_fpq_update_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fpq_update_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fpq_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">any_type_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">update_closure_over_T...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_fpq_update_w(fpq_ptr, any_type_ptr, update_closure_over_T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the user type stored in the priority queue directly. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq_ptr</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">any_type_ptr</td><td>a pointer to the user type being updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_closure_over_T</td><td>the semicolon separated statements to execute on the user type at T (optionally wrapping {code here} in braces may help with formatting). This closure may safely modify the key used to track the user element's priority in the priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at its new position in the fpq on success, NULL if parameters are invalid or fpq is empty. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the user must ensure any_type_ptr is in the fpq.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_priority_queue fpq = build_rand_int_fpq();</div>
<div class="line">(void)fpq_update_w(&amp;fpq, get_rand_fpq_elem(&amp;fpq), { *T = rand_key(); });</div>
</div><!-- fragment --><p>Note that whether the key increases or decreases does not affect runtime. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5fd5a6ed6546b30a2f61de13d7f97817" name="a5fd5a6ed6546b30a2f61de13d7f97817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd5a6ed6546b30a2f61de13d7f97817">&#9670;&#160;</a></span>ccc_flat_priority_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_fpq <a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container offering direct storage and sorting of user data by heap order. </p>
<dl class="section warning"><dt>Warning</dt><dd>it is undefined behavior to access an uninitialized container.</dd></dl>
<p>A flat priority queue can be initialized on the stack, heap, or data segment at runtime or compile time. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae25b1b64e02e35686cc1a138b20208b4" name="ae25b1b64e02e35686cc1a138b20208b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25b1b64e02e35686cc1a138b20208b4">&#9670;&#160;</a></span>ccc_fpq_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a3e73202894869d2840fb21ff912bbd96">ccc_any_alloc_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many allocate memory for the fpq. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_capacity</td><td>the desired capacity for the fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the allocation function. May be the same as used on init. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if allocation was successful or a memory error on failure. </dd></dl>

</div>
</div>
<a id="af1180cd15477e5b1f0a2ebc3b5bc015a" name="af1180cd15477e5b1f0a2ebc3b5bc015a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1180cd15477e5b1f0a2ebc3b5bc015a">&#9670;&#160;</a></span>ccc_fpq_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccc__ucount.html">ccc_ucount</a> ccc_fpq_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *&#160;</td>
          <td class="paramname"><em>fpq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the capacity of the fpq representing total possible slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity of the fpq or an argument error is set if fpq is NULL. </dd></dl>

</div>
</div>
<a id="a8ae67e38b248056c21865d20978d42bf" name="a8ae67e38b248056c21865d20978d42bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae67e38b248056c21865d20978d42bf">&#9670;&#160;</a></span>ccc_fpq_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a97f231bd3df31cb2730e3304d4cc1dd2">ccc_any_type_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the fpq calling fn on every element if provided. O(1)-O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the destructor function or NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if input is valid and clear succeeds, otherwise input error.</dd></dl>
<p>Note that because the priority queue is flat there is no need to free elements stored in the fpq. However, the destructor is free to manage cleanup in other parts of user code as needed upon destruction of each element.</p>
<p>If the destructor is NULL, the function is O(1) and no attempt is made to free capacity of the fpq. </p>

</div>
</div>
<a id="a7f8a4c0c941d14f8a721cc529eb64fce" name="a7f8a4c0c941d14f8a721cc529eb64fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8a4c0c941d14f8a721cc529eb64fce">&#9670;&#160;</a></span>ccc_fpq_clear_and_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_clear_and_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a97f231bd3df31cb2730e3304d4cc1dd2">ccc_any_type_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the fpq calling fn on every element if provided and frees the underlying buffer. O(1)-O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the destructor function or NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if input is valid and clear succeeds, otherwise input error. If the buffer attempts to free but is not allowed a no alloc error is returned.</dd></dl>
<p>Note that because the priority queue is flat there is no need to free elements stored in the fpq. However, the destructor is free to manage cleanup in other parts of user code as needed upon destruction of each element.</p>
<p>If the destructor is NULL, the function is O(1) and only relies on the runtime of the provided allocation function free operation. </p>

</div>
</div>
<a id="aca2387a268f99be1f8cf3672e964af4a" name="aca2387a268f99be1f8cf3672e964af4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2387a268f99be1f8cf3672e964af4a">&#9670;&#160;</a></span>ccc_fpq_clear_and_free_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_clear_and_free_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a97f231bd3df31cb2730e3304d4cc1dd2">ccc_any_type_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>destructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a3e73202894869d2840fb21ff912bbd96">ccc_any_alloc_fn</a> *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the fpq and frees the underlying buffer that was previously dynamically reserved with the reserve function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>the fpq to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the fpq before their slots are dropped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>the required allocation function to provide to a dynamically reserved fpq. Any auxiliary data provided upon initialization will be passed to the allocation function when called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of free operation. OK if success, or an error status to indicate the error. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is an error to call this function on a fpq that was not reserved with the provided ccc_any_alloc_fn. The fpq must have existing memory to free.</dd></dl>
<p>This function covers the edge case of reserving a dynamic capacity for a fpq at runtime but denying the fpq allocation permission to resize. This can help prevent a fpq from growing unbounded. The user in this case knows the fpq does not have allocation permission and therefore no further memory will be dedicated to the fpq.</p>
<p>However, to free the fpq in such a case this function must be used because the fpq has no ability to free itself. Just as the allocation function is required to reserve memory so to is it required to free memory.</p>
<p>This function will work normally if called on a fpq with allocation permission however the normal ccc_fpq_clear_and_free is sufficient for that use case. </p>

</div>
</div>
<a id="ad65d783f01bd17614486b178bb2c7015" name="ad65d783f01bd17614486b178bb2c7015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65d783f01bd17614486b178bb2c7015">&#9670;&#160;</a></span>ccc_fpq_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a3e73202894869d2840fb21ff912bbd96">ccc_any_alloc_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the fpq from src to newly initialized dst. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>the destination that will copy the source fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source of the fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the allocation function in case resizing of dst is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the copy operation. If the destination capacity is less than the source capacity and no allocation function is provided an input error is returned. If resizing is required and resizing of dst fails a memory error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>dst must have capacity greater than or equal to src. If dst capacity is less than src, an allocation function must be provided with the fn argument.</dd></dl>
<p>Note that there are two ways to copy data from source to destination: provide sufficient memory and pass NULL as fn, or allow the copy function to take care of allocation for the copy.</p>
<p>Manual memory management with no allocation function provided.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_priority_queue src</div>
<div class="line">    = fpq_init((<span class="keywordtype">int</span>[10]){}, <a class="code hl_enumvalue" href="types_8h.html#afa7f5d9756840807860490d28e345955a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, NULL, int_cmp, NULL, 10);</div>
<div class="line">push_rand_ints(&amp;src);</div>
<div class="line">flat_priority_queue dst</div>
<div class="line">    = fpq_init((<span class="keywordtype">int</span>[11]){}, <a class="code hl_enumvalue" href="types_8h.html#afa7f5d9756840807860490d28e345955a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, NULL, int_cmp, NULL, 11);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> res = fpq_copy(&amp;dst, &amp;src, NULL);</div>
<div class="ttc" id="atypes_8h_html_a51d6f078a83d667aff5016609d9146ef"><div class="ttname"><a href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a></div><div class="ttdeci">ccc_result</div><div class="ttdoc">A result of actions on containers.</div><div class="ttdef"><b>Definition:</b> types.h:132</div></div>
<div class="ttc" id="atypes_8h_html_afa7f5d9756840807860490d28e345955a813ea7b9e526748af7efa9a83da12ee8"><div class="ttname"><a href="types_8h.html#afa7f5d9756840807860490d28e345955a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a></div><div class="ttdeci">@ CCC_LES</div><div class="ttdef"><b>Definition:</b> types.h:155</div></div>
</div><!-- fragment --><p>The above requires dst capacity be greater than or equal to src capacity. Here is memory management handed over to the copy function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_priority_queue src</div>
<div class="line">    = fpq_init((<span class="keywordtype">int</span> *)NULL, <a class="code hl_enumvalue" href="types_8h.html#afa7f5d9756840807860490d28e345955a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, std_alloc, int_cmp, NULL, 0);</div>
<div class="line">push_rand_ints(&amp;src);</div>
<div class="line">flat_priority_queue dst</div>
<div class="line">    = fpq_init((<span class="keywordtype">int</span> *)NULL, <a class="code hl_enumvalue" href="types_8h.html#afa7f5d9756840807860490d28e345955a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, std_alloc, int_cmp, NULL, 0);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> res = fpq_copy(&amp;dst, &amp;src, std_alloc);</div>
</div><!-- fragment --><p>The above allows dst to have a capacity less than that of the src as long as copy has been provided an allocation function to resize dst. Note that this would still work if copying to a destination that the user wants as a fixed size fpq.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_priority_queue src</div>
<div class="line">    = fpq_init((<span class="keywordtype">int</span> *)NULL, <a class="code hl_enumvalue" href="types_8h.html#afa7f5d9756840807860490d28e345955a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, std_alloc, int_cmp, NULL, 0);</div>
<div class="line">push_rand_ints(&amp;src);</div>
<div class="line">flat_priority_queue dst</div>
<div class="line">    = fpq_init((<span class="keywordtype">int</span> *)NULL, <a class="code hl_enumvalue" href="types_8h.html#afa7f5d9756840807860490d28e345955a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, NULL, int_cmp, NULL, 0);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> res = fpq_copy(&amp;dst, &amp;src, std_alloc);</div>
</div><!-- fragment --><p>The above sets up dst with fixed size while src is a dynamic fpq. Because an allocation function is provided, the dst is resized once for the copy and retains its fixed size after the copy is complete. This would require the user to manually free the underlying buffer at dst eventually if this method is used. Usually it is better to allocate the memory explicitly before the copy if copying between ring buffers.</p>
<p>These options allow users to stay consistent across containers with their memory management strategies. </p>

</div>
</div>
<a id="af0c1ca80feb4ade1bdf383e7cb21f735" name="af0c1ca80feb4ade1bdf383e7cb21f735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c1ca80feb4ade1bdf383e7cb21f735">&#9670;&#160;</a></span>ccc_fpq_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccc__ucount.html">ccc_ucount</a> ccc_fpq_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *&#160;</td>
          <td class="paramname"><em>fpq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the count of the fpq active slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the fpq or an argument error is set if fpq is NULL. </dd></dl>

</div>
</div>
<a id="a005d37789d5cc821356252292cba646b" name="a005d37789d5cc821356252292cba646b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005d37789d5cc821356252292cba646b">&#9670;&#160;</a></span>ccc_fpq_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fpq_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *&#160;</td>
          <td class="paramname"><em>fpq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the base of the backing array. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the base of the backing array or NULL if fpq is NULL. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this reference starts at index 0 of the backing array. All fpq elements are stored contiguously starting at the base through size of the fpq. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it is the users responsibility to ensure that access to any data is within the capacity of the backing buffer. </dd></dl>

</div>
</div>
<a id="aa39a2c39c54275a2ff29b82a13d4a089" name="aa39a2c39c54275a2ff29b82a13d4a089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39a2c39c54275a2ff29b82a13d4a089">&#9670;&#160;</a></span>ccc_fpq_decrease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fpq_decrease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ada79c0d2b3cfeee31b9990c23a187d12">ccc_any_type_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease e that is a handle to the stored fpq element. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the stored fpq element. Must be in the fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to a dummy user type that will be used for swapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the update function to act on e. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>any auxiliary data needed for the update function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at its new position in the fpq on success, NULL if parameters are invalid or fpq is empty. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the user must ensure e is in the fpq.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>. </p>

</div>
</div>
<a id="ae8343add4d01790de653f7b0f58afcfb" name="ae8343add4d01790de653f7b0f58afcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8343add4d01790de653f7b0f58afcfb">&#9670;&#160;</a></span>ccc_fpq_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase element e that is a handle to the stored fpq element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the stored fpq element. Must be in the fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to a dummy user type that will be used for swapping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if the erase is successful or an input error if NULL args are provided or the fpq is empty. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the user must ensure e is in the fpq.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>.</p>
<p>Note that the reference to elem is invalidated after this call. </p>

</div>
</div>
<a id="a51c6495321c6d46093b06ef01f0c6360" name="a51c6495321c6d46093b06ef01f0c6360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c6495321c6d46093b06ef01f0c6360">&#9670;&#160;</a></span>ccc_fpq_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fpq_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *&#160;</td>
          <td class="paramname"><em>fpq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the front (min or max) element in the fpq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the front element or NULL if empty or fpq is NULL. </dd></dl>

</div>
</div>
<a id="a096f3b99abc3d0a612593403fab5c5b0" name="a096f3b99abc3d0a612593403fab5c5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096f3b99abc3d0a612593403fab5c5b0">&#9670;&#160;</a></span>ccc_fpq_heapify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_heapify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>input_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_sizeof_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy input array into the fpq, organizing into heap. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to an additional element of array type for swapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_array</td><td>an array of elements of the same size as the type used to initialize fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_n</td><td>the number of contiguous elements at input_array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_sizeof_type</td><td>size of each element in input_array matching element size of fpq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if sorting was successful or an input error if bad input is provided. A permission error will occur if no allocation is allowed and the input array is larger than the fixed fpq capacity. A memory error will occur if reallocation is required to fit all elements but reallocation fails.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>.</p>
<p>Note that this version of heapify copies elements from the input array. If an in place heapify is required use the initializer version of this method. </p>

</div>
</div>
<a id="a29efc554db0ce8b27e13e09f39835ca5" name="a29efc554db0ce8b27e13e09f39835ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29efc554db0ce8b27e13e09f39835ca5">&#9670;&#160;</a></span>ccc_fpq_heapify_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_heapify_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Order n elements of the underlying fpq buffer as an fpq. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to a dummy user type that will be used for swapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number n of elements where 0 &lt; (n + 1) &lt;= capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the heapify operation, ok if successful or an error if fpq is NULL or n is larger than the initialized capacity of the fpq.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>.</p>
<p>This is another method to order a heap that already has all the elements one needs sorted. The underlying buffer will be interpreted to have n valid elements starting at index 0 to index n - 1. </p>

</div>
</div>
<a id="a46f0ae8fcbfd9f3d6cb1667c5e428826" name="a46f0ae8fcbfd9f3d6cb1667c5e428826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f0ae8fcbfd9f3d6cb1667c5e428826">&#9670;&#160;</a></span>ccc_fpq_heapsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccc_buffer ccc_fpq_heapsort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the fpq by sorting its data and returning the underlying buffer. The data is sorted in <code>O(N * log(N))</code> time and <code>O(1)</code> space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>the fpq to be sorted and destroyed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to a dummy user type that will be used for swapping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer filled from the back to the front by the fpq order. If the fpq is initialized CCC_LES the returned buffer is sorted in non-increasing order from index [0, N). If the fpq is initialized CCC_GRT the buffer is sorted in non-descending order from index [0, N). If fpq is NULL, the buffer is default initialized and unusable. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>all fields of the fpq are cleared or otherwise default initialized so the fpq is unusable as a container after sorting. This function assumes the fpq has been previously initialized. Therefore, if the returned buffer value is not used the fpq memory is leaked.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>.</p>
<p>The underlying memory storage source for the fpq, a buffer, is not moved or copied during the sort. If a copy of the sorted data is preferred copy the data the data to another initialized fpq with the <code>ccc_fpq_copy</code> function first then sort that copy.</p>
<p>The sort is not inherently stable and uses the provided comparison function to the fpq to order the elements. </p>

</div>
</div>
<a id="a3cfb11ac2654304582dce575ae738861" name="a3cfb11ac2654304582dce575ae738861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfb11ac2654304582dce575ae738861">&#9670;&#160;</a></span>ccc_fpq_increase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fpq_increase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ada79c0d2b3cfeee31b9990c23a187d12">ccc_any_type_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase e that is a handle to the stored fpq element. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the stored fpq element. Must be in the fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to a dummy user type that will be used for swapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the update function to act on e. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>any auxiliary data needed for the update function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at its new position in the fpq on success, NULL if parameters are invalid or fpq is empty. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the user must ensure e is in the fpq.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>. </p>

</div>
</div>
<a id="a0c76f3d7e3ed207ff526c07b759ce4c5" name="a0c76f3d7e3ed207ff526c07b759ce4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c76f3d7e3ed207ff526c07b759ce4c5">&#9670;&#160;</a></span>ccc_fpq_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a80a7915df3bc36e01a3a0775eebc0938">ccc_tribool</a> ccc_fpq_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *&#160;</td>
          <td class="paramname"><em>fpq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the fpq is empty false if not. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size is 0, false if not empty. Error if fpq is NULL. </dd></dl>

</div>
</div>
<a id="a422acb75de11ece2ae4d9725fc4a468b" name="a422acb75de11ece2ae4d9725fc4a468b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422acb75de11ece2ae4d9725fc4a468b">&#9670;&#160;</a></span>ccc_fpq_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#afa7f5d9756840807860490d28e345955">ccc_threeway_cmp</a> ccc_fpq_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *&#160;</td>
          <td class="paramname"><em>fpq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the order used to initialize the fpq. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LES or GRT ordering. Any other ordering is invalid. </dd></dl>

</div>
</div>
<a id="a68b14ac07255f984b838843fd0a3e761" name="a68b14ac07255f984b838843fd0a3e761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b14ac07255f984b838843fd0a3e761">&#9670;&#160;</a></span>ccc_fpq_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the front element (min or max) element in the fpq. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to a dummy user type that will be used for swapping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if the pop succeeds or an input error if fpq is NULL or empty.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>. </p>

</div>
</div>
<a id="a799aff19d6b94ce1a4aeee4b491b23fe" name="a799aff19d6b94ce1a4aeee4b491b23fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799aff19d6b94ce1a4aeee4b491b23fe">&#9670;&#160;</a></span>ccc_fpq_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fpq_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes element pointed to at e into fpq. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the user element of same type as in fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to a dummy user type that will be used for swapping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inserted element or NULl if NULL args are provided or push required more memory and failed. Failure can occur if the fpq is full and allocation is not allowed or a resize failed when allocation is allowed.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>. </p>

</div>
</div>
<a id="ab1ad4f0ed5e05f3582d37c8306b57358" name="ab1ad4f0ed5e05f3582d37c8306b57358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ad4f0ed5e05f3582d37c8306b57358">&#9670;&#160;</a></span>ccc_fpq_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a51d6f078a83d667aff5016609d9146ef">ccc_result</a> ccc_fpq_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a3e73202894869d2840fb21ff912bbd96">ccc_any_alloc_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves space for at least to_add more elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_add</td><td>the number of elements to add to the current size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the allocation function to use to reserve memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the reservation. OK if successful, otherwise an error status is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see the ccc_fpq_clear_and_free_reserve function if this function is being used for a one-time dynamic reservation.</dd></dl>
<p>This function can be used for a dynamic fpq with or without allocation permission. If the fpq has allocation permission, it will reserve the required space and later resize if more space is needed.</p>
<p>If the fpq has been initialized with no allocation permission and no memory this function can serve as a one-time reservation. This is helpful when a fixed size is needed but that size is only known dynamically at runtime. To free the fpq in such a case see the ccc_fpq_clear_and_free_reserve function. </p>

</div>
</div>
<a id="a1c11b1f31545af6406fc77fa670de9ad" name="a1c11b1f31545af6406fc77fa670de9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c11b1f31545af6406fc77fa670de9ad">&#9670;&#160;</a></span>ccc_fpq_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fpq_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> *&#160;</td>
          <td class="paramname"><em>fpq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ada79c0d2b3cfeee31b9990c23a187d12">ccc_any_type_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update e that is a handle to the stored fpq element. O(lgN). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the stored fpq element. Must be in the fpq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>a pointer to a dummy user type that will be used for swapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the update function to act on e. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>any auxiliary data needed for the update function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at its new position in the fpq on success, NULL if parameters are invalid or fpq is empty. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the user must ensure e is in the fpq.</dd></dl>
<p>A simple way to provide a temp for swapping is with an inline compound literal reference provided directly to the function argument <code>&amp;(name_of_type){}</code>. </p>

</div>
</div>
<a id="abd9aa3fe7a477f99fb0abc69bbdf67f0" name="abd9aa3fe7a477f99fb0abc69bbdf67f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9aa3fe7a477f99fb0abc69bbdf67f0">&#9670;&#160;</a></span>ccc_fpq_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a80a7915df3bc36e01a3a0775eebc0938">ccc_tribool</a> ccc_fpq_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__priority__queue_8h.html#a5fd5a6ed6546b30a2f61de13d7f97817">ccc_flat_priority_queue</a> const *&#160;</td>
          <td class="paramname"><em>fpq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies the internal invariants of the fpq hold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fpq</td><td>a pointer to the flat priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the fpq is valid false if invalid. Error if fpq is NULL. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="flat__priority__queue_8h.html">flat_priority_queue.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
