<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/types.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('types_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">types.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The C Container Collection Fundamental Types.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;impl/impl_types.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for types.h:</div>
<div class="dyncontent">
<div class="center"><img src="types_8h__incl.png" border="0" usemap="#accc_2types_8h" alt=""/></div>
<map name="accc_2types_8h" id="accc_2types_8h">
<area shape="rect" title="The C Container Collection Fundamental Types." alt="" coords="27,5,122,31"/>
<area shape="rect" href="impl__types_8h_source.html" title=" " alt="" coords="5,79,144,104"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="types_8h__dep__incl.png" border="0" usemap="#accc_2types_8hdep" alt=""/></div>
<map name="accc_2types_8hdep" id="accc_2types_8hdep">
<area shape="rect" title="The C Container Collection Fundamental Types." alt="" coords="891,5,986,31"/>
<area shape="rect" href="buffer_8h.html" title="The Buffer Interface." alt="" coords="513,174,609,199"/>
<area shape="rect" href="flat__double__ended__queue_8h.html" title="The Flat Double Ended Queue Interface." alt="" coords="314,343,481,383"/>
<area shape="rect" href="impl__traits_8h_source.html" title=" " alt="" coords="1057,431,1220,456"/>
<area shape="rect" href="impl__flat__hash__map_8h_source.html" title=" " alt="" coords="145,255,282,295"/>
<area shape="rect" href="flat__hash__map_8h.html" title="The Flat Hash Map Interface." alt="" coords="135,350,289,375"/>
<area shape="rect" href="impl__flat__ordered__map_8h_source.html" title=" " alt="" coords="561,255,698,295"/>
<area shape="rect" href="flat__ordered__map_8h.html" title="The Flat Ordered Map Interface." alt="" coords="643,350,816,375"/>
<area shape="rect" href="impl__flat__priority__queue_8h_source.html" title=" " alt="" coords="774,255,911,295"/>
<area shape="rect" href="flat__priority__queue_8h.html" title="The Flat Priority Queue Interface." alt="" coords="840,350,1021,375"/>
<area shape="rect" href="impl__flat__realtime__ordered__map_8h_source.html" title=" " alt="" coords="987,255,1176,295"/>
<area shape="rect" href="flat__realtime__ordered__map_8h.html" title="The Flat Realtime Ordered Map Interface." alt="" coords="1045,343,1232,383"/>
<area shape="rect" href="doubly__linked__list_8h.html" title="The Doubly Linked List Interface." alt="" coords="1067,174,1243,199"/>
<area shape="rect" href="impl__buffer_8h_source.html" title=" " alt="" coords="432,86,597,111"/>
<area shape="rect" href="impl__doubly__linked__list_8h_source.html" title=" " alt="" coords="976,79,1136,119"/>
<area shape="rect" href="impl__priority__queue_8h_source.html" title=" " alt="" coords="1211,79,1373,119"/>
<area shape="rect" href="priority__queue_8h.html" title="The Priority Queue Interface." alt="" coords="1267,174,1421,199"/>
<area shape="rect" href="impl__realtime__ordered__map_8h_source.html" title=" " alt="" coords="1448,79,1619,119"/>
<area shape="rect" href="realtime__ordered__map_8h.html" title="The Realtime Ordered Map Interface." alt="" coords="1454,167,1613,207"/>
<area shape="rect" href="impl__singly__linked__list_8h_source.html" title=" " alt="" coords="1693,79,1848,119"/>
<area shape="rect" href="singly__linked__list_8h.html" title="The Singly Linked List Interface." alt="" coords="1685,174,1856,199"/>
<area shape="rect" href="impl__tree_8h_source.html" title=" " alt="" coords="1976,86,2131,111"/>
<area shape="rect" href="ordered__map_8h.html" title="The Ordered Map Interface." alt="" coords="1859,262,2005,287"/>
<area shape="rect" href="ordered__multimap_8h.html" title="The Ordered Multimap Interface." alt="" coords="2155,262,2333,287"/>
<area shape="rect" href="impl__flat__double__ended__queue_8h_source.html" title=" " alt="" coords="307,255,485,295"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="1092,504,1185,529"/>
<area shape="rect" href="impl__ordered__map_8h_source.html" title=" " alt="" coords="1970,167,2137,207"/>
<area shape="rect" href="impl__ordered__multimap_8h_source.html" title=" " alt="" coords="2161,167,2327,207"/>
</map>
</div>
</div>
<p><a href="types_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccc__cmp.html">ccc_cmp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An element comparison helper.  <a href="structccc__cmp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccc__key__cmp.html">ccc_key_cmp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A key comparison helper to avoid argument swapping.  <a href="structccc__key__cmp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccc__user__type.html">ccc_user_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a user type within the container.  <a href="structccc__user__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccc__user__key.html">ccc_user_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read only reference to a key type matching the key field type used for hash containers.  <a href="structccc__user__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3bf43522fb22e6e499ea327fecf35c55"><td class="memItemLeft" align="right" valign="top">typedef union ccc_range_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a></td></tr>
<tr class="memdesc:a3bf43522fb22e6e499ea327fecf35c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a range query on iterable containers.  <br /></td></tr>
<tr class="separator:a3bf43522fb22e6e499ea327fecf35c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe513ff2fb6678559bcbe22e5faca65"><td class="memItemLeft" align="right" valign="top">typedef union ccc_rrange_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a></td></tr>
<tr class="memdesc:abbe513ff2fb6678559bcbe22e5faca65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a rrange query on iterable containers.  <br /></td></tr>
<tr class="separator:abbe513ff2fb6678559bcbe22e5faca65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70feefd55fafc84e06d2f2a1dfd4f389"><td class="memItemLeft" align="right" valign="top">typedef union ccc_entry_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a></td></tr>
<tr class="memdesc:a70feefd55fafc84e06d2f2a1dfd4f389"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Occupied or Vacant position in a searchable container.  <br /></td></tr>
<tr class="separator:a70feefd55fafc84e06d2f2a1dfd4f389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be6e2d1b150a5b77b2eba5ae85764f2"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a>(void *ptr, size_t size, void *aux)</td></tr>
<tr class="memdesc:a8be6e2d1b150a5b77b2eba5ae85764f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocation function at the core of all containers.  <br /></td></tr>
<tr class="separator:a8be6e2d1b150a5b77b2eba5ae85764f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab7f61b1a36b2f31c2289bd6236231"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a78ab7f61b1a36b2f31c2289bd6236231">ccc_cmp_fn</a>(<a class="el" href="structccc__cmp.html">ccc_cmp</a>)</td></tr>
<tr class="memdesc:a78ab7f61b1a36b2f31c2289bd6236231"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function for comparing two elements in a container.  <br /></td></tr>
<tr class="separator:a78ab7f61b1a36b2f31c2289bd6236231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cf33ea819ae97e1cfdcaf1d55a99b0"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a>(<a class="el" href="structccc__user__type.html">ccc_user_type</a>)</td></tr>
<tr class="memdesc:a15cf33ea819ae97e1cfdcaf1d55a99b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function for modifying an element in the container.  <br /></td></tr>
<tr class="separator:a15cf33ea819ae97e1cfdcaf1d55a99b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bb6262f220473dc47f4c73711a6ec5"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a>(<a class="el" href="structccc__user__type.html">ccc_user_type</a>)</td></tr>
<tr class="memdesc:aa2bb6262f220473dc47f4c73711a6ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function for destroying an element in the container.  <br /></td></tr>
<tr class="separator:aa2bb6262f220473dc47f4c73711a6ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08b6b1d54268f3f739a22fea39e2c2d"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ad08b6b1d54268f3f739a22fea39e2c2d">ccc_key_eq_fn</a>(<a class="el" href="structccc__key__cmp.html">ccc_key_cmp</a>)</td></tr>
<tr class="memdesc:ad08b6b1d54268f3f739a22fea39e2c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function to determining equality between two stored keys.  <br /></td></tr>
<tr class="separator:ad08b6b1d54268f3f739a22fea39e2c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8097dd574e739c360d2fa2d3e5de70db"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a8097dd574e739c360d2fa2d3e5de70db">ccc_key_cmp_fn</a>(<a class="el" href="structccc__key__cmp.html">ccc_key_cmp</a>)</td></tr>
<tr class="memdesc:a8097dd574e739c360d2fa2d3e5de70db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function for three-way comparing two stored keys.  <br /></td></tr>
<tr class="separator:a8097dd574e739c360d2fa2d3e5de70db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4ef0c8c3c49edd91423242e6f3a09e"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a0c4ef0c8c3c49edd91423242e6f3a09e">ccc_hash_fn</a>(<a class="el" href="structccc__user__key.html">ccc_user_key</a> to_hash)</td></tr>
<tr class="memdesc:a0c4ef0c8c3c49edd91423242e6f3a09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function to hash the key type used in a container.  <br /></td></tr>
<tr class="separator:a0c4ef0c8c3c49edd91423242e6f3a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1493dc76581f8c71eb96202fb1671ae1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> { <br />
&#160;&#160;<a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1a853ea7c8fbdc75323b7f4367105e9846">CCC_OK</a> = 0
, <a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1ad1f0a157e4e58b4362d6bbd1527b57f4">CCC_NO_ALLOC</a>
, <a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1a85205e3308cd6ef0e0263764938d5d73">CCC_MEM_ERR</a>
, <a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1a87ab32ec108400309c80cdc95a9c1386">CCC_INPUT_ERR</a>
, <br />
&#160;&#160;<a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1affeda2cbcf7e1e7ce8748ab587bf969b">CCC_RESULTS_SIZE</a>
<br />
 }</td></tr>
<tr class="memdesc:a1493dc76581f8c71eb96202fb1671ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A result of actions on containers.  <a href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">More...</a><br /></td></tr>
<tr class="separator:a1493dc76581f8c71eb96202fb1671ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9958f3004414182c457c71289303ae57"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a> { <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a> = -1
, <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57a0ab42c7e0b59a46006cbb959269db825">CCC_EQL</a>
, <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57a60a4aec1f589eaad4a9e922d90501dce">CCC_GRT</a>
, <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57a2975ec57f12b7ce11f4b180af8fec7c5">CCC_CMP_ERR</a>
 }</td></tr>
<tr class="memdesc:a9958f3004414182c457c71289303ae57"><td class="mdescLeft">&#160;</td><td class="mdescRight">A three-way comparison for comparison functions.  <a href="types_8h.html#a9958f3004414182c457c71289303ae57">More...</a><br /></td></tr>
<tr class="separator:a9958f3004414182c457c71289303ae57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac0847e7b4ff4901c016fc1e06142364f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ac0847e7b4ff4901c016fc1e06142364f">ccc_entry_occupied</a> (<a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> const *e)</td></tr>
<tr class="memdesc:ac0847e7b4ff4901c016fc1e06142364f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an entry is Occupied in the container.  <br /></td></tr>
<tr class="separator:ac0847e7b4ff4901c016fc1e06142364f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a10c6e74f36faa343419f01df2da690"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a7a10c6e74f36faa343419f01df2da690">ccc_entry_insert_error</a> (<a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> const *e)</td></tr>
<tr class="memdesc:a7a10c6e74f36faa343419f01df2da690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an insertion error has occurred when a function that attempts to insert a value in a container is used.  <br /></td></tr>
<tr class="separator:a7a10c6e74f36faa343419f01df2da690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd223cf4a594565a536ae518174a9b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a9fd223cf4a594565a536ae518174a9b5">ccc_entry_input_error</a> (<a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> const *e)</td></tr>
<tr class="memdesc:a9fd223cf4a594565a536ae518174a9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an input error has occurred for a function that generates an entry.  <br /></td></tr>
<tr class="separator:a9fd223cf4a594565a536ae518174a9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013507ec0883722ec0d986ce1f51ee37"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a013507ec0883722ec0d986ce1f51ee37">ccc_entry_unwrap</a> (<a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> const *e)</td></tr>
<tr class="memdesc:a013507ec0883722ec0d986ce1f51ee37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps the provided entry providing a reference to the user type obtained from the operation that provides the entry.  <br /></td></tr>
<tr class="separator:a013507ec0883722ec0d986ce1f51ee37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bc0d800c2f2ae79c217e999b47f23a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a50bc0d800c2f2ae79c217e999b47f23a">ccc_begin_range</a> (<a class="el" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a> const *r)</td></tr>
<tr class="memdesc:a50bc0d800c2f2ae79c217e999b47f23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the beginning user element stored in a container in the provided range.  <br /></td></tr>
<tr class="separator:a50bc0d800c2f2ae79c217e999b47f23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93883873561b893b366cc8a68e5bcba1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a93883873561b893b366cc8a68e5bcba1">ccc_end_range</a> (<a class="el" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a> const *r)</td></tr>
<tr class="memdesc:a93883873561b893b366cc8a68e5bcba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the end user element stored in a container in the provided range.  <br /></td></tr>
<tr class="separator:a93883873561b893b366cc8a68e5bcba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9efbe3d5a2e7066add960fc334dab30"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ae9efbe3d5a2e7066add960fc334dab30">ccc_rbegin_rrange</a> (<a class="el" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a> const *r)</td></tr>
<tr class="memdesc:ae9efbe3d5a2e7066add960fc334dab30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the reverse beginning user element stored in a container in the provided range.  <br /></td></tr>
<tr class="separator:ae9efbe3d5a2e7066add960fc334dab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dfac06c009f98de694c2d9fecfa36b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a91dfac06c009f98de694c2d9fecfa36b">ccc_rend_rrange</a> (<a class="el" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a> const *r)</td></tr>
<tr class="memdesc:a91dfac06c009f98de694c2d9fecfa36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the reverse end user element stored in a container in the provided range.  <br /></td></tr>
<tr class="separator:a91dfac06c009f98de694c2d9fecfa36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9964d90c381797ba6ce9d76ad1f63a"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a0e9964d90c381797ba6ce9d76ad1f63a">ccc_result_msg</a> (<a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> res)</td></tr>
<tr class="memdesc:a0e9964d90c381797ba6ce9d76ad1f63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a string message with a description of the error returned from a container operation, possible causes, and possible fixes to such error.  <br /></td></tr>
<tr class="separator:a0e9964d90c381797ba6ce9d76ad1f63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The C Container Collection Fundamental Types. </p>
<p>All containers make use of the fundamental types defined here. The purpose of these types is to aid the user in writing correct callback functions, allow clear error handling, and present a consistent interface to users across containers. If allocation permission is given to containers be sure to review the allocation function interface. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a8be6e2d1b150a5b77b2eba5ae85764f2" name="a8be6e2d1b150a5b77b2eba5ae85764f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be6e2d1b150a5b77b2eba5ae85764f2">&#9670;&#160;</a></span>ccc_alloc_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void * ccc_alloc_fn(void *ptr, size_t size, void *aux)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An allocation function at the core of all containers. </p>
<p>An allocation function implements the following behavior, where ptr is pointer to memory, size is number of bytes to allocate, and aux is a reference to any supplementary information required for allocation, deallocation, or reallocation. Aux is passed to a container upon its initialization and the programmer may choose how to best utilize this reference (more on aux later).</p>
<ul>
<li>If NULL is provided with a size of 0, NULL is returned.</li>
<li>If NULL is provided with a non-zero size, new memory is allocated/returned.</li>
<li>If ptr is non-NULL it has been previously allocated by the alloc function.</li>
<li>If ptr is non-NULL with non-zero size, ptr is resized to at least size size. The pointer returned is NULL if resizing fails. Upon success, the pointer returned might not be equal to the pointer provided.</li>
<li>If ptr is non-NULL and size is 0, ptr is freed and NULL is returned.</li>
</ul>
<p>One may be tempted to use realloc to check all of these boxes but realloc is implementation defined on some of these points. So, the aux parameter also discourages users from providing realloc. For example, one solution using the standard library allocator might be implemented as follows (aux is not needed):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *</div>
<div class="line">std_alloc(<span class="keywordtype">void</span> *<span class="keyword">const</span> ptr, <span class="keywordtype">size_t</span> <span class="keyword">const</span> size, <span class="keywordtype">void</span> *)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr &amp;&amp; !size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> malloc(size);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!size)</div>
<div class="line">    {</div>
<div class="line">        free(ptr);</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> realloc(ptr, size);</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, the above example is only useful if the standard library allocator is used. Any allocator that implements the required behavior is sufficient. For example programs that utilize the aux parameter, see the sample programs. Using custom arena allocators or container compositions are cases when aux is needed. </p>

</div>
</div>
<a id="a78ab7f61b1a36b2f31c2289bd6236231" name="a78ab7f61b1a36b2f31c2289bd6236231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ab7f61b1a36b2f31c2289bd6236231">&#9670;&#160;</a></span>ccc_cmp_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a> ccc_cmp_fn(<a class="el" href="structccc__cmp.html">ccc_cmp</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function for comparing two elements in a container. </p>
<p>A three-way comparison return value is expected and the two containers being compared are guaranteed to be non-NULL and pointing to the base of the user type stored in the container. Aux may be NULL if no aux is provided on initialization. </p>

</div>
</div>
<a id="aa2bb6262f220473dc47f4c73711a6ec5" name="aa2bb6262f220473dc47f4c73711a6ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bb6262f220473dc47f4c73711a6ec5">&#9670;&#160;</a></span>ccc_destructor_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void ccc_destructor_fn(<a class="el" href="structccc__user__type.html">ccc_user_type</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function for destroying an element in the container. </p>
<p>A reference to the container type and any aux data provided on initialization is available. The container pointer points to the base of the user type and is not NULL. Aux may be NULL if no aux is provided on initialization. A destructor function is used to act on each element of the container when it is being emptied and destroyed. The function will be called on each type after it removed from the container and before it is freed by the container, if allocation permission is provided to the container. Therefore, if the user has given permission to the container to allocate memory they can assume the container will free each element with the provided allocation function; this function can be used for any other program state to be maintained before the container frees. If the user has not given permission to the container to allocate memory, this a good function in which to free each element, if desired; any program state can be maintained then the element can be freed by the user in this function as the final step. </p>

</div>
</div>
<a id="a70feefd55fafc84e06d2f2a1dfd4f389" name="a70feefd55fafc84e06d2f2a1dfd4f389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70feefd55fafc84e06d2f2a1dfd4f389">&#9670;&#160;</a></span>ccc_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union ccc_entry_ <a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Occupied or Vacant position in a searchable container. </p>
<p>A entry is the basis for more complex container specific Entry Interface for all search-by-key containers. An entry is returned from various operations to provide both a reference to data and any auxiliary status that is important for the user. An entry can be Occupied or Vacant. See individual headers for containers that return this type for its meaning in context. </p>

</div>
</div>
<a id="a0c4ef0c8c3c49edd91423242e6f3a09e" name="a0c4ef0c8c3c49edd91423242e6f3a09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4ef0c8c3c49edd91423242e6f3a09e">&#9670;&#160;</a></span>ccc_hash_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t ccc_hash_fn(<a class="el" href="structccc__user__key.html">ccc_user_key</a> to_hash)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function to hash the key type used in a container. </p>
<p>A reference to any aux data provided on initialization is also available. Return the complete hash value as determined by the user hashing algorithm. </p>

</div>
</div>
<a id="a8097dd574e739c360d2fa2d3e5de70db" name="a8097dd574e739c360d2fa2d3e5de70db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8097dd574e739c360d2fa2d3e5de70db">&#9670;&#160;</a></span>ccc_key_cmp_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a> ccc_key_cmp_fn(<a class="el" href="structccc__key__cmp.html">ccc_key_cmp</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function for three-way comparing two stored keys. </p>
<p>The key is considered the left hand side of the comparison. The function should return CCC_LES if the key is less than the key in key field of user type, CCC_EQL if equal, and CCC_GRT if greater. </p>

</div>
</div>
<a id="ad08b6b1d54268f3f739a22fea39e2c2d" name="ad08b6b1d54268f3f739a22fea39e2c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08b6b1d54268f3f739a22fea39e2c2d">&#9670;&#160;</a></span>ccc_key_eq_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool ccc_key_eq_fn(<a class="el" href="structccc__key__cmp.html">ccc_key_cmp</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function to determining equality between two stored keys. </p>
<p>The function should return true if the key and key field in the user type are equivalent, else false. </p>

</div>
</div>
<a id="a3bf43522fb22e6e499ea327fecf35c55" name="a3bf43522fb22e6e499ea327fecf35c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf43522fb22e6e499ea327fecf35c55">&#9670;&#160;</a></span>ccc_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union ccc_range_ <a class="el" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result of a range query on iterable containers. </p>
<p>A range provides a view all elements that fit the equals range criteria of search-by-key containers. Use the provided range iteration functions in this header to iterate from beginning to end in forward order relative to the containers default ordering. </p>

</div>
</div>
<a id="abbe513ff2fb6678559bcbe22e5faca65" name="abbe513ff2fb6678559bcbe22e5faca65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe513ff2fb6678559bcbe22e5faca65">&#9670;&#160;</a></span>ccc_rrange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union ccc_rrange_ <a class="el" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result of a rrange query on iterable containers. </p>
<p>A rrange provides a view all elements that fit the equals rrange criteria of search-by-key containers. Use the provided range iteration functions in this header to iterate from beginning to end in reverse order relative to the containers default ordering. </p>

</div>
</div>
<a id="a15cf33ea819ae97e1cfdcaf1d55a99b0" name="a15cf33ea819ae97e1cfdcaf1d55a99b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cf33ea819ae97e1cfdcaf1d55a99b0">&#9670;&#160;</a></span>ccc_update_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void ccc_update_fn(<a class="el" href="structccc__user__type.html">ccc_user_type</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function for modifying an element in the container. </p>
<p>A reference to the container type and any aux data provided on initialization is available. The container pointer points to the base of the user type and is not NULL. Aux may be NULL if no aux is provided on initialization. An update function is used when a container Interface exposes functions to modify the key or value used to determine sorted order of elements in the container. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1493dc76581f8c71eb96202fb1671ae1" name="a1493dc76581f8c71eb96202fb1671ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1493dc76581f8c71eb96202fb1671ae1">&#9670;&#160;</a></span>ccc_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A result of actions on containers. </p>
<p>A result indicates the status of the requested operation. Each container provides status messages according to the result type returned from a operation that uses this type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1493dc76581f8c71eb96202fb1671ae1a853ea7c8fbdc75323b7f4367105e9846" name="a1493dc76581f8c71eb96202fb1671ae1a853ea7c8fbdc75323b7f4367105e9846"></a>CCC_OK&#160;</td><td class="fielddoc"><p>The operation has occurred without error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1493dc76581f8c71eb96202fb1671ae1ad1f0a157e4e58b4362d6bbd1527b57f4" name="a1493dc76581f8c71eb96202fb1671ae1ad1f0a157e4e58b4362d6bbd1527b57f4"></a>CCC_NO_ALLOC&#160;</td><td class="fielddoc"><p>Memory is needed but the container lacks allocation permission. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1493dc76581f8c71eb96202fb1671ae1a85205e3308cd6ef0e0263764938d5d73" name="a1493dc76581f8c71eb96202fb1671ae1a85205e3308cd6ef0e0263764938d5d73"></a>CCC_MEM_ERR&#160;</td><td class="fielddoc"><p>The container has allocation permission, but allocation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1493dc76581f8c71eb96202fb1671ae1a87ab32ec108400309c80cdc95a9c1386" name="a1493dc76581f8c71eb96202fb1671ae1a87ab32ec108400309c80cdc95a9c1386"></a>CCC_INPUT_ERR&#160;</td><td class="fielddoc"><p>Bad arguments have been provided to an operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1493dc76581f8c71eb96202fb1671ae1affeda2cbcf7e1e7ce8748ab587bf969b" name="a1493dc76581f8c71eb96202fb1671ae1affeda2cbcf7e1e7ce8748ab587bf969b"></a>CCC_RESULTS_SIZE&#160;</td><td class="fielddoc"><p>Internal helper, never returned to user. Always last result. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9958f3004414182c457c71289303ae57" name="a9958f3004414182c457c71289303ae57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9958f3004414182c457c71289303ae57">&#9670;&#160;</a></span>ccc_threeway_cmp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A three-way comparison for comparison functions. </p>
<p>A C style three way comparison value (e.g. ((a &gt; b) - (a &lt; b))). CCC_LES if left hand side is less than right hand side, CCC_EQL if they are equal, and CCC_GRT if left hand side is greater than right hand side. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8" name="a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8"></a>CCC_LES&#160;</td><td class="fielddoc"><p>The left hand side is less than the right hand side. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9958f3004414182c457c71289303ae57a0ab42c7e0b59a46006cbb959269db825" name="a9958f3004414182c457c71289303ae57a0ab42c7e0b59a46006cbb959269db825"></a>CCC_EQL&#160;</td><td class="fielddoc"><p>The left hand side and right hand side are equal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9958f3004414182c457c71289303ae57a60a4aec1f589eaad4a9e922d90501dce" name="a9958f3004414182c457c71289303ae57a60a4aec1f589eaad4a9e922d90501dce"></a>CCC_GRT&#160;</td><td class="fielddoc"><p>The left hand side is greater than the right hand side. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9958f3004414182c457c71289303ae57a2975ec57f12b7ce11f4b180af8fec7c5" name="a9958f3004414182c457c71289303ae57a2975ec57f12b7ce11f4b180af8fec7c5"></a>CCC_CMP_ERR&#160;</td><td class="fielddoc"><p>Comparison is not possible or other error has occurred. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a50bc0d800c2f2ae79c217e999b47f23a" name="a50bc0d800c2f2ae79c217e999b47f23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bc0d800c2f2ae79c217e999b47f23a">&#9670;&#160;</a></span>ccc_begin_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_begin_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a> const *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the beginning user element stored in a container in the provided range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a pointer to the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored in the container that serves as the beginning of the range.</dd></dl>
<p>Note the beginning of a range may be equivalent to the end or NULL. </p>

</div>
</div>
<a id="a93883873561b893b366cc8a68e5bcba1" name="a93883873561b893b366cc8a68e5bcba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93883873561b893b366cc8a68e5bcba1">&#9670;&#160;</a></span>ccc_end_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_end_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a> const *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the end user element stored in a container in the provided range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a pointer to the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored in the container that serves as the end of the range.</dd></dl>
<p>Note the end of a range may be equivalent to the beginning or NULL. Functions that obtain ranges treat the end as an exclusive bound and therefore it is undefined to access this element. </p>

</div>
</div>
<a id="a9fd223cf4a594565a536ae518174a9b5" name="a9fd223cf4a594565a536ae518174a9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd223cf4a594565a536ae518174a9b5">&#9670;&#160;</a></span>ccc_entry_input_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_entry_input_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an input error has occurred for a function that generates an entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the pointer to the entry obtained from a container function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an input error occurred usually meaning an invalid argument such as a NULL pointer was provided to a function. </dd></dl>

</div>
</div>
<a id="a7a10c6e74f36faa343419f01df2da690" name="a7a10c6e74f36faa343419f01df2da690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a10c6e74f36faa343419f01df2da690">&#9670;&#160;</a></span>ccc_entry_insert_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_entry_insert_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an insertion error has occurred when a function that attempts to insert a value in a container is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the pointer to the entry obtained from a container insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an insertion error occurred usually meaning a insertion should have occurred but the container did not have permission to allocate new memory or allocation failed. </dd></dl>

</div>
</div>
<a id="ac0847e7b4ff4901c016fc1e06142364f" name="ac0847e7b4ff4901c016fc1e06142364f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0847e7b4ff4901c016fc1e06142364f">&#9670;&#160;</a></span>ccc_entry_occupied()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_entry_occupied </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an entry is Occupied in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the pointer to the entry obtained from a container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if Occupied false if Vacant. </dd></dl>

</div>
</div>
<a id="a013507ec0883722ec0d986ce1f51ee37" name="a013507ec0883722ec0d986ce1f51ee37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013507ec0883722ec0d986ce1f51ee37">&#9670;&#160;</a></span>ccc_entry_unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_entry_unwrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwraps the provided entry providing a reference to the user type obtained from the operation that provides the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the pointer to the entry obtained from an operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored in the Occupied entry or NULL if the entry is Vacant or otherwise cannot be viewed.</dd></dl>
<p>The expected return value from unwrapping a value will change depending on the container from which the entry is obtained. Read the documentation for the container being used to understand what to expect from this function once an entry is obtained. </p>

</div>
</div>
<a id="ae9efbe3d5a2e7066add960fc334dab30" name="ae9efbe3d5a2e7066add960fc334dab30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9efbe3d5a2e7066add960fc334dab30">&#9670;&#160;</a></span>ccc_rbegin_rrange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_rbegin_rrange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a> const *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the reverse beginning user element stored in a container in the provided range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a pointer to the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored in the container that serves as the reverse beginning of the range.</dd></dl>
<p>Note the reverse beginning of a range may be equivalent to the reverse end or NULL. </p>

</div>
</div>
<a id="a91dfac06c009f98de694c2d9fecfa36b" name="a91dfac06c009f98de694c2d9fecfa36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dfac06c009f98de694c2d9fecfa36b">&#9670;&#160;</a></span>ccc_rend_rrange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_rend_rrange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a> const *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the reverse end user element stored in a container in the provided range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a pointer to the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored in the container that serves as the reverse end of the range.</dd></dl>
<p>Note the reverse end of a range may be equivalent to the reverse beginning or NULL. Functions that obtain ranges treat the reverse end as an exclusive bound and therefore it is undefined to access this element. </p>

</div>
</div>
<a id="a0e9964d90c381797ba6ce9d76ad1f63a" name="a0e9964d90c381797ba6ce9d76ad1f63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9964d90c381797ba6ce9d76ad1f63a">&#9670;&#160;</a></span>ccc_result_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const  * ccc_result_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a string message with a description of the error returned from a container operation, possible causes, and possible fixes to such error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>the result obtained from a container operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string message of the result. A CCC_OK result is an empty string, the falsey NULL terminator. All other results have a string message.</dd></dl>
<p>These messages can be used for logging or to help with debugging by providing more information for why such a result might be obtained from a container. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="types_8h.html">types.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
