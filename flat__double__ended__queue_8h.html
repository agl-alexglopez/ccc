<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/flat_double_ended_queue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('flat__double__ended__queue_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">flat_double_ended_queue.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Flat Double Ended Queue Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;impl/impl_flat_double_ended_queue.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for flat_double_ended_queue.h:</div>
<div class="dyncontent">
<div class="center"><img src="flat__double__ended__queue_8h__incl.png" border="0" usemap="#accc_2flat__double__ended__queue_8h" alt=""/></div>
<map name="accc_2flat__double__ended__queue_8h" id="accc_2flat__double__ended__queue_8h">
<area shape="rect" title="The Flat Double Ended Queue Interface." alt="" coords="91,5,257,45"/>
<area shape="rect" href="impl__flat__double__ended__queue_8h_source.html" title=" " alt="" coords="34,93,197,133"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="142,328,225,353"/>
<area shape="rect" href="buffer_8h.html" title="The Buffer Interface." alt="" coords="74,181,157,207"/>
<area shape="rect" href="impl__buffer_8h_source.html" title=" " alt="" coords="5,255,145,280"/>
<area shape="rect" href="impl__types_8h_source.html" title=" " alt="" coords="114,401,253,427"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="flat__double__ended__queue_8h__dep__incl.png" border="0" usemap="#accc_2flat__double__ended__queue_8hdep" alt=""/></div>
<map name="accc_2flat__double__ended__queue_8hdep" id="accc_2flat__double__ended__queue_8hdep">
<area shape="rect" title="The Flat Double Ended Queue Interface." alt="" coords="5,5,172,45"/>
<area shape="rect" href="impl__traits_8h_source.html" title=" " alt="" coords="7,93,170,119"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="42,167,135,192"/>
</map>
</div>
</div>
<p><a href="flat__double__ended__queue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Initialize and create containers with memory, callbacks, and permissions. </p>
</td></tr>
<tr class="memitem:a5f6c51ae30c8f0cae6e1b05466008784"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a5f6c51ae30c8f0cae6e1b05466008784">ccc_fdeq_init</a>(mem_ptr,  alloc_fn,  aux_data,  capacity,  optional_size...)&#160;&#160;&#160;    ccc_impl_fdeq_init(mem_ptr, alloc_fn, aux_data, capacity, optional_size)</td></tr>
<tr class="memdesc:a5f6c51ae30c8f0cae6e1b05466008784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the fdeq with memory and allocation permission.  <br /></td></tr>
<tr class="separator:a5f6c51ae30c8f0cae6e1b05466008784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7164375cce93f29179ed077fb7ede7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a7164375cce93f29179ed077fb7ede7db">ccc_fdeq_copy</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *dst, <a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *src, <a class="el" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a> *fn)</td></tr>
<tr class="memdesc:a7164375cce93f29179ed077fb7ede7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the fdeq from src to newly initialized dst.  <br /></td></tr>
<tr class="separator:a7164375cce93f29179ed077fb7ede7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Insert and Remove Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Add or remove elements from the FDEQ. </p>
</td></tr>
<tr class="memitem:a9ee4b94addf503252a94ee32a438b5e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a9ee4b94addf503252a94ee32a438b5e0">ccc_fdeq_emplace_back</a>(fdeq_ptr,  value...)&#160;&#160;&#160;    ccc_impl_fdeq_emplace_back(fdeq_ptr, value)</td></tr>
<tr class="memdesc:a9ee4b94addf503252a94ee32a438b5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an element directly to the back slot of the fdeq. O(1) if no allocation permission amortized O(1) if allocation permission is given and a resize is required.  <br /></td></tr>
<tr class="separator:a9ee4b94addf503252a94ee32a438b5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82291c88d3a1153d9370d57334bd1a1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a82291c88d3a1153d9370d57334bd1a1e">ccc_fdeq_emplace_front</a>(fdeq_ptr,  value...)&#160;&#160;&#160;    ccc_impl_fdeq_emplace_front(fdeq_ptr, value)</td></tr>
<tr class="memdesc:a82291c88d3a1153d9370d57334bd1a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an element directly to the front slot of the fdeq. O(1) if no allocation permission amortized O(1) if allocation permission is given and a resize is required.  <br /></td></tr>
<tr class="separator:a82291c88d3a1153d9370d57334bd1a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa352727365879daa6510133a768cc628"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#aa352727365879daa6510133a768cc628">ccc_fdeq_push_back</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq, void const *elem)</td></tr>
<tr class="memdesc:aa352727365879daa6510133a768cc628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the user type to the back of the fdeq. O(1) if no allocation permission amortized O(1) if allocation permission is given and a resize is required.  <br /></td></tr>
<tr class="separator:aa352727365879daa6510133a768cc628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8c8988041f24a63d46defee8db29bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a2d8c8988041f24a63d46defee8db29bd">ccc_fdeq_push_back_range</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq, size_t n, void const *elems)</td></tr>
<tr class="memdesc:a2d8c8988041f24a63d46defee8db29bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the range of user types to the back of the fdeq. O(N).  <br /></td></tr>
<tr class="separator:a2d8c8988041f24a63d46defee8db29bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8aa8edc1a18d945b8bdd664709e7a2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a6e8aa8edc1a18d945b8bdd664709e7a2">ccc_fdeq_push_front</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq, void const *elem)</td></tr>
<tr class="memdesc:a6e8aa8edc1a18d945b8bdd664709e7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the user type to the front of the fdeq. O(1) if no allocation permission amortized O(1) if allocation permission is given and a resize is required.  <br /></td></tr>
<tr class="separator:a6e8aa8edc1a18d945b8bdd664709e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d271eca7745f9da989409b337afb5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a5d271eca7745f9da989409b337afb5b7">ccc_fdeq_push_front_range</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq, size_t n, void const *elems)</td></tr>
<tr class="memdesc:a5d271eca7745f9da989409b337afb5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the range of user types to the front of the fdeq. O(N).  <br /></td></tr>
<tr class="separator:a5d271eca7745f9da989409b337afb5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3637efae168143b1068575dbf07cec8f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a3637efae168143b1068575dbf07cec8f">ccc_fdeq_insert_range</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq, void *pos, size_t n, void const *elems)</td></tr>
<tr class="memdesc:a3637efae168143b1068575dbf07cec8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the range of user types before pos of the fdeq. O(N).  <br /></td></tr>
<tr class="separator:a3637efae168143b1068575dbf07cec8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1122093b9e142bbc81f56d09e2d5331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#ae1122093b9e142bbc81f56d09e2d5331">ccc_fdeq_pop_front</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq)</td></tr>
<tr class="memdesc:ae1122093b9e142bbc81f56d09e2d5331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an element from the front of the fdeq. O(1).  <br /></td></tr>
<tr class="separator:ae1122093b9e142bbc81f56d09e2d5331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e38bd6dacaf6204fa8de34c7732789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a60e38bd6dacaf6204fa8de34c7732789">ccc_fdeq_pop_back</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq)</td></tr>
<tr class="memdesc:a60e38bd6dacaf6204fa8de34c7732789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an element from the back of the fdeq. O(1).  <br /></td></tr>
<tr class="separator:a60e38bd6dacaf6204fa8de34c7732789"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Types available in the container interface. </p>
</td></tr>
<tr class="memitem:a0b47511ed59d60a9e66bdb2fee438eb0"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_fdeq_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a></td></tr>
<tr class="memdesc:a0b47511ed59d60a9e66bdb2fee438eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contiguous buffer for O(1) push and pop from front and back.  <br /></td></tr>
<tr class="separator:a0b47511ed59d60a9e66bdb2fee438eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Destroy the container. </p>
</td></tr>
<tr class="memitem:a1b352898bcc66874d9808fd58e4dab5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a1b352898bcc66874d9808fd58e4dab5b">ccc_fdeq_clear</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq, <a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *destructor)</td></tr>
<tr class="memdesc:a1b352898bcc66874d9808fd58e4dab5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size of fdeq to 0 and call destructor on each element if needed. O(1) if no destructor is provided, else O(N).  <br /></td></tr>
<tr class="separator:a1b352898bcc66874d9808fd58e4dab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661112e9f407ddf187a70ecc2ee2ace9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a661112e9f407ddf187a70ecc2ee2ace9">ccc_fdeq_clear_and_free</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *fdeq, <a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *destructor)</td></tr>
<tr class="memdesc:a661112e9f407ddf187a70ecc2ee2ace9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size of fdeq to 0 and call destructor on each element if needed. Free the underlying buffer setting the capacity to 0. O(1) if no destructor is provided, else O(N).  <br /></td></tr>
<tr class="separator:a661112e9f407ddf187a70ecc2ee2ace9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Interact with the state of the FDEQ. </p>
</td></tr>
<tr class="memitem:ac78b94bd197607dce9b20ef4ed0894a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#ac78b94bd197607dce9b20ef4ed0894a9">ccc_fdeq_begin</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:ac78b94bd197607dce9b20ef4ed0894a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the front element of the fdeq. O(1).  <br /></td></tr>
<tr class="separator:ac78b94bd197607dce9b20ef4ed0894a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d7a66b34eae3abf0557ed5656c4091"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a01d7a66b34eae3abf0557ed5656c4091">ccc_fdeq_rbegin</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:a01d7a66b34eae3abf0557ed5656c4091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the back element of the fdeq. O(1).  <br /></td></tr>
<tr class="separator:a01d7a66b34eae3abf0557ed5656c4091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e152982e0102e279af6893a77d975de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a1e152982e0102e279af6893a77d975de">ccc_fdeq_next</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq, void const *iter_ptr)</td></tr>
<tr class="memdesc:a1e152982e0102e279af6893a77d975de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next element in the fdeq moving front to back. O(1).  <br /></td></tr>
<tr class="separator:a1e152982e0102e279af6893a77d975de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62103b1ef7d05fd9daa66c956c352bf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#af62103b1ef7d05fd9daa66c956c352bf">ccc_fdeq_rnext</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq, void const *iter_ptr)</td></tr>
<tr class="memdesc:af62103b1ef7d05fd9daa66c956c352bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next element in the fdeq moving back to front. O(1).  <br /></td></tr>
<tr class="separator:af62103b1ef7d05fd9daa66c956c352bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9264ced538427697983cdaf42ff8ff27"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a9264ced538427697983cdaf42ff8ff27">ccc_fdeq_end</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:a9264ced538427697983cdaf42ff8ff27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the end element. It may not be accessed. O(1).  <br /></td></tr>
<tr class="separator:a9264ced538427697983cdaf42ff8ff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d5c7871381b4bd11eae774ad999962"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a91d5c7871381b4bd11eae774ad999962">ccc_fdeq_rend</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:a91d5c7871381b4bd11eae774ad999962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the start element. It may not be accessed. O(1).  <br /></td></tr>
<tr class="separator:a91d5c7871381b4bd11eae774ad999962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4caa4193f1547f8cdf5289935aa2da6a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a4caa4193f1547f8cdf5289935aa2da6a">ccc_fdeq_at</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq, size_t i)</td></tr>
<tr class="memdesc:a4caa4193f1547f8cdf5289935aa2da6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the element at index position i. O(1).  <br /></td></tr>
<tr class="separator:a4caa4193f1547f8cdf5289935aa2da6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d9f08549c2ce4edf9d575caccb3fb4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a88d9f08549c2ce4edf9d575caccb3fb4">ccc_fdeq_front</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:a88d9f08549c2ce4edf9d575caccb3fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the front of the fdeq. O(1).  <br /></td></tr>
<tr class="separator:a88d9f08549c2ce4edf9d575caccb3fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd07edbd36d2c84bbb633e910a4d59a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a9cd07edbd36d2c84bbb633e910a4d59a">ccc_fdeq_back</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:a9cd07edbd36d2c84bbb633e910a4d59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the back of the fdeq. O(1).  <br /></td></tr>
<tr class="separator:a9cd07edbd36d2c84bbb633e910a4d59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891865ef2a715297974c2def5671d5bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a80a7915df3bc36e01a3a0775eebc0938">ccc_tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a891865ef2a715297974c2def5671d5bb">ccc_fdeq_is_empty</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:a891865ef2a715297974c2def5671d5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the size of the fdeq is 0. O(1).  <br /></td></tr>
<tr class="separator:a891865ef2a715297974c2def5671d5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7f79aa1f843a86074c16904a554aa3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a0b7f79aa1f843a86074c16904a554aa3">ccc_fdeq_size</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:a0b7f79aa1f843a86074c16904a554aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the fdeq. O(1).  <br /></td></tr>
<tr class="separator:a0b7f79aa1f843a86074c16904a554aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3edec85610bbe6b39ea2069ada7466"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#acf3edec85610bbe6b39ea2069ada7466">ccc_fdeq_capacity</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:acf3edec85610bbe6b39ea2069ada7466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capacity of the fdeq. O(1).  <br /></td></tr>
<tr class="separator:acf3edec85610bbe6b39ea2069ada7466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49f9096ecd1127d3f8501613ab45602"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#ab49f9096ecd1127d3f8501613ab45602">ccc_fdeq_data</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:ab49f9096ecd1127d3f8501613ab45602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the base of backing array. O(1).  <br /></td></tr>
<tr class="separator:ab49f9096ecd1127d3f8501613ab45602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996af112cdbfa57d1511a82489b0f074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a80a7915df3bc36e01a3a0775eebc0938">ccc_tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__double__ended__queue_8h.html#a996af112cdbfa57d1511a82489b0f074">ccc_fdeq_validate</a> (<a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *fdeq)</td></tr>
<tr class="memdesc:a996af112cdbfa57d1511a82489b0f074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the internal invariants of the fdeq.  <br /></td></tr>
<tr class="separator:a996af112cdbfa57d1511a82489b0f074"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Flat Double Ended Queue Interface. </p>
<p>An FDEQ offers contiguous storage and random access, push, and pop in constant time. The contiguous nature of the buffer makes it well-suited to dynamic or fixed size contexts where a double ended queue is needed.</p>
<p>If the container is initialized with allocation permission it will resize when needed but support constant time push and pop to the front and back when resizing is not required, resulting in amortized O(1) operations.</p>
<p>If the FDEQ is initialized without allocation permission its behavior is equivalent to a Ring Buffer. This is somewhat unique in that it does not fail to insert elements when size is equal to capacity. This means that push front, push back, pop front, and pop back are O(1) operations. However, if any push exceeds capacity an element where the push should occur is overwritten.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_DOUBLE_ENDED_QUEUE_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>ccc_</code> prefix. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9ee4b94addf503252a94ee32a438b5e0" name="a9ee4b94addf503252a94ee32a438b5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee4b94addf503252a94ee32a438b5e0">&#9670;&#160;</a></span>ccc_fdeq_emplace_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fdeq_emplace_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fdeq_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_fdeq_emplace_back(fdeq_ptr, value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an element directly to the back slot of the fdeq. O(1) if no allocation permission amortized O(1) if allocation permission is given and a resize is required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq_ptr</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>for integral types, the direct value. For structs and unions use compound literal syntax. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the inserted element. If allocation is permitted and a resizing is required to insert the element but fails, NULL is returned. </dd></dl>

</div>
</div>
<a id="a82291c88d3a1153d9370d57334bd1a1e" name="a82291c88d3a1153d9370d57334bd1a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82291c88d3a1153d9370d57334bd1a1e">&#9670;&#160;</a></span>ccc_fdeq_emplace_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fdeq_emplace_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fdeq_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_fdeq_emplace_front(fdeq_ptr, value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an element directly to the front slot of the fdeq. O(1) if no allocation permission amortized O(1) if allocation permission is given and a resize is required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq_ptr</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>for integral types, the direct value. For structs and unions use compound literal syntax. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the inserted element. If allocation is permitted and a resizing is required to insert the element but fails, NULL is returned. </dd></dl>

</div>
</div>
<a id="a5f6c51ae30c8f0cae6e1b05466008784" name="a5f6c51ae30c8f0cae6e1b05466008784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6c51ae30c8f0cae6e1b05466008784">&#9670;&#160;</a></span>ccc_fdeq_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_fdeq_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mem_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alloc_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">aux_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_size...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_fdeq_init(mem_ptr, alloc_fn, aux_data, capacity, optional_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the fdeq with memory and allocation permission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_ptr</td><td>a pointer to existing memory or ((T *)NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_fn</td><td>the allocator function, if allocation is allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux_data</td><td>any auxiliary data needed for element destruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the number of contiguous elements at mem_ptr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_size</td><td>an optional initial size between 1 and capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fdeq on the right hand side of an equality operator at runtime or compiletime (e.g. ccc_flat_double_ended_queue q = <a class="el" href="flat__double__ended__queue_8h.html#a5f6c51ae30c8f0cae6e1b05466008784" title="Initialize the fdeq with memory and allocation permission.">ccc_fdeq_init(...)</a>;) </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0b47511ed59d60a9e66bdb2fee438eb0" name="a0b47511ed59d60a9e66bdb2fee438eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b47511ed59d60a9e66bdb2fee438eb0">&#9670;&#160;</a></span>ccc_flat_double_ended_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_fdeq_ <a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A contiguous buffer for O(1) push and pop from front and back. </p>
<dl class="section warning"><dt>Warning</dt><dd>it is undefined behavior to use an uninitialized flat double ended queue.</dd></dl>
<p>A flat double ended queue can be initialized on the stack, heap, or data segment at compile time or runtime. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4caa4193f1547f8cdf5289935aa2da6a" name="a4caa4193f1547f8cdf5289935aa2da6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4caa4193f1547f8cdf5289935aa2da6a">&#9670;&#160;</a></span>ccc_fdeq_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the element at index position i. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the 0 based index in the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at i if i &lt; capacity.</dd></dl>
<p>Note that the front of the fdeq is considered index 0, so the user need not worry about where the front is for indexing purposes. </p>

</div>
</div>
<a id="a9cd07edbd36d2c84bbb633e910a4d59a" name="a9cd07edbd36d2c84bbb633e910a4d59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd07edbd36d2c84bbb633e910a4d59a">&#9670;&#160;</a></span>ccc_fdeq_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the back of the fdeq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the back element or NULL if fdeq is NULL or the fdeq is empty. </dd></dl>

</div>
</div>
<a id="ac78b94bd197607dce9b20ef4ed0894a9" name="ac78b94bd197607dce9b20ef4ed0894a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78b94bd197607dce9b20ef4ed0894a9">&#9670;&#160;</a></span>ccc_fdeq_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the front element of the fdeq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type at the start of the fdeq. NULL if empty. </dd></dl>

</div>
</div>
<a id="acf3edec85610bbe6b39ea2069ada7466" name="acf3edec85610bbe6b39ea2069ada7466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3edec85610bbe6b39ea2069ada7466">&#9670;&#160;</a></span>ccc_fdeq_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_fdeq_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the capacity of the fdeq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity of the fdeq or 0 if fdeq is NULL. </dd></dl>

</div>
</div>
<a id="a1b352898bcc66874d9808fd58e4dab5b" name="a1b352898bcc66874d9808fd58e4dab5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b352898bcc66874d9808fd58e4dab5b">&#9670;&#160;</a></span>ccc_fdeq_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_fdeq_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>destructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size of fdeq to 0 and call destructor on each element if needed. O(1) if no destructor is provided, else O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>the destructor if needed or NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if destructor is non-NULL it will be called on each element in the fdeq. However, the underlying buffer for the fdeq is not freed. If the destructor is NULL, setting the size to 0 is O(1). </p>

</div>
</div>
<a id="a661112e9f407ddf187a70ecc2ee2ace9" name="a661112e9f407ddf187a70ecc2ee2ace9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661112e9f407ddf187a70ecc2ee2ace9">&#9670;&#160;</a></span>ccc_fdeq_clear_and_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_fdeq_clear_and_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>destructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size of fdeq to 0 and call destructor on each element if needed. Free the underlying buffer setting the capacity to 0. O(1) if no destructor is provided, else O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>the destructor if needed or NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if destructor is non-NULL it will be called on each element in the fdeq. After all elements are processed the buffer is freed and capacity is 0. If destructor is NULL the buffer is freed directly and capacity is 0. </p>

</div>
</div>
<a id="a7164375cce93f29179ed077fb7ede7db" name="a7164375cce93f29179ed077fb7ede7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7164375cce93f29179ed077fb7ede7db">&#9670;&#160;</a></span>ccc_fdeq_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_fdeq_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the fdeq from src to newly initialized dst. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>the destination that will copy the source fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source of the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the allocation function in case resizing of dst is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the copy operation. If the destination capacity is less than the source capacity and no allocation function is provided an input error is returned. If resizing is required and resizing of dst fails a memory error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>dst must have capacity greater than or equal to src. If dst capacity is less than src, an allocation function must be provided with the fn argument.</dd></dl>
<p>Note that there are two ways to copy data from source to destination: provide sufficient memory and pass NULL as fn, or allow the copy function to take care of allocation for the copy.</p>
<p>Manual memory management with no allocation function provided.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_DOUBLE_ENDED_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_double_ended_queue src = fdeq_init((<span class="keywordtype">int</span>[10]){}, NULL, NULL, 10);</div>
<div class="line"><span class="keywordtype">int</span> *new_mem = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * fdeq_capacity(&amp;src));</div>
<div class="line">flat_double_ended_queue dst</div>
<div class="line">    = fdeq_init(new_mem, NULL, NULL, fdeq_capacity(&amp;src));</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> res = fdeq_copy(&amp;dst, &amp;src, NULL);</div>
<div class="ttc" id="atypes_8h_html_a1493dc76581f8c71eb96202fb1671ae1"><div class="ttname"><a href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a></div><div class="ttdeci">ccc_result</div><div class="ttdoc">A result of actions on containers.</div><div class="ttdef"><b>Definition:</b> types.h:125</div></div>
</div><!-- fragment --><p>The above requires dst capacity be greater than or equal to src capacity. Here is memory management handed over to the copy function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_DOUBLE_ENDED_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_double_ended_queue src = fdeq_init((<span class="keywordtype">int</span> *)NULL, std_alloc, NULL, 0);</div>
<div class="line">(void)<a class="code hl_function" href="flat__double__ended__queue_8h.html#a2d8c8988041f24a63d46defee8db29bd">ccc_fdeq_push_back_range</a>(&amp;src, 5, (<span class="keywordtype">int</span>[5]){0,1,2,3,4});</div>
<div class="line">flat_double_ended_queue dst = fdeq_init((<span class="keywordtype">int</span> *)NULL, std_alloc, NULL, 0);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> res = fdeq_copy(&amp;dst, &amp;src, std_alloc);</div>
<div class="ttc" id="aflat__double__ended__queue_8h_html_a2d8c8988041f24a63d46defee8db29bd"><div class="ttname"><a href="flat__double__ended__queue_8h.html#a2d8c8988041f24a63d46defee8db29bd">ccc_fdeq_push_back_range</a></div><div class="ttdeci">ccc_result ccc_fdeq_push_back_range(ccc_flat_double_ended_queue *fdeq, size_t n, void const *elems)</div><div class="ttdoc">Push the range of user types to the back of the fdeq. O(N).</div></div>
</div><!-- fragment --><p>The above allows dst to have a capacity less than that of the src as long as copy has been provided an allocation function to resize dst. Note that this would still work if copying to a destination that the user wants as a fixed size fdeq (ring buffer).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_DOUBLE_ENDED_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line">flat_double_ended_queue src = fdeq_init((<span class="keywordtype">int</span> *)NULL, std_alloc, NULL, 0);</div>
<div class="line">(void)<a class="code hl_function" href="flat__double__ended__queue_8h.html#a2d8c8988041f24a63d46defee8db29bd">ccc_fdeq_push_back_range</a>(&amp;src, 5, (<span class="keywordtype">int</span>[5]){0,1,2,3,4});</div>
<div class="line">flat_double_ended_queue dst = fdeq_init((<span class="keywordtype">int</span> *)NULL, NULL, NULL, 0);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> res = fdeq_copy(&amp;dst, &amp;src, std_alloc);</div>
</div><!-- fragment --><p>The above sets up dst as a ring buffer while src is a dynamic fdeq. Because an allocation function is provided, the dst is resized once for the copy and retains its fixed size after the copy is complete. This would require the user to manually free the underlying buffer at dst eventually if this method is used. Usually it is better to allocate the memory explicitly before the copy if copying between ring buffers.</p>
<p>These options allow users to stay consistent across containers with their memory management strategies. </p>

</div>
</div>
<a id="ab49f9096ecd1127d3f8501613ab45602" name="ab49f9096ecd1127d3f8501613ab45602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49f9096ecd1127d3f8501613ab45602">&#9670;&#160;</a></span>ccc_fdeq_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the base of backing array. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the base of the backing array. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the reference is to the base of the backing array at index 0 with no consideration to where the front index of the fdeq may be. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it is the users responsibility to ensure that access to any data is within the capacity of the backing buffer.</dd></dl>
<p>This method is exposed for serialization or writing purposes but the base of the array may not point to valid data in terms of organization of the fdeq. </p>

</div>
</div>
<a id="a9264ced538427697983cdaf42ff8ff27" name="a9264ced538427697983cdaf42ff8ff27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9264ced538427697983cdaf42ff8ff27">&#9670;&#160;</a></span>ccc_fdeq_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the end element. It may not be accessed. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the end sentinel element that may not be accessed. </dd></dl>

</div>
</div>
<a id="a88d9f08549c2ce4edf9d575caccb3fb4" name="a88d9f08549c2ce4edf9d575caccb3fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d9f08549c2ce4edf9d575caccb3fb4">&#9670;&#160;</a></span>ccc_fdeq_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the front of the fdeq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the front element or NULL if fdeq is NULL or the fdeq is empty. </dd></dl>

</div>
</div>
<a id="a3637efae168143b1068575dbf07cec8f" name="a3637efae168143b1068575dbf07cec8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3637efae168143b1068575dbf07cec8f">&#9670;&#160;</a></span>ccc_fdeq_insert_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_insert_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push the range of user types before pos of the fdeq. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>the position in the fdeq before which to push the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of user types in the elems range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elems</td><td>a pointer to the array of user types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the inserted range or NULL if a resize was required and could not complete.</dd></dl>
<p>Note that if no allocation is permitted the fdeq behaves as a ring buffer. Therefore, pushing a range that will exceed capacity will overwrite elements at the start of the fdeq.</p>
<p>Pushing a range of elements prioritizes the range and allows the range to overwrite elements instead of pushing those elements over the start of the range. For example, push a range {3,4,5} over a fdeq with capacity 5 before pos with value 6.</p>
<div class="fragment"><div class="line"> front pos        front</div>
<div class="line">┌─┬┴┬─┬┴┬─┐    ┌─┬─┬┴┬─┬─┐</div>
<div class="line">│ │1│2│6│ │ -&gt; │5│6│2│3│4│</div>
<div class="line">└─┴─┴─┴─┴─┘    └─┴─┴─┴─┴─┘</div>
</div><!-- fragment --><p>Notice that 1 and 2 were NOT moved to overwrite the start of the range, the values 3 and 4. The only way the start of a range will be overwritten is if the range itself is too large for the capacity. For example, push a range {0,0,3,3,4,4,5,5} over the same fdeq.</p>
<div class="fragment"><div class="line"> front pos    front</div>
<div class="line">┌─┬┴┬─┬┴┬─┐    ┌┴┬─┬─┬─┬─┐</div>
<div class="line">│ │1│2│6│ │ -&gt; │3│4│4│5│5│</div>
<div class="line">└─┴─┴─┴─┴─┘    └─┴─┴─┴─┴─┘</div>
</div><!-- fragment --><p>Notice that the start of the range, {0,0,3,...}, is overwritten. </p>

</div>
</div>
<a id="a891865ef2a715297974c2def5671d5bb" name="a891865ef2a715297974c2def5671d5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891865ef2a715297974c2def5671d5bb">&#9670;&#160;</a></span>ccc_fdeq_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a80a7915df3bc36e01a3a0775eebc0938">ccc_tribool</a> ccc_fdeq_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the size of the fdeq is 0. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size is 0 or false. Error if fdeq is NULL. </dd></dl>

</div>
</div>
<a id="a1e152982e0102e279af6893a77d975de" name="a1e152982e0102e279af6893a77d975de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e152982e0102e279af6893a77d975de">&#9670;&#160;</a></span>ccc_fdeq_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>iter_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next element in the fdeq moving front to back. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_ptr</td><td>the current element in the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the element following iter_ptr or NULL if no elements follow. </dd></dl>

</div>
</div>
<a id="a60e38bd6dacaf6204fa8de34c7732789" name="a60e38bd6dacaf6204fa8de34c7732789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e38bd6dacaf6204fa8de34c7732789">&#9670;&#160;</a></span>ccc_fdeq_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_fdeq_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an element from the back of the fdeq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the pop was successful. If fdeq is NULL or the fdeq is empty an input error is returned. </dd></dl>

</div>
</div>
<a id="ae1122093b9e142bbc81f56d09e2d5331" name="ae1122093b9e142bbc81f56d09e2d5331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1122093b9e142bbc81f56d09e2d5331">&#9670;&#160;</a></span>ccc_fdeq_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_fdeq_pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an element from the front of the fdeq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the pop was successful. If fdeq is NULL or the fdeq is empty an input error is returned. </dd></dl>

</div>
</div>
<a id="aa352727365879daa6510133a768cc628" name="aa352727365879daa6510133a768cc628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa352727365879daa6510133a768cc628">&#9670;&#160;</a></span>ccc_fdeq_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push the user type to the back of the fdeq. O(1) if no allocation permission amortized O(1) if allocation permission is given and a resize is required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the user type to insert into the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the inserted element. </dd></dl>

</div>
</div>
<a id="a2d8c8988041f24a63d46defee8db29bd" name="a2d8c8988041f24a63d46defee8db29bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8c8988041f24a63d46defee8db29bd">&#9670;&#160;</a></span>ccc_fdeq_push_back_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_fdeq_push_back_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push the range of user types to the back of the fdeq. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of user types in the elems range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elems</td><td>a pointer to the array of user types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if insertion was successful. If allocation is permitted and a resize is needed but fails an error is returned. If bad input is provided an input error is returned.</dd></dl>
<p>Note that if no allocation is permitted the fdeq behaves as a ring buffer. Therefore, pushing a range that will exceed capacity will overwrite elements at the beginning of the fdeq. </p>

</div>
</div>
<a id="a6e8aa8edc1a18d945b8bdd664709e7a2" name="a6e8aa8edc1a18d945b8bdd664709e7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8aa8edc1a18d945b8bdd664709e7a2">&#9670;&#160;</a></span>ccc_fdeq_push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push the user type to the front of the fdeq. O(1) if no allocation permission amortized O(1) if allocation permission is given and a resize is required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the user type to insert into the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the inserted element. </dd></dl>

</div>
</div>
<a id="a5d271eca7745f9da989409b337afb5b7" name="a5d271eca7745f9da989409b337afb5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d271eca7745f9da989409b337afb5b7">&#9670;&#160;</a></span>ccc_fdeq_push_front_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_fdeq_push_front_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push the range of user types to the front of the fdeq. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of user types in the elems range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elems</td><td>a pointer to the array of user types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if insertion was successful. If allocation is permitted and a resize is needed but fails an error is returned. If bad input is provided an input error is returned.</dd></dl>
<p>Note that if no allocation is permitted the fdeq behaves as a ring buffer. Therefore, pushing a range that will exceed capacity will overwrite elements at the back of the fdeq. </p>

</div>
</div>
<a id="a01d7a66b34eae3abf0557ed5656c4091" name="a01d7a66b34eae3abf0557ed5656c4091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d7a66b34eae3abf0557ed5656c4091">&#9670;&#160;</a></span>ccc_fdeq_rbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the back element of the fdeq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type at the back of the fdeq. NULL if empty. </dd></dl>

</div>
</div>
<a id="a91d5c7871381b4bd11eae774ad999962" name="a91d5c7871381b4bd11eae774ad999962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d5c7871381b4bd11eae774ad999962">&#9670;&#160;</a></span>ccc_fdeq_rend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the start element. It may not be accessed. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start sentinel element that may not be accessed. </dd></dl>

</div>
</div>
<a id="af62103b1ef7d05fd9daa66c956c352bf" name="af62103b1ef7d05fd9daa66c956c352bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62103b1ef7d05fd9daa66c956c352bf">&#9670;&#160;</a></span>ccc_fdeq_rnext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_fdeq_rnext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>iter_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next element in the fdeq moving back to front. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_ptr</td><td>the current element in the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the element preceding iter_ptr or NULL if no elements follow. </dd></dl>

</div>
</div>
<a id="a0b7f79aa1f843a86074c16904a554aa3" name="a0b7f79aa1f843a86074c16904a554aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7f79aa1f843a86074c16904a554aa3">&#9670;&#160;</a></span>ccc_fdeq_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_fdeq_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the fdeq. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the fdeq or 0 if fdeq is NULL. </dd></dl>

</div>
</div>
<a id="a996af112cdbfa57d1511a82489b0f074" name="a996af112cdbfa57d1511a82489b0f074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996af112cdbfa57d1511a82489b0f074">&#9670;&#160;</a></span>ccc_fdeq_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a80a7915df3bc36e01a3a0775eebc0938">ccc_tribool</a> ccc_fdeq_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flat__double__ended__queue_8h.html#a0b47511ed59d60a9e66bdb2fee438eb0">ccc_flat_double_ended_queue</a> const *&#160;</td>
          <td class="paramname"><em>fdeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the internal invariants of the fdeq. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdeq</td><td>a pointer to the fdeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the internal invariants of the fdeq are held, else false. Error if fdeq is NULL. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="flat__double__ended__queue_8h.html">flat_double_ended_queue.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
