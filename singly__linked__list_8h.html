<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/singly_linked_list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('singly__linked__list_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">singly_linked_list.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Singly Linked List Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;impl/impl_singly_linked_list.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for singly_linked_list.h:</div>
<div class="dyncontent">
<div class="center"><img src="singly__linked__list_8h__incl.png" border="0" usemap="#accc_2singly__linked__list_8h" alt=""/></div>
<map name="accc_2singly__linked__list_8h" id="accc_2singly__linked__list_8h">
<area shape="rect" title="The Singly Linked List Interface." alt="" coords="81,5,252,31"/>
<area shape="rect" title=" " alt="" coords="5,79,181,119"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="206,86,277,111"/>
<area shape="rect" title=" " alt="" coords="172,167,311,192"/>
</map>
</div>
</div>
<p><a href="singly__linked__list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a76fa7a679858852029b6ac191b9868b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a76fa7a679858852029b6ac191b9868b4">ccc_sll_init</a>(list_name,  struct_name,  list_elem_field,  alloc_fn,  cmp_fn,  aux_data)</td></tr>
<tr class="memdesc:a76fa7a679858852029b6ac191b9868b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a singly linked list at compile or runtime.  <br /></td></tr>
<tr class="separator:a76fa7a679858852029b6ac191b9868b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9002202a3809db1cf28ab47146f5cb3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a9002202a3809db1cf28ab47146f5cb3a">ccc_sll_emplace_front</a>(list_ptr,  struct_initializer...)&#160;&#160;&#160;    ccc_impl_sll_emplace_front(list_ptr, struct_initializer)</td></tr>
<tr class="memdesc:a9002202a3809db1cf28ab47146f5cb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a compound literal directly to allocated memory at the front. O(1).  <br /></td></tr>
<tr class="separator:a9002202a3809db1cf28ab47146f5cb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a900d4f0c536208547abfbc1e79e74fbf"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_sll_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a></td></tr>
<tr class="memdesc:a900d4f0c536208547abfbc1e79e74fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A low overhead front tracking container with efficient push and pop.  <br /></td></tr>
<tr class="separator:a900d4f0c536208547abfbc1e79e74fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeb9ade999c0c98572b636601a72bb9"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_sll_elem_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a></td></tr>
<tr class="memdesc:adfeb9ade999c0c98572b636601a72bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A singly linked list intrusive element to embedded in a user type.  <br /></td></tr>
<tr class="separator:adfeb9ade999c0c98572b636601a72bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Insert and Remove Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Add or remove elements from the container. </p>
</td></tr>
<tr class="memitem:a20652f3d5f4e73dd77b3490c7534a54b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a20652f3d5f4e73dd77b3490c7534a54b">ccc_sll_push_front</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *elem)</td></tr>
<tr class="memdesc:a20652f3d5f4e73dd77b3490c7534a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the type wrapping elem to the front of the list. O(1).  <br /></td></tr>
<tr class="separator:a20652f3d5f4e73dd77b3490c7534a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2924476c4e07b64703ba579e9126ff7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a2924476c4e07b64703ba579e9126ff7b">ccc_sll_pop_front</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *sll)</td></tr>
<tr class="memdesc:a2924476c4e07b64703ba579e9126ff7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the front element from the list. O(1).  <br /></td></tr>
<tr class="separator:a2924476c4e07b64703ba579e9126ff7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf05230243224dbf4d344e852f1cce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#afbf05230243224dbf4d344e852f1cce9">ccc_sll_splice</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *pos_sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *pos, <a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *splice_sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *splice)</td></tr>
<tr class="memdesc:afbf05230243224dbf4d344e852f1cce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts splice element before pos. O(N).  <br /></td></tr>
<tr class="separator:afbf05230243224dbf4d344e852f1cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a78d6739651c7609a0dc73b7e367062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a0a78d6739651c7609a0dc73b7e367062">ccc_sll_splice_range</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *pos_sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *pos, <a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *splice_sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *begin, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *end)</td></tr>
<tr class="memdesc:a0a78d6739651c7609a0dc73b7e367062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the range of spliced elements before pos. O(N).  <br /></td></tr>
<tr class="separator:a0a78d6739651c7609a0dc73b7e367062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a146bc93e08c20b82e36fcf079fa08"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a22a146bc93e08c20b82e36fcf079fa08">ccc_sll_erase</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *elem)</td></tr>
<tr class="memdesc:a22a146bc93e08c20b82e36fcf079fa08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases elem from the list returning the following element. O(N).  <br /></td></tr>
<tr class="separator:a22a146bc93e08c20b82e36fcf079fa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7d968ad70c8a7eb3e31fe7e91cecf2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a8b7d968ad70c8a7eb3e31fe7e91cecf2">ccc_sll_erase_range</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *begin, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *end)</td></tr>
<tr class="memdesc:a8b7d968ad70c8a7eb3e31fe7e91cecf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a range from the list returning the element after end. O(N).  <br /></td></tr>
<tr class="separator:a8b7d968ad70c8a7eb3e31fe7e91cecf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792d38a075b9f51c29886193fea53f8f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a792d38a075b9f51c29886193fea53f8f">ccc_sll_extract</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *elem)</td></tr>
<tr class="memdesc:a792d38a075b9f51c29886193fea53f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the list without freeing it. O(N).  <br /></td></tr>
<tr class="separator:a792d38a075b9f51c29886193fea53f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdb50adbf99f6a07b531a6d962a7f83"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#aebdb50adbf99f6a07b531a6d962a7f83">ccc_sll_extract_range</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *begin, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *end)</td></tr>
<tr class="memdesc:aebdb50adbf99f6a07b531a6d962a7f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a range of elements from the list without freeing them. O(N).  <br /></td></tr>
<tr class="separator:aebdb50adbf99f6a07b531a6d962a7f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Deallocate the container. </p>
</td></tr>
<tr class="memitem:ab042e96aa623cc0bd618994414429961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#ab042e96aa623cc0bd618994414429961">ccc_sll_clear</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *sll, <a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *fn)</td></tr>
<tr class="memdesc:ab042e96aa623cc0bd618994414429961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list freeing memory if needed. O(N).  <br /></td></tr>
<tr class="separator:ab042e96aa623cc0bd618994414429961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iteration Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Iterate through the doubly linked list. </p>
</td></tr>
<tr class="memitem:abe30c1573bc55030386e62844f8ae74e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#abe30c1573bc55030386e62844f8ae74e">ccc_sll_begin</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll)</td></tr>
<tr class="memdesc:abe30c1573bc55030386e62844f8ae74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the user type at the front of the list. O(1).  <br /></td></tr>
<tr class="separator:abe30c1573bc55030386e62844f8ae74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a023a3175530b417a5827a03dff95d7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a3a023a3175530b417a5827a03dff95d7">ccc_sll_end</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll)</td></tr>
<tr class="memdesc:a3a023a3175530b417a5827a03dff95d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sentinel at the end of the list. Do not access sentinel. O(1).  <br /></td></tr>
<tr class="separator:a3a023a3175530b417a5827a03dff95d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4724b83877b5582774c6f5d138edf6a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#ab4724b83877b5582774c6f5d138edf6a">ccc_sll_next</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll, <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> const *elem)</td></tr>
<tr class="memdesc:ab4724b83877b5582774c6f5d138edf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the user type following elem in the list. O(1).  <br /></td></tr>
<tr class="separator:ab4724b83877b5582774c6f5d138edf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain state from the doubly linked list. </p>
</td></tr>
<tr class="memitem:a9925c8fe46e4b260e72377bb5bb7e4bc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a9925c8fe46e4b260e72377bb5bb7e4bc">ccc_sll_front</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll)</td></tr>
<tr class="memdesc:a9925c8fe46e4b260e72377bb5bb7e4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the element at the front of the list. O(1).  <br /></td></tr>
<tr class="separator:a9925c8fe46e4b260e72377bb5bb7e4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a2fa2efc460be38875c7893b1416e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a96a2fa2efc460be38875c7893b1416e2">ccc_sll_begin_elem</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll)</td></tr>
<tr class="memdesc:a96a2fa2efc460be38875c7893b1416e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the first intrusive handle in the list. O(1).  <br /></td></tr>
<tr class="separator:a96a2fa2efc460be38875c7893b1416e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3332d20b463538ad83abc752858a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a8a3332d20b463538ad83abc752858a37">ccc_sll_begin_sentinel</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll)</td></tr>
<tr class="memdesc:a8a3332d20b463538ad83abc752858a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the first list element in the list. O(1).  <br /></td></tr>
<tr class="separator:a8a3332d20b463538ad83abc752858a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a9baed75df4fea03f0be097e4e5699"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a85a9baed75df4fea03f0be097e4e5699">ccc_sll_size</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll)</td></tr>
<tr class="memdesc:a85a9baed75df4fea03f0be097e4e5699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the list. O(1).  <br /></td></tr>
<tr class="separator:a85a9baed75df4fea03f0be097e4e5699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be8bf3d55e3e7bc9baff68a14c3ffe0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a7be8bf3d55e3e7bc9baff68a14c3ffe0">ccc_sll_is_empty</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll)</td></tr>
<tr class="memdesc:a7be8bf3d55e3e7bc9baff68a14c3ffe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the list is empty. O(1).  <br /></td></tr>
<tr class="separator:a7be8bf3d55e3e7bc9baff68a14c3ffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb65ff8b957b2dd2c4ef6ef33e85b33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singly__linked__list_8h.html#a4eb65ff8b957b2dd2c4ef6ef33e85b33">ccc_sll_validate</a> (<a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *sll)</td></tr>
<tr class="memdesc:a4eb65ff8b957b2dd2c4ef6ef33e85b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the invariants of the list hold.  <br /></td></tr>
<tr class="separator:a4eb65ff8b957b2dd2c4ef6ef33e85b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Singly Linked List Interface. </p>
<p>A singly linked list is well suited for list or stack structures that only need access to the front or most recently added elements. When compared to a doubly linked list, the memory overhead per node is smaller but some operations will have O(N) runtime implications when compared to a similar operation in a doubly linked list. Review function documentation when unsure of the runtime of an sll operation.</p>
<p>This container offers pointer stability. Also, if the container is not permitted to allocate all insertion code assumes that the user has allocated memory appropriately for the element to be inserted; it will not allocate or free in this case. If allocation is permitted upon initialization the container will manage the memory as expected on insert or erase operations as defined by the interface; memory is allocated for insertions and freed for removals.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SINGLY_LINKED_LIST_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>ccc_</code> prefix. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9002202a3809db1cf28ab47146f5cb3a" name="a9002202a3809db1cf28ab47146f5cb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9002202a3809db1cf28ab47146f5cb3a">&#9670;&#160;</a></span>ccc_sll_emplace_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_sll_emplace_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">struct_initializer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_sll_emplace_front(list_ptr, struct_initializer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a compound literal directly to allocated memory at the front. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list_ptr</td><td>a pointer to the singly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">struct_initializer</td><td>a compound literal containing the elements to be written to a newly allocated node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element pushed to the front or NULL if allocation failed.</dd></dl>
<p>Note that it only makes sense to use this method when the container is given allocation permission. Otherwise NULL is returned due to an inability for the container to allocate memory. </p>

</div>
</div>
<a id="a76fa7a679858852029b6ac191b9868b4" name="a76fa7a679858852029b6ac191b9868b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fa7a679858852029b6ac191b9868b4">&#9670;&#160;</a></span>ccc_sll_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_sll_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">struct_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list_elem_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alloc_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmp_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">aux_data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ccc_impl_sll_init(list_name, struct_name, list_elem_field, alloc_fn,       \</div>
<div class="line">                      cmp_fn, aux_data)</div>
</div><!-- fragment -->
<p>Initialize a singly linked list at compile or runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list_name</td><td>the name the user has chosen for the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">struct_name</td><td>the user type wrapping the intrusive sll elem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list_elem_field</td><td>the name of the field in the user type storing the intrusive list elem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_fn</td><td>an allocation function if allocation is allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_fn</td><td>a comparison function for searching or sorting the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux_data</td><td>a pointer to any auxiliary data needed for comparison or destruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a stuct initializer for the singly linked list to be assigned (e.g. ccc_singly_linked_list l = <a class="el" href="singly__linked__list_8h.html#a76fa7a679858852029b6ac191b9868b4" title="Initialize a singly linked list at compile or runtime.">ccc_sll_init(...)</a>;). </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a900d4f0c536208547abfbc1e79e74fbf" name="a900d4f0c536208547abfbc1e79e74fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900d4f0c536208547abfbc1e79e74fbf">&#9670;&#160;</a></span>ccc_singly_linked_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_sll_ <a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A low overhead front tracking container with efficient push and pop. </p>
<p>A singly linked list may be stored in the stack, heap, or data segment. Once Initialized it is passed by reference to all functions. A singly linked list can be initialized at compile time or runtime. </p>

</div>
</div>
<a id="adfeb9ade999c0c98572b636601a72bb9" name="adfeb9ade999c0c98572b636601a72bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfeb9ade999c0c98572b636601a72bb9">&#9670;&#160;</a></span>ccc_sll_elem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_sll_elem_ <a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A singly linked list intrusive element to embedded in a user type. </p>
<p>It can be used in an allocating or non allocating container. If allocation is prohibited the container assumes the element is wrapped in pre-allocated memory with the appropriate lifetime and scope for the user's needs; the container does not allocate or free in this case. If allocation is allowed the container will handle copying the data wrapping the element to allocations and deallocating when necessary. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abe30c1573bc55030386e62844f8ae74e" name="abe30c1573bc55030386e62844f8ae74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe30c1573bc55030386e62844f8ae74e">&#9670;&#160;</a></span>ccc_sll_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the user type at the front of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type at the start of the list or the end sentinel. NULL is returned if sll is NULL. </dd></dl>

</div>
</div>
<a id="a96a2fa2efc460be38875c7893b1416e2" name="a96a2fa2efc460be38875c7893b1416e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a2fa2efc460be38875c7893b1416e2">&#9670;&#160;</a></span>ccc_sll_begin_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> * ccc_sll_begin_elem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the first intrusive handle in the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first handle to a user type in the list or NULL if empty. </dd></dl>

</div>
</div>
<a id="a8a3332d20b463538ad83abc752858a37" name="a8a3332d20b463538ad83abc752858a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3332d20b463538ad83abc752858a37">&#9670;&#160;</a></span>ccc_sll_begin_sentinel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> * ccc_sll_begin_sentinel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the first list element in the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first list element. This will never be NULL, even if the list is empty. If bad input is provided (sll is NULL) NULL is returned. </dd></dl>

</div>
</div>
<a id="ab042e96aa623cc0bd618994414429961" name="ab042e96aa623cc0bd618994414429961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab042e96aa623cc0bd618994414429961">&#9670;&#160;</a></span>ccc_sll_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_sll_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the list freeing memory if needed. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>a destructor function or NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the clear succeeded or an input error if sll or fn are NULL.</dd></dl>
<p>Note that if allocation is allowed, the container will free the user types wrapping each intrusive element in the list after calling fn. Therefore, fn should not free memory if the container has been given allocation permission. It should only perform other necessary cleanup or state management.</p>
<p>If allocation is not allowed fn may free memory or not as the user sees fit. The user is responsible for managing the memory that wraps each intrusive handle as the elements are simply removed from the list. </p>

</div>
</div>
<a id="a3a023a3175530b417a5827a03dff95d7" name="a3a023a3175530b417a5827a03dff95d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a023a3175530b417a5827a03dff95d7">&#9670;&#160;</a></span>ccc_sll_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sentinel at the end of the list. Do not access sentinel. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sentinel at the end of the list. It is undefined to access the sentinel. NULL is returned if sll is NULL. <br  />
 </dd></dl>

</div>
</div>
<a id="a22a146bc93e08c20b82e36fcf079fa08" name="a22a146bc93e08c20b82e36fcf079fa08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a146bc93e08c20b82e36fcf079fa08">&#9670;&#160;</a></span>ccc_sll_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases elem from the list returning the following element. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a handle to the intrusive element known to be in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element following elem in the list or NULL if the list is empty or any bad input is provided to the function. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>elem must be in the list.</dd></dl>
<p>Note that if allocation permission is given to the container it will free the element. Otherwise, it is the user's responsibility to free the type wrapping elem. </p>

</div>
</div>
<a id="a8b7d968ad70c8a7eb3e31fe7e91cecf2" name="a8b7d968ad70c8a7eb3e31fe7e91cecf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7d968ad70c8a7eb3e31fe7e91cecf2">&#9670;&#160;</a></span>ccc_sll_erase_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_erase_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases a range from the list returning the element after end. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>the start of the range in the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the exclusive end of the range in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element following the range in the list or NULL if the list is empty or any bad input is provided to the function. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the provided range must be in the list.</dd></dl>
<p>Note that if allocation permission is given to the container it will free the elements in the range. Otherwise, it is the user's responsibility to free the types wrapping the range of elements. </p>

</div>
</div>
<a id="a792d38a075b9f51c29886193fea53f8f" name="a792d38a075b9f51c29886193fea53f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792d38a075b9f51c29886193fea53f8f">&#9670;&#160;</a></span>ccc_sll_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts an element from the list without freeing it. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a handle to the intrusive element known to be in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element following elem in the list.</dd></dl>
<p>Note that regardless of allocation permission this method will not free the type wrapping elem. It only removes it from the list. </p>

</div>
</div>
<a id="aebdb50adbf99f6a07b531a6d962a7f83" name="aebdb50adbf99f6a07b531a6d962a7f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdb50adbf99f6a07b531a6d962a7f83">&#9670;&#160;</a></span>ccc_sll_extract_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_extract_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a range of elements from the list without freeing them. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>the start of the range in the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the exclusive end of the range in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element following the range of elements in the list.</dd></dl>
<p>Note that the range remains in tact and can be iterated as one would iterate a normal list. However, insertions and removals from a range are not possible as they no longer belong to any list. </p>

</div>
</div>
<a id="a9925c8fe46e4b260e72377bb5bb7e4bc" name="a9925c8fe46e4b260e72377bb5bb7e4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9925c8fe46e4b260e72377bb5bb7e4bc">&#9670;&#160;</a></span>ccc_sll_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the element at the front of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the front element or NULL if empty or sll is NULL. </dd></dl>

</div>
</div>
<a id="a7be8bf3d55e3e7bc9baff68a14c3ffe0" name="a7be8bf3d55e3e7bc9baff68a14c3ffe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be8bf3d55e3e7bc9baff68a14c3ffe0">&#9670;&#160;</a></span>ccc_sll_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_sll_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the list is empty. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size is 0 or sll is NULL otherwise false. </dd></dl>

</div>
</div>
<a id="ab4724b83877b5582774c6f5d138edf6a" name="ab4724b83877b5582774c6f5d138edf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4724b83877b5582774c6f5d138edf6a">&#9670;&#160;</a></span>ccc_sll_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> const *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the user type following elem in the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the intrusive handle known to be in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the user type following elem or the end sentinel if none follow. NULL is returned if sll or elem are NULL. </dd></dl>

</div>
</div>
<a id="a2924476c4e07b64703ba579e9126ff7b" name="a2924476c4e07b64703ba579e9126ff7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2924476c4e07b64703ba579e9126ff7b">&#9670;&#160;</a></span>ccc_sll_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_sll_pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the front element from the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the list is non-empty and the pop is successful. An input error is returned if sll is NULL or the list is empty. </dd></dl>

</div>
</div>
<a id="a20652f3d5f4e73dd77b3490c7534a54b" name="a20652f3d5f4e73dd77b3490c7534a54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20652f3d5f4e73dd77b3490c7534a54b">&#9670;&#160;</a></span>ccc_sll_push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_sll_push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push the type wrapping elem to the front of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a pointer to the intrusive handle in the user type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inserted element or NULL if allocation failed.</dd></dl>
<p>Note that if allocation is not allowed the container assumes the memory wrapping elem has been allocated appropriately and with the correct lifetime by the user.</p>
<p>If allocation is allowed the provided element is copied to a new allocation. </p>

</div>
</div>
<a id="a85a9baed75df4fea03f0be097e4e5699" name="a85a9baed75df4fea03f0be097e4e5699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a9baed75df4fea03f0be097e4e5699">&#9670;&#160;</a></span>ccc_sll_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_sll_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the list. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size or 0 if the list is empty or sll is NULL. </dd></dl>

</div>
</div>
<a id="afbf05230243224dbf4d344e852f1cce9" name="afbf05230243224dbf4d344e852f1cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf05230243224dbf4d344e852f1cce9">&#9670;&#160;</a></span>ccc_sll_splice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_sll_splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>pos_sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>splice_sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>splice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts splice element before pos. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_sll</td><td>the list to which pos belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>the position before which splice will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splice_sll</td><td>the list to which splice belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splice</td><td>the element to be moved before pos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the operations is successful. An input error is provided if any input pointers are NULL.</dd></dl>
<p>Note that pos_sll and splice_sll may be the same or different lists and the invariants of each or the same list will be maintained by the function. </p>

</div>
</div>
<a id="a0a78d6739651c7609a0dc73b7e367062" name="a0a78d6739651c7609a0dc73b7e367062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a78d6739651c7609a0dc73b7e367062">&#9670;&#160;</a></span>ccc_sll_splice_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_sll_splice_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>pos_sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> *&#160;</td>
          <td class="paramname"><em>splice_sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#adfeb9ade999c0c98572b636601a72bb9">ccc_sll_elem</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the range of spliced elements before pos. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_sll</td><td>the list to which pos belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>the position before which the range will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splice_sll</td><td>the list to which the range belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>the start of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the operations is successful. An input error is provided if any input pointers are NULL. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>pos must not be inside of the range (begin, end) if pos_sll is the same list as splice_sll.</dd></dl>
<p>Note that pos_sll and splice_sll may be the same or different lists and the invariants of each or the same list will be maintained by the function. </p>

</div>
</div>
<a id="a4eb65ff8b957b2dd2c4ef6ef33e85b33" name="a4eb65ff8b957b2dd2c4ef6ef33e85b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb65ff8b957b2dd2c4ef6ef33e85b33">&#9670;&#160;</a></span>ccc_sll_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_sll_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singly__linked__list_8h.html#a900d4f0c536208547abfbc1e79e74fbf">ccc_singly_linked_list</a> const *&#160;</td>
          <td class="paramname"><em>sll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the invariants of the list hold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sll</td><td>a pointer to the singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the list is valid, else false. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="singly__linked__list_8h.html">singly_linked_list.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
