<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): C Container Collection (CCC)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">C Container Collection (CCC) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> The C Container Collection offers a variety of containers for C programmers who want fine-grained control of memory in their programs. All containers offer both allocating and non-allocating interfaces. This means it is possible to write a program in which a container never allocates or frees a single byte of your memory. For the motivations of why such a library is helpful in C read on.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Installation</h1>
<p>Currently, this library supports a manual installation via CMake. See the <a class="el" href="md_INSTALL.html">INSTALL.md</a> file for more details.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Quick Start</h1>
<p>Read the documentation <a href="https://agl-alexglopez.github.io/ccc">HERE</a>. To get started, read the <a href="https://agl-alexglopez.github.io/ccc/files.html">header</a> for the container you want to use. Also check out <a href="https://agl-alexglopez.github.io/ccc/files.html">types.h</a> to acquaint yourself with the <code>ccc_alloc_fn</code> abstraction and decide if you need allocating or non-allocating containers in your project.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Design</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
Motivations</h2>
<p>Here is the main argument of this library:</p>
<blockquote class="doxtable">
<p>&zwj;Containers in C should avoid limiting the control and flexibility offered by the C language. </p>
</blockquote>
<p>There are many excellent data structure libraries in C (see the related section). However, many of them try to approximate more modern languages like C++ and Rust in both form and function; they implement memory owning containers where the interface implicitly forces you to agree to the container's opinion of how and when memory should be managed. While many accept custom allocators for the container, a core assumption seems to be that it is OK for calls to container functions to have a non-trivial side effect by calling dynamic memory interfaces.</p>
<p>The C Container Collection takes a different approach. When initializing the containers in this library the user chooses if memory management is allowed by the container. If allowed, these containers will manage allocation as one may be used to in higher level languages. However, if allocation is prohibited then these containers offer data structures as their literal interpretation; they structure the data they are given according to the container's invariants with no memory related side effects. The concerns of the container are now separate from those of the programmer. The container takes no part in the scope or lifetime of the programmer's provided memory, simply structuring it within the container as promised by the interface.</p>
<p>The reason for this decision is simple: if people are using C today, in the face of many other modern and safety-minded languages, they should benefit from all the language can provide, even when incorporating a third-party library. This means that they can manage all their memory as they see fit and these containers simply structure it when and how the programmer requires. This design style is not unique. Non-allocating intrusive containers are common in operating system kernel development where the idea of dynamic memory, where memory comes from, and when memory should be allocated or freed becomes more complex due to the structure of all the modules working together behind the scenes to support the user. Embedded developers also stand to benefit from this design. However, I think that all applications can benefit from thinking more carefully about their memory in C.</p>
<p>While not all containers require the user accommodate intrusive elements, when they do it looks like this.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>key_val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">    container_elem elem;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The handle to the container element is then passed by reference to all functions that require it.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Allocation</h2>
<p>If the non-allocating features are of the most interest to you, this section may not be relevant. However, to support the previously mentioned design motivations, this collection offers the following interface for allocation. The user defines this function and provides it to containers upon initialization.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">void</span> *<a class="code hl_typedef" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a>(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size, <span class="keywordtype">void</span> *aux);</div>
<div class="ttc" id="atypes_8h_html_a8be6e2d1b150a5b77b2eba5ae85764f2"><div class="ttname"><a href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a></div><div class="ttdeci">void * ccc_alloc_fn(void *ptr, size_t size, void *aux)</div><div class="ttdoc">An allocation function at the core of all containers.</div><div class="ttdef"><b>Definition:</b> types.h:186</div></div>
</div><!-- fragment --><p>An allocation function implements the following behavior, where ptr is pointer to memory, size is number of bytes to allocate, and aux is a reference to any supplementary information required for allocation, deallocation, or reallocation. The aux parameter is passed to a container upon its initialization and the programmer may choose how to best utilize this reference (read on for more on aux).</p>
<ul>
<li>If NULL is provided with a size of 0, NULL is returned.</li>
<li>If NULL is provided with a non-zero size, new memory is allocated/returned.</li>
<li>If ptr is non-NULL it has been previously allocated by the alloc function.</li>
<li>If ptr is non-NULL with non-zero size, ptr is resized to at least size size. The pointer returned is NULL if resizing fails. Upon success, the pointer returned might not be equal to the pointer provided.</li>
<li>If ptr is non-NULL and size is 0, ptr is freed and NULL is returned.</li>
</ul>
<p>One may be tempted to use realloc to check all of these boxes but realloc is implementation defined on some of these points. So, the aux parameter also discourages users from providing realloc. For example, one solution using the standard library allocator might be implemented as follows (aux is not needed):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *</div>
<div class="line">std_alloc(<span class="keywordtype">void</span> *<span class="keyword">const</span> ptr, <span class="keywordtype">size_t</span> <span class="keyword">const</span> size, <span class="keywordtype">void</span> *<span class="keyword">const</span> aux)</div>
<div class="line">{</div>
<div class="line">    (void)aux;</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr &amp;&amp; !size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> malloc(size);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!size)</div>
<div class="line">    {</div>
<div class="line">        free(ptr);</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> realloc(ptr, size);</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, the above example is only useful if the standard library allocator is used. Any allocator that implements the required behavior is sufficient. For ideas of how to utilize the aux parameter, see the sample programs. Using custom arena allocators or container compositions are cases when aux is helpful in taming lifetimes and simplifying allocation.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Constructors</h3>
<p>Another concern for the programmer related to allocation may be constructors and destructors, a C++ shaped block for a C shaped hole. In general, this library has some limited support for destruction but does not provide an interface for direct constructors as C++ would define them; though this may change.</p>
<p>Consider a constructor. If the container is allowed to allocate, and the user wants to insert a new element, they may see an interface like this (pseudocode as all containers are slightly different).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *insert(container *c, container_elem *e);</div>
</div><!-- fragment --><p>Because the user has wrapped the intrusive container element in their type, the entire user type will be written to the new allocation. All interfaces also offer functions that return references to successfully inserted elements if global program state should be set depending on this success. So, if some action beyond setting values needs to be performed, there are multiple opportunities to do so.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Destructors</h3>
<p>For destructors, the argument is similar but the container does help with this at times. If an action other than freeing the memory of a user type is needed upon removal, there are multiple options in an interface to obtain the element to be removed. Associative containers offer functions that can obtain entries (similar to Rust's Entry API). This reference can then be examined and complex destructor actions can occur before removal. Other containers like lists or priority queues offer references to an element of interest such as front, back, max, min, etc. These can all allow destructor-like actions before removal. The one exception is the following interfaces.</p>
<p>The clear function works for pointer stable containers and flat containers.</p>
<div class="fragment"><div class="line">result clear(container *c, destructor_fn *fn);</div>
</div><!-- fragment --><p>The clear and free function works for flat containers.</p>
<div class="fragment"><div class="line">result clear_and_free(container *c, destructor_fn *fn);</div>
</div><!-- fragment --><p>The above functions free the resources of the container. Because there is no way to access each element before it is freed when this function is called, a destructor callback can be passed to operate on each element before deallocation.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Samples</h1>
<p>For examples of what code that uses these ideas looks like, read and use the sample programs in the <code>samples/</code>. I try to only add non-trivial samples that do something mildly interesting to give a good idea of how to take advantage of this flexible memory philosophy.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Related</h1>
<p>Here are some excellent data structure libraries I have found for C. Many of them are simple, fast, and elegant, taking care of all memory management for you.</p>
<ul>
<li><a href="https://github.com/stclib/STC">STC - Smart Template Containers</a></li>
<li><a href="https://github.com/glouw/ctl">C Template Library (CTL)</a></li>
<li><a href="https://github.com/JacksonAllan/CC">CC: Convenient Containers</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
