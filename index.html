<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): C Container Collection (CCC)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">C Container Collection (CCC) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> The C Container Collection offers a variety of containers for C programmers who want fine-grained control of memory in their programs. All containers offer both allocating and non-allocating interfaces. For the motivations of why such a library is helpful in C read on.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Installation</h1>
<p>The following are required for install:</p>
<ul>
<li>GCC or Clang supporting C23.<ul>
<li>100% coverage of C23 is not required. For example, at the time of writing Clang 19.1.1 and GCC 14.2 have all features used in this collection covered, but older versions of each compiler may work as well.</li>
</ul>
</li>
<li>CMake &gt;= 3.23.</li>
</ul>
<p>Currently, this library supports a manual installation via CMake. See the <a class="el" href="md_INSTALL.html">INSTALL.md</a> file for more details. This file is also included when you download a simplified release from the <a href="https://github.com/agl-alexglopez/ccc/releases">Releases</a> page.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Quick Start</h1>
<ul>
<li>Read the <a href="https://agl-alexglopez.github.io/ccc">DOCS</a>.</li>
<li>Read <a href="https://agl-alexglopez.github.io/ccc/types_8h.html">types.h</a> to understand the <code>ccc_alloc_fn</code> interface.</li>
<li>Read the <a href="https://agl-alexglopez.github.io/ccc/files.html">header</a> for the desired container to understand its functionality.</li>
<li>Read about generic <a href="https://agl-alexglopez.github.io/ccc/traits_8h.html">traits.h</a> shared across containers to make code more succinct.</li>
<li>Read CONTRIBUTING.md if interested in project structure, tools, and todos.</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Containers</h1>
<details >
<summary >
buffer.h (dropdown)</summary>
<p>A fixed or dynamic contiguous array of a single user defined type.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="buffer_8h.html">ccc/buffer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* stack array, no allocation permission, no aux data, capacity 5 */</span></div>
<div class="line">    buffer b = buf_init((<span class="keywordtype">int</span>[5]){}, NULL, NULL, 5);</div>
<div class="line">    (void)push_back(&amp;b, &amp;(<span class="keywordtype">int</span>){3});</div>
<div class="line">    (void)push_back(&amp;b, &amp;(<span class="keywordtype">int</span>){2});</div>
<div class="line">    (void)push_back(&amp;b, &amp;(<span class="keywordtype">int</span>){1});</div>
<div class="line">    (void)pop_back(&amp;b);</div>
<div class="line">    <span class="keywordtype">int</span> *i = back(&amp;b);</div>
<div class="line">    assert(*i == 2);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="abuffer_8h_html"><div class="ttname"><a href="buffer_8h.html">buffer.h</a></div><div class="ttdoc">The Buffer Interface.</div></div>
<div class="ttc" id="atraits_8h_html"><div class="ttname"><a href="traits_8h.html">traits.h</a></div><div class="ttdoc">The C Container Collection Traits Interface.</div></div>
</div><!-- fragment --> </details>
<details >
<summary >
doubly_linked_list.h (dropdown)</summary>
<p>A dynamic container for efficient insertion and removal at any position.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define DOUBLY_LINKED_LIST_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="doubly__linked__list_8h.html">ccc/doubly_linked_list.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>int_elem</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    dll_elem e;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">int_cmp(<a class="code hl_struct" href="structccc__cmp.html">ccc_cmp</a> <span class="keyword">const</span> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>int_elem const *<span class="keyword">const</span> lhs = cmp.<a class="code hl_variable" href="structccc__cmp.html#a413783988aeb931cebe1ff2355147e49">user_type_lhs</a>;</div>
<div class="line">    <span class="keyword">struct </span>int_elem const *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__cmp.html#aad71faef58d3c2d057d2f2953372f32f">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordflow">return</span> (lhs-&gt;i &gt; rhs-&gt;i) - (lhs-&gt;i &lt; rhs-&gt;i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* doubly linked list l, list elem field e, no allocation permission,</span></div>
<div class="line"><span class="comment">       comparing integers, no auxiliary data. */</span></div>
<div class="line">    doubly_linked_list l = dll_init(l, <span class="keyword">struct</span> int_elem, e, NULL, int_cmp, NULL);</div>
<div class="line">    <span class="keyword">struct </span>int_elem elems[3] = {{.i = 3}, {.i = 2}, {.i = 1}};</div>
<div class="line">    (void)push_back(&amp;l, &amp;elems[0].e);</div>
<div class="line">    (void)push_front(&amp;l, &amp;elems[1].e);</div>
<div class="line">    (void)push_back(&amp;l, &amp;elems[2].e);</div>
<div class="line">    (void)pop_back(&amp;l);</div>
<div class="line">    <span class="keyword">struct </span>int_elem *e = back(&amp;l);</div>
<div class="line">    assert(e-&gt;i == 3);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="adoubly__linked__list_8h_html"><div class="ttname"><a href="doubly__linked__list_8h.html">doubly_linked_list.h</a></div><div class="ttdoc">The Doubly Linked List Interface.</div></div>
<div class="ttc" id="astructccc__cmp_html"><div class="ttname"><a href="structccc__cmp.html">ccc_cmp</a></div><div class="ttdoc">An element comparison helper.</div><div class="ttdef"><b>Definition:</b> types.h:100</div></div>
<div class="ttc" id="astructccc__cmp_html_a413783988aeb931cebe1ff2355147e49"><div class="ttname"><a href="structccc__cmp.html#a413783988aeb931cebe1ff2355147e49">ccc_cmp::user_type_lhs</a></div><div class="ttdeci">void const  *const user_type_lhs</div><div class="ttdef"><b>Definition:</b> types.h:102</div></div>
<div class="ttc" id="astructccc__cmp_html_aad71faef58d3c2d057d2f2953372f32f"><div class="ttname"><a href="structccc__cmp.html#aad71faef58d3c2d057d2f2953372f32f">ccc_cmp::user_type_rhs</a></div><div class="ttdeci">void const  *const user_type_rhs</div><div class="ttdef"><b>Definition:</b> types.h:104</div></div>
<div class="ttc" id="atypes_8h_html_a9958f3004414182c457c71289303ae57"><div class="ttname"><a href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div><div class="ttdeci">ccc_threeway_cmp</div><div class="ttdoc">A three-way comparison for comparison functions.</div><div class="ttdef"><b>Definition:</b> types.h:80</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
flat_double_ended_queue.h (dropdown)</summary>
<p>A dynamic or fixed size double ended queue offering contiguously stored elements. When fixed size, its behavior is that of a ring buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define FLAT_DOUBLE_ENDED_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="flat__double__ended__queue_8h.html">ccc/flat_double_ended_queue.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* stack array, no allocation permission, no aux data, capacity 2 */</span></div>
<div class="line">    flat_double_ended_queue q = fdeq_init((<span class="keywordtype">int</span>[2]){}, NULL, NULL, 2);</div>
<div class="line">    (void)push_back(&amp;q, &amp;(<span class="keywordtype">int</span>){3});</div>
<div class="line">    (void)push_front(&amp;q, &amp;(<span class="keywordtype">int</span>){2});</div>
<div class="line">    (void)push_back(&amp;q, &amp;(<span class="keywordtype">int</span>){1}); <span class="comment">/* Overwrite 2. */</span></div>
<div class="line">    <span class="keywordtype">int</span> *i = front(&amp;q);</div>
<div class="line">    assert(*i == 3);</div>
<div class="line">    i = back(&amp;q);</div>
<div class="line">    assert(*i == 1);</div>
<div class="line">    (void)pop_back(&amp;q);</div>
<div class="line">    i = back(&amp;q);</div>
<div class="line">    assert(*i == 3);</div>
<div class="line">    i = front(&amp;q);</div>
<div class="line">    assert(*i == 3);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aflat__double__ended__queue_8h_html"><div class="ttname"><a href="flat__double__ended__queue_8h.html">flat_double_ended_queue.h</a></div><div class="ttdoc">The Flat Double Ended Queue Interface.</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
flat_hash_map.h (dropdown)</summary>
<p>Amortized O(1) access to elements stored in a flat array by key. Not pointer stable.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="flat__hash__map_8h.html">ccc/flat_hash_map.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>key_val</div>
<div class="line">{</div>
<div class="line">    fhmap_elem e;</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> uint64_t</div>
<div class="line">fhmap_int_to_u64(<a class="code hl_struct" href="structccc__user__key.html">ccc_user_key</a> <span class="keyword">const</span> k)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> key_int = *((<span class="keywordtype">int</span> *)k.<a class="code hl_variable" href="structccc__user__key.html#aa8ccc5020a1cada149fb7d1509868b35">user_key</a>);</div>
<div class="line">    uint64_t x = key_int;</div>
<div class="line">    x = (x ^ (x &gt;&gt; 30)) * UINT64_C(0xbf58476d1ce4e5b9);</div>
<div class="line">    x = (x ^ (x &gt;&gt; 27)) * UINT64_C(0x94d049bb133111eb);</div>
<div class="line">    x = x ^ (x &gt;&gt; 31);</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span></div>
<div class="line">fhmap_id_eq(<a class="code hl_struct" href="structccc__key__cmp.html">ccc_key_cmp</a> <span class="keyword">const</span> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>key_val const *<span class="keyword">const</span> va = cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a1378c81c5089d815ce1d61090bd391c4">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordflow">return</span> va-&gt;key == *((<span class="keywordtype">int</span> *)cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a6077551b8a72a5149f78b81f3cb90951">key_lhs</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Two Sum */</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>key_val vals[20];</div>
<div class="line">    <span class="comment">/* stack array backed, key field named key, intrusive field e, no</span></div>
<div class="line"><span class="comment">       allocation permission, a hash function, an equality function, no aux. */</span></div>
<div class="line">    <a class="code hl_typedef" href="flat__hash__map_8h.html#af8251d1f96c8a10e8ff2b20d7f117447">ccc_flat_hash_map</a> fh;</div>
<div class="line">    <a class="code hl_enumeration" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> <span class="keyword">const</span> res</div>
<div class="line">        = fhm_init(&amp;fh, vals, <span class="keyword">sizeof</span>(vals) / <span class="keyword">sizeof</span>(vals[0]), key, e, NULL,</div>
<div class="line">                   fhmap_int_to_u64, fhmap_id_eq, NULL);</div>
<div class="line">    assert(res == <a class="code hl_enumvalue" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1a853ea7c8fbdc75323b7f4367105e9846">CCC_OK</a>);</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> addends[10] = {1, 3, -980, 6, 7, 13, 44, 32, 995, -1};</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> target = 15;</div>
<div class="line">    <span class="keywordtype">int</span> solution_indices[2] = {-1, -1};</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (<span class="keyword">sizeof</span>(addends) / <span class="keyword">sizeof</span>(addends[0])); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Functions take keys and structs by reference. */</span></div>
<div class="line">        <span class="keyword">struct </span>key_val const *<span class="keyword">const</span> other_addend</div>
<div class="line">            = get_key_val(&amp;fh, &amp;(<span class="keywordtype">int</span>){target - addends[i]});</div>
<div class="line">        <span class="keywordflow">if</span> (other_addend)</div>
<div class="line">        {</div>
<div class="line">            solution_indices[0] = (int)i;</div>
<div class="line">            solution_indices[1] = other_addend-&gt;val;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">/* Macros take keys and structs by value. */</span></div>
<div class="line">        (void)fhm_insert_or_assign_w(&amp;fh, addends[i],</div>
<div class="line">                                     (<span class="keyword">struct</span> key_val){.val = i});</div>
<div class="line">    }</div>
<div class="line">    assert(solution_indices[0] == 8);</div>
<div class="line">    assert(solution_indices[1] == 2);</div>
<div class="line">    assert(addends[solution_indices[0]] + addends[solution_indices[1]]</div>
<div class="line">           == target);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aflat__hash__map_8h_html"><div class="ttname"><a href="flat__hash__map_8h.html">flat_hash_map.h</a></div><div class="ttdoc">The Flat Hash Map Interface.</div></div>
<div class="ttc" id="aflat__hash__map_8h_html_af8251d1f96c8a10e8ff2b20d7f117447"><div class="ttname"><a href="flat__hash__map_8h.html#af8251d1f96c8a10e8ff2b20d7f117447">ccc_flat_hash_map</a></div><div class="ttdeci">struct ccc_fhmap_ ccc_flat_hash_map</div><div class="ttdoc">A container for storing key-value structures defined by the user in a contiguous buffer.</div><div class="ttdef"><b>Definition:</b> flat_hash_map.h:39</div></div>
<div class="ttc" id="astructccc__key__cmp_html"><div class="ttname"><a href="structccc__key__cmp.html">ccc_key_cmp</a></div><div class="ttdoc">A key comparison helper to avoid argument swapping.</div><div class="ttdef"><b>Definition:</b> types.h:114</div></div>
<div class="ttc" id="astructccc__key__cmp_html_a1378c81c5089d815ce1d61090bd391c4"><div class="ttname"><a href="structccc__key__cmp.html#a1378c81c5089d815ce1d61090bd391c4">ccc_key_cmp::user_type_rhs</a></div><div class="ttdeci">void const  *const user_type_rhs</div><div class="ttdef"><b>Definition:</b> types.h:118</div></div>
<div class="ttc" id="astructccc__key__cmp_html_a6077551b8a72a5149f78b81f3cb90951"><div class="ttname"><a href="structccc__key__cmp.html#a6077551b8a72a5149f78b81f3cb90951">ccc_key_cmp::key_lhs</a></div><div class="ttdeci">void const  *const key_lhs</div><div class="ttdef"><b>Definition:</b> types.h:116</div></div>
<div class="ttc" id="astructccc__user__key_html"><div class="ttname"><a href="structccc__user__key.html">ccc_user_key</a></div><div class="ttdoc">A read only reference to a key type matching the key field type used for hash containers.</div><div class="ttdef"><b>Definition:</b> types.h:141</div></div>
<div class="ttc" id="astructccc__user__key_html_aa8ccc5020a1cada149fb7d1509868b35"><div class="ttname"><a href="structccc__user__key.html#aa8ccc5020a1cada149fb7d1509868b35">ccc_user_key::user_key</a></div><div class="ttdeci">void const  *const user_key</div><div class="ttdef"><b>Definition:</b> types.h:143</div></div>
<div class="ttc" id="atypes_8h_html_a1493dc76581f8c71eb96202fb1671ae1"><div class="ttname"><a href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a></div><div class="ttdeci">ccc_result</div><div class="ttdoc">A result of actions on containers.</div><div class="ttdef"><b>Definition:</b> types.h:61</div></div>
<div class="ttc" id="atypes_8h_html_a1493dc76581f8c71eb96202fb1671ae1a853ea7c8fbdc75323b7f4367105e9846"><div class="ttname"><a href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1a853ea7c8fbdc75323b7f4367105e9846">CCC_OK</a></div><div class="ttdeci">@ CCC_OK</div><div class="ttdef"><b>Definition:</b> types.h:63</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
flat_ordered_map.h (dropdown)</summary>
<p>An ordered map implemented in array with an index based self-optimizing tree.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define FLAT_ORDERED_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TYPES_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="flat__ordered__map_8h.html">ccc/flat_ordered_map.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>kval</div>
<div class="line">{</div>
<div class="line">    fomap_elem elem;</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">kval_cmp(<a class="code hl_struct" href="structccc__key__cmp.html">ccc_key_cmp</a> <span class="keyword">const</span> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>kval const *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a1378c81c5089d815ce1d61090bd391c4">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> key_lhs = *((<span class="keywordtype">int</span> *)cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a6077551b8a72a5149f78b81f3cb90951">key_lhs</a>);</div>
<div class="line">    <span class="keywordflow">return</span> (key_lhs &gt; rhs-&gt;key) - (key_lhs &lt; rhs-&gt;key);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* stack array of 25 elements with one slot for sentinel, intrusive field</span></div>
<div class="line"><span class="comment">       named elem, key field named key, no allocation permission, key comparison</span></div>
<div class="line"><span class="comment">       function, no aux data. */</span></div>
<div class="line">    flat_ordered_map s</div>
<div class="line">        = fom_init((<span class="keyword">struct</span> kval[26]){}, 26, elem, key, NULL, kval_cmp, NULL);</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> num_nodes = 25;</div>
<div class="line">    <span class="comment">/* 0, 5, 10, 15, 20, 25, 30, 35,... 120 */</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, <span class="keywordtype">id</span> = 0; i &lt; num_nodes; ++i, <span class="keywordtype">id</span> += 5)</div>
<div class="line">    {</div>
<div class="line">        (void)insert_or_assign(&amp;s, &amp;(<span class="keyword">struct</span> kval){.key = id, .val = i}.elem);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* This should be the following range [6,44). 6 should raise to</span></div>
<div class="line"><span class="comment">       next value not less than 6, 10 and 44 should be the first</span></div>
<div class="line"><span class="comment">       value greater than 44, 45. */</span></div>
<div class="line">    <span class="keywordtype">int</span> range_keys[8] = {10, 15, 20, 25, 30, 35, 40, 45};</div>
<div class="line">    range r = equal_range(&amp;s, &amp;(<span class="keywordtype">int</span>){6}, &amp;(int){44});</div>
<div class="line">    <span class="keywordtype">int</span> index = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">struct</span> kval *i = begin_range(&amp;r); i != end_range(&amp;r);</div>
<div class="line">         i = next(&amp;s, &amp;i-&gt;elem))</div>
<div class="line">    {</div>
<div class="line">        assert(i-&gt;key == range_keys[index]);</div>
<div class="line">        ++index;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* This should be the following range [119,84). 119 should be</span></div>
<div class="line"><span class="comment">       dropped to first value not greater than 119 and last should</span></div>
<div class="line"><span class="comment">       be dropped to first value less than 84. */</span></div>
<div class="line">    <span class="keywordtype">int</span> rrange_keys[8] = {115, 110, 105, 100, 95, 90, 85, 80};</div>
<div class="line">    rrange rr = equal_rrange(&amp;s, &amp;(<span class="keywordtype">int</span>){119}, &amp;(int){84});</div>
<div class="line">    index = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">struct</span> kval *i = rbegin_rrange(&amp;rr); i != rend_rrange(&amp;rr);</div>
<div class="line">         i = rnext(&amp;s, &amp;i-&gt;elem))</div>
<div class="line">    {</div>
<div class="line">        assert(i-&gt;key == rrange_keys[index]);</div>
<div class="line">        ++index;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aflat__ordered__map_8h_html"><div class="ttname"><a href="flat__ordered__map_8h.html">flat_ordered_map.h</a></div><div class="ttdoc">The Flat Ordered Map Interface.</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
flat_priority_queue.h (dropdown)</summary>
<p></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define FLAT_PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="flat__priority__queue_8h.html">ccc/flat_priority_queue.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">int_cmp(<a class="code hl_struct" href="structccc__cmp.html">ccc_cmp</a> <span class="keyword">const</span> ints)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> lhs = *(<span class="keywordtype">int</span> *)ints.<a class="code hl_variable" href="structccc__cmp.html#a413783988aeb931cebe1ff2355147e49">user_type_lhs</a>;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> rhs = *(<span class="keywordtype">int</span> *)ints.<a class="code hl_variable" href="structccc__cmp.html#aad71faef58d3c2d057d2f2953372f32f">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordflow">return</span> (lhs &gt; rhs) - (lhs &lt; rhs);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* In place O(n) time O(1) space partial sort. */</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> heap[20] = {12, 61, -39, 76, 48, -93, -77, -81, 35, 21,</div>
<div class="line">                    -3, 90, 20,  27, 97, -22, -20, -19, 70, 76};</div>
<div class="line">    <span class="comment">/* Heapify existing array of values, with capacity, size one less than</span></div>
<div class="line"><span class="comment">       capacity for swap space, min priority queue, no allocation, no aux. */</span></div>
<div class="line">    flat_priority_queue pq = fpq_heapify_init(</div>
<div class="line">        heap, (<span class="keyword">sizeof</span>(heap) / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)), 19, <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, NULL, int_cmp, NULL);</div>
<div class="line">    (void)fpq_update_w(&amp;pq, &amp;heap[5], { heap[5] -= 4; });</div>
<div class="line">    <span class="keywordtype">int</span> prev = *((<span class="keywordtype">int</span> *)front(&amp;pq));</div>
<div class="line">    (void)pop(&amp;pq);</div>
<div class="line">    <span class="keywordflow">while</span> (!is_empty(&amp;pq))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> cur = *((<span class="keywordtype">int</span> *)front(&amp;pq));</div>
<div class="line">        (void)pop(&amp;pq);</div>
<div class="line">        assert(cur &gt;= prev);</div>
<div class="line">        prev = cur;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aflat__priority__queue_8h_html"><div class="ttname"><a href="flat__priority__queue_8h.html">flat_priority_queue.h</a></div><div class="ttdoc">The Flat Priority Queue Interface.</div></div>
<div class="ttc" id="atypes_8h_html_a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8"><div class="ttname"><a href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a></div><div class="ttdeci">@ CCC_LES</div><div class="ttdef"><b>Definition:</b> types.h:82</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
flat_realtime_ordered_map.h (dropdown)</summary>
<p>An ordered map with strict runtime bounds implemented in an array with indices tracking the tree structure.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define FLAT_REALTIME_ORDERED_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TYPES_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="flat__realtime__ordered__map_8h.html">ccc/flat_realtime_ordered_map.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>kval</div>
<div class="line">{</div>
<div class="line">    fromap_elem elem;</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">kval_cmp(<a class="code hl_struct" href="structccc__key__cmp.html">ccc_key_cmp</a> <span class="keyword">const</span> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>kval const *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a1378c81c5089d815ce1d61090bd391c4">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> key_lhs = *((<span class="keywordtype">int</span> *)cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a6077551b8a72a5149f78b81f3cb90951">key_lhs</a>);</div>
<div class="line">    <span class="keywordflow">return</span> (key_lhs &gt; rhs-&gt;key) - (key_lhs &lt; rhs-&gt;key);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* stack array of 25 elements with one slot for sentinel, intrusive field</span></div>
<div class="line"><span class="comment">       named elem, key field named key, no allocation permission, key comparison</span></div>
<div class="line"><span class="comment">       function, no aux data. */</span></div>
<div class="line">    flat_realtime_ordered_map s</div>
<div class="line">        = frm_init((<span class="keyword">struct</span> kval[26]){}, 26, elem, key, NULL, kval_cmp, NULL);</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> num_nodes = 25;</div>
<div class="line">    <span class="comment">/* 0, 5, 10, 15, 20, 25, 30, 35,... 120 */</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, <span class="keywordtype">id</span> = 0; i &lt; num_nodes; ++i, <span class="keywordtype">id</span> += 5)</div>
<div class="line">    {</div>
<div class="line">        (void)insert_or_assign(&amp;s, &amp;(<span class="keyword">struct</span> kval){.key = id, .val = i}.elem);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* This should be the following range [6,44). 6 should raise to</span></div>
<div class="line"><span class="comment">       next value not less than 6, 10 and 44 should be the first</span></div>
<div class="line"><span class="comment">       value greater than 44, 45. */</span></div>
<div class="line">    <span class="keywordtype">int</span> range_keys[8] = {10, 15, 20, 25, 30, 35, 40, 45};</div>
<div class="line">    range r = equal_range(&amp;s, &amp;(<span class="keywordtype">int</span>){6}, &amp;(int){44});</div>
<div class="line">    <span class="keywordtype">int</span> index = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">struct</span> kval *i = begin_range(&amp;r); i != end_range(&amp;r);</div>
<div class="line">         i = next(&amp;s, &amp;i-&gt;elem))</div>
<div class="line">    {</div>
<div class="line">        assert(i-&gt;key == range_keys[index]);</div>
<div class="line">        ++index;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* This should be the following range [119,84). 119 should be</span></div>
<div class="line"><span class="comment">       dropped to first value not greater than 119 and last should</span></div>
<div class="line"><span class="comment">       be dropped to first value less than 84. */</span></div>
<div class="line">    <span class="keywordtype">int</span> rrange_keys[8] = {115, 110, 105, 100, 95, 90, 85, 80};</div>
<div class="line">    rrange rr = equal_rrange(&amp;s, &amp;(<span class="keywordtype">int</span>){119}, &amp;(int){84});</div>
<div class="line">    index = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">struct</span> kval *i = rbegin_rrange(&amp;rr); i != rend_rrange(&amp;rr);</div>
<div class="line">         i = rnext(&amp;s, &amp;i-&gt;elem))</div>
<div class="line">    {</div>
<div class="line">        assert(i-&gt;key == rrange_keys[index]);</div>
<div class="line">        ++index;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aflat__realtime__ordered__map_8h_html"><div class="ttname"><a href="flat__realtime__ordered__map_8h.html">flat_realtime_ordered_map.h</a></div><div class="ttdoc">The Flat Realtime Ordered Map Interface.</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
ordered_map.h (dropdown)</summary>
<p>A pointer stable ordered map that stores unique keys, implemented with a self-optimizing tree structure.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define ORDERED_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ordered__map_8h.html">ccc/ordered_map.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>name</div>
<div class="line">{</div>
<div class="line">    omap_elem e;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">kval_cmp(<a class="code hl_struct" href="structccc__key__cmp.html">ccc_key_cmp</a> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *<span class="keyword">const</span> key = *(<span class="keywordtype">char</span> **)cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a6077551b8a72a5149f78b81f3cb90951">key_lhs</a>;</div>
<div class="line">    <span class="keyword">struct</span> name <span class="keyword">const</span> *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a1378c81c5089d815ce1d61090bd391c4">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> res = strcmp(key, rhs-&gt;name);</div>
<div class="line">    <span class="keywordflow">if</span> (res == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a0ab42c7e0b59a46006cbb959269db825">CCC_EQL</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (res &lt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a60a4aec1f589eaad4a9e922d90501dce">CCC_GRT</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>name nodes[5];</div>
<div class="line">    <span class="comment">/* ordered_map named om, stores struct name, intrusive field e, key field</span></div>
<div class="line"><span class="comment">       name, no allocation permission, comparison fn, no aux */</span></div>
<div class="line">    ordered_map om = om_init(om, <span class="keyword">struct</span> name, e, name, NULL, kval_cmp, NULL);</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *<span class="keyword">const</span> sorted_names[5]</div>
<div class="line">        = {<span class="stringliteral">&quot;Ferris&quot;</span>, <span class="stringliteral">&quot;Glenda&quot;</span>, <span class="stringliteral">&quot;Rocky&quot;</span>, <span class="stringliteral">&quot;Tux&quot;</span>, <span class="stringliteral">&quot;Ziggy&quot;</span>};</div>
<div class="line">    <span class="keywordtype">size_t</span> <span class="keyword">const</span> size = <span class="keyword">sizeof</span>(sorted_names) / <span class="keyword">sizeof</span>(sorted_names[0]);</div>
<div class="line">    <span class="keywordtype">size_t</span> j = 7 % size;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; size; ++i, j = (j + 7) % size)</div>
<div class="line">    {</div>
<div class="line">        nodes[size(&amp;om)].name = sorted_names[j];</div>
<div class="line">        <a class="code hl_typedef" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> e = insert_or_assign(&amp;om, &amp;nodes[size(&amp;om)].e);</div>
<div class="line">        assert(!insert_error(&amp;e) &amp;&amp; !occupied(&amp;e));</div>
<div class="line">    }</div>
<div class="line">    j = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">struct</span> name <span class="keyword">const</span> *n = begin(&amp;om); n != end(&amp;om); n = next(&amp;om, &amp;n-&gt;e))</div>
<div class="line">    {</div>
<div class="line">        assert(n-&gt;name == sorted_names[j]);</div>
<div class="line">        assert(strcmp(n-&gt;name, sorted_names[j]) == 0);</div>
<div class="line">        ++j;</div>
<div class="line">    }</div>
<div class="line">    assert(size(&amp;om) == size);</div>
<div class="line">    <a class="code hl_typedef" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> e = try_insert(&amp;om, &amp;(<span class="keyword">struct</span> name){.name = <span class="stringliteral">&quot;Ferris&quot;</span>}.e);</div>
<div class="line">    assert(size(&amp;om) == size);</div>
<div class="line">    assert(occupied(&amp;e));</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aordered__map_8h_html"><div class="ttname"><a href="ordered__map_8h.html">ordered_map.h</a></div><div class="ttdoc">The Ordered Map Interface.</div></div>
<div class="ttc" id="atypes_8h_html_a70feefd55fafc84e06d2f2a1dfd4f389"><div class="ttname"><a href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a></div><div class="ttdeci">union ccc_entry_ ccc_entry</div><div class="ttdoc">An Occupied or Vacant position in a searchable container.</div><div class="ttdef"><b>Definition:</b> types.h:43</div></div>
<div class="ttc" id="atypes_8h_html_a9958f3004414182c457c71289303ae57a0ab42c7e0b59a46006cbb959269db825"><div class="ttname"><a href="types_8h.html#a9958f3004414182c457c71289303ae57a0ab42c7e0b59a46006cbb959269db825">CCC_EQL</a></div><div class="ttdeci">@ CCC_EQL</div><div class="ttdef"><b>Definition:</b> types.h:84</div></div>
<div class="ttc" id="atypes_8h_html_a9958f3004414182c457c71289303ae57a60a4aec1f589eaad4a9e922d90501dce"><div class="ttname"><a href="types_8h.html#a9958f3004414182c457c71289303ae57a60a4aec1f589eaad4a9e922d90501dce">CCC_GRT</a></div><div class="ttdeci">@ CCC_GRT</div><div class="ttdef"><b>Definition:</b> types.h:86</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
ordered_multimap.h (dropdown)</summary>
<p>A pointer stable ordered map allowing storage of duplicate keys; searches and removals of duplicates will yield the oldest duplicate. An ordered multimap uses a self optimizing tree structures and is suitable for a priority queue if round robin fairness among duplicates is needed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define ORDERED_MULTIMAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ordered__multimap_8h.html">ccc/ordered_multimap.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>name</div>
<div class="line">{</div>
<div class="line">    ommap_elem e;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">kval_cmp(<a class="code hl_struct" href="structccc__key__cmp.html">ccc_key_cmp</a> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *<span class="keyword">const</span> key = *(<span class="keywordtype">char</span> **)cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a6077551b8a72a5149f78b81f3cb90951">key_lhs</a>;</div>
<div class="line">    <span class="keyword">struct</span> name <span class="keyword">const</span> *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a1378c81c5089d815ce1d61090bd391c4">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> res = strcmp(key, rhs-&gt;name);</div>
<div class="line">    <span class="keywordflow">if</span> (res == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a0ab42c7e0b59a46006cbb959269db825">CCC_EQL</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (res &lt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a60a4aec1f589eaad4a9e922d90501dce">CCC_GRT</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>name nodes[10];</div>
<div class="line">    <span class="comment">/* ordered_map named om, stores struct name, intrusive field e, key field</span></div>
<div class="line"><span class="comment">       name, no allocation permission, comparison fn, no aux */</span></div>
<div class="line">    ordered_multimap om</div>
<div class="line">        = omm_init(om, <span class="keyword">struct</span> name, e, name, NULL, kval_cmp, NULL);</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *<span class="keyword">const</span> sorted_repeat_names[10]</div>
<div class="line">        = {<span class="stringliteral">&quot;Ferris&quot;</span>, <span class="stringliteral">&quot;Ferris&quot;</span>, <span class="stringliteral">&quot;Glenda&quot;</span>, <span class="stringliteral">&quot;Glenda&quot;</span>, <span class="stringliteral">&quot;Rocky&quot;</span>,</div>
<div class="line">           <span class="stringliteral">&quot;Rocky&quot;</span>,  <span class="stringliteral">&quot;Tux&quot;</span>,    <span class="stringliteral">&quot;Tux&quot;</span>,    <span class="stringliteral">&quot;Ziggy&quot;</span>,  <span class="stringliteral">&quot;Ziggy&quot;</span>};</div>
<div class="line">    <span class="keywordtype">size_t</span> <span class="keyword">const</span> size</div>
<div class="line">        = <span class="keyword">sizeof</span>(sorted_repeat_names) / <span class="keyword">sizeof</span>(sorted_repeat_names[0]);</div>
<div class="line">    <span class="keywordtype">size_t</span> j = 11 % size;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; size; ++i, j = (j + 11) % size)</div>
<div class="line">    {</div>
<div class="line">        nodes[size(&amp;om)].name = sorted_repeat_names[j];</div>
<div class="line">        <a class="code hl_typedef" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> e = insert(&amp;om, &amp;nodes[size(&amp;om)].e);</div>
<div class="line">        assert(!insert_error(&amp;e));</div>
<div class="line">    };</div>
<div class="line">    j = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">struct</span> name *prev = rbegin(&amp;om), *n = rnext(&amp;om, &amp;prev-&gt;e);</div>
<div class="line">         n != rend(&amp;om); n = rnext(&amp;om, &amp;n-&gt;e), n = rnext(&amp;om, &amp;n-&gt;e),</div>
<div class="line">                     prev = rnext(&amp;om, &amp;prev-&gt;e), prev = rnext(&amp;om, &amp;prev-&gt;e))</div>
<div class="line">    {</div>
<div class="line">        assert(strcmp(n-&gt;name, sorted_repeat_names[j]) == 0);</div>
<div class="line">        assert(strcmp(n-&gt;name, prev-&gt;name) == 0);</div>
<div class="line">        j += 2;</div>
<div class="line">    }</div>
<div class="line">    assert(size(&amp;om) == size);</div>
<div class="line">    <a class="code hl_typedef" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> e = insert(&amp;om, &amp;(<span class="keyword">struct</span> name){.name = <span class="stringliteral">&quot;Ferris&quot;</span>}.e);</div>
<div class="line">    assert(size(&amp;om) == size + 1);</div>
<div class="line">    assert(occupied(&amp;e));</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aordered__multimap_8h_html"><div class="ttname"><a href="ordered__multimap_8h.html">ordered_multimap.h</a></div><div class="ttdoc">The Ordered Multimap Interface.</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
priority_queue.h (dropdown)</summary>
<p>A pointer stable priority queue offering O(1) push and efficient decrease, increase, erase, and extract operations.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define PRIORITY_QUEUE_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TYPES_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="priority__queue_8h.html">ccc/priority_queue.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>val</div>
<div class="line">{</div>
<div class="line">    pq_elem elem;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">val_cmp(<a class="code hl_struct" href="structccc__cmp.html">ccc_cmp</a> <span class="keyword">const</span> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>val const *<span class="keyword">const</span> lhs = cmp.<a class="code hl_variable" href="structccc__cmp.html#a413783988aeb931cebe1ff2355147e49">user_type_lhs</a>;</div>
<div class="line">    <span class="keyword">struct </span>val const *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__cmp.html#aad71faef58d3c2d057d2f2953372f32f">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordflow">return</span> (lhs-&gt;val &gt; rhs-&gt;val) - (lhs-&gt;val &lt; rhs-&gt;val);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>val elems[5]</div>
<div class="line">        = {{.val = 3}, {.val = 3}, {.val = 7}, {.val = -1}, {.val = 5}};</div>
<div class="line">    priority_queue pq = pq_init(<span class="keyword">struct</span> val, elem, <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, NULL, val_cmp, NULL);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <span class="keyword">sizeof</span>(elems) / <span class="keyword">sizeof</span>(elems[0]); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>val const *<span class="keyword">const</span> v = push(&amp;pq, &amp;elems[i].elem);</div>
<div class="line">        assert(v &amp;&amp; v-&gt;val == elems[i].val);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <span class="keyword">const</span> decreased = pq_decrease_w(&amp;pq, &amp;elems[4].elem,</div>
<div class="line">                                         { elems[4].val = -99; });</div>
<div class="line">    assert(decreased);</div>
<div class="line">    <span class="keyword">struct </span>val const *<span class="keyword">const</span> v = front(&amp;pq);</div>
<div class="line">    assert(v-&gt;val == -99);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="apriority__queue_8h_html"><div class="ttname"><a href="priority__queue_8h.html">priority_queue.h</a></div><div class="ttdoc">The Priority Queue Interface.</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
realtime_ordered_map.h (dropdown)</summary>
<p>A pointer stable ordered map meeting strict O(lg N) runtime bounds for realtime applications.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define REALTIME_ORDERED_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TYPES_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="realtime__ordered__map_8h.html">ccc/realtime_ordered_map.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>kval</div>
<div class="line">{</div>
<div class="line">    romap_elem elem;</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">kval_cmp(<a class="code hl_struct" href="structccc__key__cmp.html">ccc_key_cmp</a> <span class="keyword">const</span> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>kval const *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a1378c81c5089d815ce1d61090bd391c4">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> key_lhs = *((<span class="keywordtype">int</span> *)cmp.<a class="code hl_variable" href="structccc__key__cmp.html#a6077551b8a72a5149f78b81f3cb90951">key_lhs</a>);</div>
<div class="line">    <span class="keywordflow">return</span> (key_lhs &gt; rhs-&gt;key) - (key_lhs &lt; rhs-&gt;key);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>kval elems[25];</div>
<div class="line">    <span class="comment">/* stack array of 25 elements with one slot for sentinel, intrusive field</span></div>
<div class="line"><span class="comment">       named elem, key field named key, no allocation permission, key comparison</span></div>
<div class="line"><span class="comment">       function, no aux data. */</span></div>
<div class="line">    realtime_ordered_map s</div>
<div class="line">        = rom_init(s, <span class="keyword">struct</span> kval, elem, key, NULL, kval_cmp, NULL);</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> num_nodes = 25;</div>
<div class="line">    <span class="comment">/* 0, 5, 10, 15, 20, 25, 30, 35,... 120 */</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, <span class="keywordtype">id</span> = 0; i &lt; num_nodes; ++i, <span class="keywordtype">id</span> += 5)</div>
<div class="line">    {</div>
<div class="line">        elems[i].key = id;</div>
<div class="line">        elems[i].val = i;</div>
<div class="line">        (void)insert_or_assign(&amp;s, &amp;elems[i].elem);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* This should be the following range [6,44). 6 should raise to</span></div>
<div class="line"><span class="comment">       next value not less than 6, 10 and 44 should be the first</span></div>
<div class="line"><span class="comment">       value greater than 44, 45. */</span></div>
<div class="line">    <span class="keywordtype">int</span> range_keys[8] = {10, 15, 20, 25, 30, 35, 40, 45};</div>
<div class="line">    range r = equal_range(&amp;s, &amp;(<span class="keywordtype">int</span>){6}, &amp;(int){44});</div>
<div class="line">    <span class="keywordtype">int</span> index = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">struct</span> kval *i = begin_range(&amp;r); i != end_range(&amp;r);</div>
<div class="line">         i = next(&amp;s, &amp;i-&gt;elem))</div>
<div class="line">    {</div>
<div class="line">        assert(i-&gt;key == range_keys[index]);</div>
<div class="line">        ++index;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* This should be the following range [119,84). 119 should be</span></div>
<div class="line"><span class="comment">       dropped to first value not greater than 119 and last should</span></div>
<div class="line"><span class="comment">       be dropped to first value less than 84. */</span></div>
<div class="line">    <span class="keywordtype">int</span> rrange_keys[8] = {115, 110, 105, 100, 95, 90, 85, 80};</div>
<div class="line">    rrange rr = equal_rrange(&amp;s, &amp;(<span class="keywordtype">int</span>){119}, &amp;(int){84});</div>
<div class="line">    index = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">struct</span> kval *i = rbegin_rrange(&amp;rr); i != rend_rrange(&amp;rr);</div>
<div class="line">         i = rnext(&amp;s, &amp;i-&gt;elem))</div>
<div class="line">    {</div>
<div class="line">        assert(i-&gt;key == rrange_keys[index]);</div>
<div class="line">        ++index;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="arealtime__ordered__map_8h_html"><div class="ttname"><a href="realtime__ordered__map_8h.html">realtime_ordered_map.h</a></div><div class="ttdoc">The Realtime Ordered Map Interface.</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
singly_linked_list.h (dropdown)</summary>
<p>A low overhead push-to-front container. When contiguity is not possible and the access pattern resembles a stack this is more-efficient than a doubly-linked list.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define SINGLY_LINKED_LIST_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="singly__linked__list_8h.html">ccc/singly_linked_list.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="traits_8h.html">ccc/traits.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>int_elem</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    sll_elem e;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">int_cmp(<a class="code hl_struct" href="structccc__cmp.html">ccc_cmp</a> <span class="keyword">const</span> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>int_elem const *<span class="keyword">const</span> lhs = cmp.<a class="code hl_variable" href="structccc__cmp.html#a413783988aeb931cebe1ff2355147e49">user_type_lhs</a>;</div>
<div class="line">    <span class="keyword">struct </span>int_elem const *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__cmp.html#aad71faef58d3c2d057d2f2953372f32f">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordflow">return</span> (lhs-&gt;i &gt; rhs-&gt;i) - (lhs-&gt;i &lt; rhs-&gt;i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* singly linked list l, list elem field e, no allocation permission,</span></div>
<div class="line"><span class="comment">       comparing integers, no auxiliary data. */</span></div>
<div class="line">    singly_linked_list l = sll_init(l, <span class="keyword">struct</span> int_elem, e, NULL, int_cmp, NULL);</div>
<div class="line">    <span class="keyword">struct </span>int_elem elems[3] = {{.i = 3}, {.i = 2}, {.i = 1}};</div>
<div class="line">    (void)push_front(&amp;l, &amp;elems[0].e);</div>
<div class="line">    (void)push_front(&amp;l, &amp;elems[1].e);</div>
<div class="line">    (void)push_front(&amp;l, &amp;elems[2].e);</div>
<div class="line">    <span class="keyword">struct </span>int_elem const *i = front(&amp;l);</div>
<div class="line">    assert(i-&gt;i == 1);</div>
<div class="line">    pop_front(&amp;l);</div>
<div class="line">    i = front(&amp;l);</div>
<div class="line">    assert(i-&gt;i == 2);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="asingly__linked__list_8h_html"><div class="ttname"><a href="singly__linked__list_8h.html">singly_linked_list.h</a></div><div class="ttdoc">The Singly Linked List Interface.</div></div>
</div><!-- fragment --><p></p>
</details>
<h1><a class="anchor" id="autotoc_md4"></a>
Features</h1>
<ul>
<li>Intrusive and non-intrusive containers.</li>
<li>Non-allocating container options.</li>
<li>No <code>container_of</code> macro required of the user to get to their type after a function call.</li>
<li>Rust's Entry API for associative containers with C and C++ influences.</li>
<li>Opt-in macros for more succinct insertion and in place modifications (see "closures" in the <a href="https://agl-alexglopez.github.io/ccc/flat__hash__map_8h.html">and_modify_w</a> interface for associative containers).</li>
<li>Container Traits implemented with C <code>_Generic</code> capabilities.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Intrusive and Non-Intrusive Containers</h2>
<p>Currently, all associative containers ask the user to store an element in their type. This means wrapping an element in a struct such as this type found in <code>samples/graph.c</code> for the flat hash map.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>path_backtrack_cell</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="flat__hash__map_8h.html#ada2d334ae54ac456f5ff1a37ac546994">ccc_fhmap_elem</a> elem;</div>
<div class="line">    <span class="keyword">struct </span>point current;</div>
<div class="line">    <span class="keyword">struct </span>point parent;</div>
<div class="line">};</div>
<div class="ttc" id="aflat__hash__map_8h_html_ada2d334ae54ac456f5ff1a37ac546994"><div class="ttname"><a href="flat__hash__map_8h.html#ada2d334ae54ac456f5ff1a37ac546994">ccc_fhmap_elem</a></div><div class="ttdeci">struct ccc_fhmap_elem_ ccc_fhmap_elem</div><div class="ttdoc">An intrusive element for a user provided type.</div><div class="ttdef"><b>Definition:</b> flat_hash_map.h:45</div></div>
</div><!-- fragment --><p>The interface may then ask for a handle to this type for certain operations. For example, a flat hash map we have the following interface for <code>try_insert</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> <a class="code hl_function" href="flat__hash__map_8h.html#aba9e915d0b006d759c55689c27731829">ccc_fhm_try_insert</a>(<a class="code hl_typedef" href="flat__hash__map_8h.html#af8251d1f96c8a10e8ff2b20d7f117447">ccc_flat_hash_map</a> *h,</div>
<div class="line">                             <a class="code hl_typedef" href="flat__hash__map_8h.html#ada2d334ae54ac456f5ff1a37ac546994">ccc_fhmap_elem</a> *key_val_handle);</div>
<div class="ttc" id="aflat__hash__map_8h_html_aba9e915d0b006d759c55689c27731829"><div class="ttname"><a href="flat__hash__map_8h.html#aba9e915d0b006d759c55689c27731829">ccc_fhm_try_insert</a></div><div class="ttdeci">ccc_entry ccc_fhm_try_insert(ccc_flat_hash_map *h, ccc_fhmap_elem *key_val_handle)</div><div class="ttdoc">Attempts to insert the key value wrapping key_val_handle.</div></div>
</div><!-- fragment --><p>Here, the user is trying to insert a new key and value into the hash map which in the above example would be a <code>struct path_backtrack_cell</code> with the <code>current</code> and <code>parent</code> fields set appropriately.</p>
<p>Non-Intrusive containers exist when a flat container can operate without such help from the user. The <code>flat_priority_queue</code> is a good example of this. When initializing we give it the following information.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ccc_fpq_init(mem_ptr, capacity, cmp_order, alloc_fn, cmp_fn, aux_data) \</span></div>
<div class="line"><span class="preprocessor">    ccc_impl_fpq_init(mem_ptr, capacity, cmp_order, alloc_fn, cmp_fn, aux_data)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* For example: */</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="flat__priority__queue_8h.html#a8ed534b783c08382f5e3cd0456a1d72c">ccc_flat_priority_queue</a> fpq</div>
<div class="line">    = <a class="code hl_define" href="flat__priority__queue_8h.html#aef56a4bcfd5a33aeb767c177d43c51bf">ccc_fpq_init</a>((<span class="keywordtype">int</span>[40]){}, 40, <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, NULL, int_cmp, NULL);</div>
<div class="ttc" id="aflat__priority__queue_8h_html_a8ed534b783c08382f5e3cd0456a1d72c"><div class="ttname"><a href="flat__priority__queue_8h.html#a8ed534b783c08382f5e3cd0456a1d72c">ccc_flat_priority_queue</a></div><div class="ttdeci">struct ccc_fpq_ ccc_flat_priority_queue</div><div class="ttdoc">A container offering direct storage and sorting of user data by heap order.</div><div class="ttdef"><b>Definition:</b> flat_priority_queue.h:33</div></div>
<div class="ttc" id="aflat__priority__queue_8h_html_aef56a4bcfd5a33aeb767c177d43c51bf"><div class="ttname"><a href="flat__priority__queue_8h.html#aef56a4bcfd5a33aeb767c177d43c51bf">ccc_fpq_init</a></div><div class="ttdeci">#define ccc_fpq_init(mem_ptr, capacity, cmp_order, alloc_fn, cmp_fn, aux_data)</div><div class="ttdoc">Initialize a fpq as a min or max heap.</div><div class="ttdef"><b>Definition:</b> flat_priority_queue.h:48</div></div>
</div><!-- fragment --><p>Here a small min priority queue of integers with a maximum capacity of 40 has been allocated on the stack with no allocation permission and no auxiliary data needed. As long as the flat priority queue knows the type upon initialization no intrusive elements are needed. We could have also initialized this container as empty if we provide an allocation function (see allocation for more on allocation permission).</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="flat__priority__queue_8h.html#a8ed534b783c08382f5e3cd0456a1d72c">ccc_flat_priority_queue</a> fpq</div>
<div class="line">    = <a class="code hl_define" href="flat__priority__queue_8h.html#aef56a4bcfd5a33aeb767c177d43c51bf">ccc_fpq_init</a>((<span class="keywordtype">int</span> *)NULL, 0, <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, std_alloc, int_cmp, NULL);</div>
</div><!-- fragment --><p>Notice that we need to help the container by casting to the type we are storing. The interface then looks like this.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *<a class="code hl_function" href="flat__priority__queue_8h.html#af3629428e2a5117d810852fc70c283c8">ccc_fpq_push</a>(<a class="code hl_typedef" href="flat__priority__queue_8h.html#a8ed534b783c08382f5e3cd0456a1d72c">ccc_flat_priority_queue</a> *fpq, <span class="keywordtype">void</span> <span class="keyword">const</span> *e);</div>
<div class="ttc" id="aflat__priority__queue_8h_html_af3629428e2a5117d810852fc70c283c8"><div class="ttname"><a href="flat__priority__queue_8h.html#af3629428e2a5117d810852fc70c283c8">ccc_fpq_push</a></div><div class="ttdeci">void * ccc_fpq_push(ccc_flat_priority_queue *fpq, void const *e)</div><div class="ttdoc">Pushes element pointed to at e into fpq. O(lgN).</div></div>
</div><!-- fragment --><p>The element <code>e</code> here is just a generic reference to whatever type the user stores in the container.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Non-Allocating Containers</h2>
<p>As was mentioned in the previous section, all containers can be forbidden from allocating memory. In the flat priority queue example we had this initialization.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="flat__priority__queue_8h.html#a8ed534b783c08382f5e3cd0456a1d72c">ccc_flat_priority_queue</a> fpq</div>
<div class="line">    = <a class="code hl_define" href="flat__priority__queue_8h.html#aef56a4bcfd5a33aeb767c177d43c51bf">ccc_fpq_init</a>((<span class="keywordtype">int</span>[40]){}, 40, <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>, NULL, int_cmp, NULL);</div>
</div><!-- fragment --><p>For flat containers, fixed capacity is straightforward. Once space runs out, further insertion functions will fail and report that failure in different ways depending on the function used.</p>
<p>For non-flat containers that can't assume they are stored contiguously in memory, the initialization looks like this when allocation is prohibited.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>id_val</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> e;</div>
<div class="line">    <span class="keywordtype">int</span> id;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> dll</div>
<div class="line">    = <a class="code hl_define" href="doubly__linked__list_8h.html#a50ff4422f52bc1a5c2c926dc88a01e3e">ccc_dll_init</a>(dll, <span class="keyword">struct</span> id_val, e, NULL, val_cmp, NULL);</div>
<div class="ttc" id="adoubly__linked__list_8h_html_a50ff4422f52bc1a5c2c926dc88a01e3e"><div class="ttname"><a href="doubly__linked__list_8h.html#a50ff4422f52bc1a5c2c926dc88a01e3e">ccc_dll_init</a></div><div class="ttdeci">#define ccc_dll_init(list_name, struct_name, list_elem_field, alloc_fn, cmp_fn, aux_data)</div><div class="ttdoc">Initialize a doubly linked list with its l-value name, type containing the dll elems,...</div><div class="ttdef"><b>Definition:</b> doubly_linked_list.h:67</div></div>
<div class="ttc" id="adoubly__linked__list_8h_html_aaceb2c981b30f064750203fcb938e774"><div class="ttname"><a href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a></div><div class="ttdeci">struct ccc_dll_ ccc_doubly_linked_list</div><div class="ttdoc">A container offering bidirectional, insert, removal, and iteration.</div><div class="ttdef"><b>Definition:</b> doubly_linked_list.h:41</div></div>
<div class="ttc" id="adoubly__linked__list_8h_html_ae6ab05fc0a5ac5f5d8ff31103209edf0"><div class="ttname"><a href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a></div><div class="ttdeci">struct ccc_dll_elem_ ccc_dll_elem</div><div class="ttdoc">A doubly linked list intrusive element to embedded in a user type.</div><div class="ttdef"><b>Definition:</b> doubly_linked_list.h:51</div></div>
</div><!-- fragment --><p>All interface functions now expect the memory containing the intrusive elements to exist with the appropriate scope and lifetime for the programmer's needs.</p>
<div class="fragment"><div class="line"><span class="comment">/* !WARNING: THIS IS A BAD IDEA FOR DEMONSTRATION PURPOSES! */</span></div>
<div class="line"><span class="keywordtype">void</span> push_three(<a class="code hl_typedef" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> *<span class="keyword">const</span> dll)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>id_val v0 = {};</div>
<div class="line">    <span class="keyword">struct </span>id_val *v = push_back(dll, &amp;v0.e);</div>
<div class="line">    assert(v == &amp;v0);</div>
<div class="line">    <span class="keyword">struct </span>id_val v1 = {.id = 1, .val = 1};</div>
<div class="line">    v = push_back(dll, &amp;v1.e);</div>
<div class="line">    assert(v == &amp;v1);</div>
<div class="line">    <span class="keyword">struct </span>id_val v2 = {.id = 2, .val = 2};</div>
<div class="line">    v = push_back(dll, &amp;v2.e);</div>
<div class="line">    assert(v == &amp;v2);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, the container pushes stack allocated structs directly into the list. The container has not been given allocation permission so it assumes the memory it is given has the appropriate lifetime for the programmer's needs. When this function ends, that memory is invalid because its scope and lifetime has ended. Using <code>malloc</code> in this case would be the traditional approach, but there are a variety of ways a programmer can control scope and lifetime. This library does not prescribe any specific strategy to managing memory when allocation is prohibited. For example compositions of allocating and non-allocating containers, see the <code>samples/</code>.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
No &lt;tt&gt;container_of&lt;/tt&gt; Macros</h2>
<p>Traditionally, intrusive containers provide the following macro.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#define list_entry(ptr, type, member) \</span></div>
<div class="line"><span class="preprocessor">    container_of(ptr, type, member)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* A provided function by the container. */</span></div>
<div class="line"><span class="keyword">struct </span>list_elem *list_front(list *l);</div>
</div><!-- fragment --><p>Then, the user code looks like this.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>id</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> id;</div>
<div class="line">    <span class="keyword">struct </span>list_elem id_elem;</div>
<div class="line">};</div>
<div class="line"><span class="comment">/* ...  */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>list id_list = LIST_INIT(id_list);</div>
<div class="line"><span class="comment">/* ...  */</span></div>
<div class="line"><span class="keyword">struct </span>id *front = list_entry(list_front(&amp;id_list), <span class="keyword">struct</span> <span class="keywordtype">id</span>, id_elem);</div>
<div class="line"><span class="comment">/* Or when writing a comparison callback. */</span></div>
<div class="line"><span class="keywordtype">bool</span></div>
<div class="line">is_id_a_less(<span class="keyword">struct</span> list_elem <span class="keyword">const</span> *<span class="keyword">const</span> a,</div>
<div class="line">             <span class="keyword">struct</span> list_elem <span class="keyword">const</span> *<span class="keyword">const</span> b, <span class="keywordtype">void</span> *<span class="keyword">const</span> aux)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>id const *<span class="keyword">const</span> a_ = list_entry(a, <span class="keyword">struct</span> <span class="keywordtype">id</span>, id_elem);</div>
<div class="line">    <span class="keyword">struct </span>id const *<span class="keyword">const</span> b_ = list_entry(b, <span class="keyword">struct</span> <span class="keywordtype">id</span>, id_elem);</div>
<div class="line">    <span class="keywordflow">return</span> a_-&gt;id &lt; b_-&gt;id;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, it may seem manageable to use such a macro, but it is required at every location in the code where the user type is needed. The opportunity for bugs in entering the type or field name grows the more the macro is used. It is better to take care of this step for the user and present a cleaner interface.</p>
<p>Here is the same list example in the C Container Collection.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>id</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> id;</div>
<div class="line">    <a class="code hl_typedef" href="doubly__linked__list_8h.html#ae6ab05fc0a5ac5f5d8ff31103209edf0">ccc_dll_elem</a> id_elem;</div>
<div class="line">};</div>
<div class="line"><span class="comment">/* ... */</span></div>
<div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="doubly__linked__list_8h.html#aaceb2c981b30f064750203fcb938e774">ccc_doubly_linked_list</a> id_list</div>
<div class="line">    = <a class="code hl_define" href="doubly__linked__list_8h.html#a50ff4422f52bc1a5c2c926dc88a01e3e">ccc_dll_init</a>(id_list, <span class="keyword">struct</span> <span class="keywordtype">id</span>, id_elem, NULL, id_cmp, NULL);</div>
<div class="line"><span class="comment">/* ... */</span></div>
<div class="line"><span class="keyword">struct </span>id *front = <a class="code hl_function" href="doubly__linked__list_8h.html#a4f7f1c337174a8c19091ab34d25587ff">ccc_dll_front</a>(&amp;id_list);</div>
<div class="line"><span class="keyword">struct </span>id *new_id = generate_id();</div>
<div class="line"><span class="keyword">struct </span>id *new_front = <a class="code hl_function" href="doubly__linked__list_8h.html#ac21312b92a33769a08c7e9cd334800a7">ccc_dll_push_front</a>(&amp;id_list, &amp;new_id-&gt;id_elem);</div>
<div class="line"><span class="comment">/* Or when writing a comparison callback. */</span></div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a9958f3004414182c457c71289303ae57">ccc_threeway_cmp</a></div>
<div class="line">id_cmp(<a class="code hl_struct" href="structccc__cmp.html">ccc_cmp</a> <span class="keyword">const</span> cmp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>id const *<span class="keyword">const</span> lhs = cmp.<a class="code hl_variable" href="structccc__cmp.html#a413783988aeb931cebe1ff2355147e49">user_type_lhs</a>;</div>
<div class="line">    <span class="keyword">struct </span>id const *<span class="keyword">const</span> rhs = cmp.<a class="code hl_variable" href="structccc__cmp.html#aad71faef58d3c2d057d2f2953372f32f">user_type_rhs</a>;</div>
<div class="line">    <span class="keywordflow">return</span> (lhs-&gt;id &gt; rhs-&gt;id) - (lhs-&gt;id &lt; rhs-&gt;id);</div>
<div class="line">}</div>
<div class="ttc" id="adoubly__linked__list_8h_html_a4f7f1c337174a8c19091ab34d25587ff"><div class="ttname"><a href="doubly__linked__list_8h.html#a4f7f1c337174a8c19091ab34d25587ff">ccc_dll_front</a></div><div class="ttdeci">void * ccc_dll_front(ccc_doubly_linked_list const *l)</div><div class="ttdoc">Returns the user type at the front of the list. O(1).</div></div>
<div class="ttc" id="adoubly__linked__list_8h_html_ac21312b92a33769a08c7e9cd334800a7"><div class="ttname"><a href="doubly__linked__list_8h.html#ac21312b92a33769a08c7e9cd334800a7">ccc_dll_push_front</a></div><div class="ttdeci">void * ccc_dll_push_front(ccc_doubly_linked_list *l, ccc_dll_elem *elem)</div><div class="ttdoc">Push user type wrapping elem to the front of the list. O(1).</div></div>
</div><!-- fragment --><p>Internally the containers will remember the offsets of the provided elements within the user struct wrapping the intruder. Then, the contract of the interface is simpler: provide a handle to the container and receive your type in return. The user takes on less complexity overall by providing a slightly more detailed initialization.</p>
<p>Composing multiple containers with this approach is also possible. Consider the following struct from <code>samples/graph.c</code> used to run Dijkstra's algorithm.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>dijkstra_vertex</div>
<div class="line">{</div>
<div class="line">    romap_elem path_elem;</div>
<div class="line">    pq_elem pq_elem;</div>
<div class="line">    <span class="keywordtype">int</span> dist;</div>
<div class="line">    <span class="keywordtype">char</span> cur_name;</div>
<div class="line">    <span class="keywordtype">char</span> prev_name;</div>
<div class="line">};</div>
<div class="line"><span class="comment">/* ... Later Initialization After Memory is Prepared ... */</span></div>
<div class="line">realtime_ordered_map path_map = rom_init(path_map, <span class="keyword">struct</span> dijkstra_vertex,</div>
<div class="line">    path_elem, cur_name, arena_alloc, cmp_prev_vertices, &amp;bump_arena);</div>
<div class="line">priority_queue costs_pq = pq_init(<span class="keyword">struct</span> dijkstra_vertex, pq_elem, <a class="code hl_enumvalue" href="types_8h.html#a9958f3004414182c457c71289303ae57a813ea7b9e526748af7efa9a83da12ee8">CCC_LES</a>,</div>
<div class="line">    NULL, cmp_pq_costs, NULL);</div>
<div class="line"><span class="comment">/*... Steps to Prepare to Run the Algorithm ...*/</span></div>
<div class="line"><span class="keywordflow">while</span> (!is_empty(&amp;costs_pq))</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>dijkstra_vertex *cur = front(&amp;costs_pq);</div>
<div class="line">    (void)pop(&amp;costs_pq);</div>
<div class="line">    <span class="comment">/* ... Check for Stopping Condition Then Continue ... */</span></div>
<div class="line">    <span class="keyword">struct </span>node const *<span class="keyword">const</span> edges = vertex_at(graph, cur-&gt;cur_name)-&gt;edges;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MAX_DEGREE &amp;&amp; edges[i].name; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>dijkstra_vertex *next</div>
<div class="line">            = get_key_val(&amp;path_map, &amp;edges[i].name);</div>
<div class="line">        <span class="keywordtype">int</span> alt = cur-&gt;dist + edges[i].cost;</div>
<div class="line">        <span class="keywordflow">if</span> (alt &lt; next-&gt;dist)</div>
<div class="line">        {</div>
<div class="line">            pq_decrease_w(&amp;costs_pq, &amp;next-&gt;pq_elem, {</div>
<div class="line">                next-&gt;prev_name = cur-&gt;cur_name;</div>
<div class="line">                next-&gt;dist = alt;</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment">/* ... Rebuild Shortest Path etc... */</span></div>
</div><!-- fragment --><p>One conceptual element, a <code>dijkstra_vertex</code>, is part of two containers, a map and a priority queue. The priority queue piggy backs of the memory controlled by the map so that we always have access to all vertices while the algorithm runs. An already complex algorithm is not cluttered by further steps to accommodate macros.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Rust's Entry Interface</h2>
<p>Rust has solid interfaces for associative containers, largely due to the Entry API/Interface. In the C Container Collection the core of all associative containers is inspired by the Entry Interface (these versions are found in <code><a class="el" href="traits_8h.html" title="The C Container Collection Traits Interface.">ccc/traits.h</a></code> but specific names, behaviors, and parameters can be read in each container's header).</p>
<ul>
<li><code><a class="el" href="traits_8h.html#aa6dc7577080398fd18623d2c6a464723" title="Obtain a container specific entry for the Entry Interface.">ccc_entry(container_ptr, key_ptr...)</a></code> - Obtains an entry, a view into an Occupied or Vacant user type stored in the container.</li>
<li><code><a class="el" href="traits_8h.html#ab25eca1e59257aab34f67308a523553c" title="Modify an entry if Occupied.">ccc_and_modify(entry_ptr, mod_fn)</a></code> - Modify an occupied entry with a callback.</li>
<li><code><a class="el" href="traits_8h.html#a25c5c848da545831e1efa54645aae2dd" title="Modify an entry if Occupied.">ccc_and_modify_aux(entry_ptr, mod_fn, aux_args)</a></code> - Modify an Occupied entry with a callback that requires auxiliary data.</li>
<li><code><a class="el" href="traits_8h.html#a1c157dfada3fb8d3beddcab00d2fade4" title="Insert new element if the entry is Vacant.">ccc_or_insert(entry_ptr, or_insert_args)</a></code> - Insert a default key value if Vacant or return the Occupied entry.</li>
<li><code><a class="el" href="traits_8h.html#aa79106d83ff5343b2b3aff707a9f5447" title="Insert new element or overwrite old element.">ccc_insert_entry(entry_ptr, insert_entry_args)</a></code> - Invariantly insert a new key value, overwriting an Occupied entry if needed.</li>
<li><code><a class="el" href="traits_8h.html#a3157c1ad2dc111b73f8018bd4fdbc7a4" title="Remove the element if the entry is Occupied.">ccc_remove_entry(entry_ptr)</a></code> - Remove an Occupied entry from the container or do nothing.</li>
</ul>
<p>Other Rust Interface functions like <code>get_key_val</code>, <code>insert</code>, and <code>remove</code> are included and can provide information about previous values stored in the container.</p>
<p>Each container offers it's own C version of "closures" for the <code>and_modify_w</code> macro, short for and modify "with". Here is an example from the <code>samples/words.c</code> program.</p>
<ul>
<li><code>and_modify_w(flat_ordered_map_entry_ptr, type_name, closure_over_T...)</code> - Run code in <code>closure_over_T</code> on the stored user type <code>T</code>.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    str_ofs str_arena_offset;</div>
<div class="line">    <span class="keywordtype">int</span> cnt;</div>
<div class="line">    fomap_elem e;</div>
<div class="line">} word;</div>
<div class="line"><span class="comment">/* Increment a found word or insert a default count of 1. */</span></div>
<div class="line">word *w =</div>
<div class="line">fom_or_insert_w(</div>
<div class="line">    fom_and_modify_w(entry_r(&amp;fom, &amp;ofs), word, { T-&gt;cnt++; }),</div>
<div class="line">    (word){.str_arena_offset = ofs, .cnt = 1}</div>
<div class="line">);</div>
</div><!-- fragment --><p>This is possible because of the details discussed in the previous section. Containers can always provide the user type stored in the container directly. However, there are other options to achieve the same result.</p>
<p>Some C++ associative container interfaces have also been adapted to the Entry Interface.</p>
<ul>
<li><code><a class="el" href="traits_8h.html#a7e4421e251272e1eb19a8b0c8e40d7c2" title="Insert an element if the entry is Vacant.">ccc_try_insert(container_ptr, try_insert_args)</a></code> - Inserts a new element if none was present and reports if a previous entry existed.</li>
<li><code><a class="el" href="traits_8h.html#af535d3d2b63e8c68efb85e5c54bb0f77" title="Insert an element or overwrite the Occupied entry.">ccc_insert_or_assign(container_ptr, insert_or_assign_args)</a></code> - Inserts a new element invariantly and reports if a previous entry existed.</li>
</ul>
<p>Many other containers fall back to C++ style interfaces when it makes sense to do so.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Lazy Evaluation</h3>
<p>Many of the above functions come with an optional macro variant. For example, the <code>or_insert</code> function for associative containers will come with an <code>or_insert_w</code> variant, short for or insert "with." The word "with" in this context means a direct r-value.</p>
<p>Here is an example for generating a maze with Prim's algorithm in the <code>samples/maze.c</code> sample.</p>
<p>The functional version.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>point const next = {.r = c-&gt;cell.r + dir_offsets[i].r,</div>
<div class="line">                           .c = c-&gt;cell.c + dir_offsets[i].c};</div>
<div class="line"><span class="keyword">struct </span>prim_cell new = (<span class="keyword">struct </span>prim_cell){.cell = next,</div>
<div class="line">                                          .cost = rand_range(0, 100)};</div>
<div class="line"><span class="keyword">struct </span>prim_cell *<span class="keyword">const</span> cell = or_insert(entry_r(&amp;costs, &amp;next), &amp;<span class="keyword">new</span>.map_elem);</div>
</div><!-- fragment --><p>The lazily evaluated macro version.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>point const next = {.r = c-&gt;cell.r + dir_offsets[i].r,</div>
<div class="line">                           .c = c-&gt;cell.c + dir_offsets[i].c};</div>
<div class="line"><span class="keyword">struct </span>prim_cell *<span class="keyword">const</span> cell = om_or_insert_w(</div>
<div class="line">    entry_r(&amp;costs, &amp;next),</div>
<div class="line">    (<span class="keyword">struct</span> prim_cell){.cell = next, .cost = rand_range(0, 100)});</div>
</div><!-- fragment --><p>The second example is slightly more convenient and efficient. The compound literal is provided to be directly assigned to a Vacant memory location; it is only constructed if there is no entry present. This also means the random generation function is only called if a Vacant entry requires the insertion of a new value. So, expensive function calls can be lazily evaluated only when needed.</p>
<p>Here is another example illustrating the difference between the two.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>val</div>
<div class="line">{</div>
<div class="line">    omap_elem e;</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> e = om_try_insert(&amp;om, &amp;(<span class="keyword">struct</span> val){.key = 3, .val = 1}.e);</div>
</div><!-- fragment --><p>The same insertion with the "with" variant.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>val</div>
<div class="line">val(int val_arg)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keyword">struct</span> val){.val = val_args};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> *e = om_try_insert_w(&amp;om, 3, val(1));</div>
</div><!-- fragment --><p>This second version illustrates a few key points. R-values are provided directly as keys and values, not references to keys and values. Also, a function call to generate a value to be inserted is completely acceptable; the function is only called if insertion is required. Finally, the functions <code>try_insert_w</code> and <code>insert_or_assign_w</code> will ensure the key in the newly inserted value matches the key searched, saving the user some typing and ensuring they don't make a mistake in this regard.</p>
<p>The lazy evaluation of the <code>_w</code> family of functions offer an expressive way to write C code when needed. See each container's header for more.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Traits</h2>
<p>Traits, found in <code><a class="el" href="traits_8h.html" title="The C Container Collection Traits Interface.">ccc/traits.h</a></code>, offer a more succinct way to use shared functionality across containers. Instead of calling <code>ccc_fhm_entry</code> when trying to obtain an entry from a flat hash map, one can simply call <code>entry</code>. Traits utilize <code>_Generic</code> in C to choose the correct container function based on parameters provided.</p>
<p>Traits cost nothing at runtime but may increase compilation resources and time, though I have not been able to definitively measure a human noticeable difference in this regard. For example, consider two ways to use the entry interface.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    str_ofs str_arena_offset;</div>
<div class="line">    <span class="keywordtype">int</span> cnt;</div>
<div class="line">    fomap_elem e;</div>
<div class="line">} word;</div>
<div class="line"><span class="comment">/* ... Elsewhere generate offset ofs as key. */</span></div>
<div class="line">word <span class="keywordflow">default</span> = {.str_arena_offset = ofs, .cnt = 1};</div>
<div class="line">word *w = or_insert(and_modify(entry_r(&amp;fom, &amp;ofs), increment), &amp;<span class="keywordflow">default</span>.e);</div>
</div><!-- fragment --><p>Or the following.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    str_ofs str_arena_offset;</div>
<div class="line">    <span class="keywordtype">int</span> cnt;</div>
<div class="line">    fomap_elem e;</div>
<div class="line">} word;</div>
<div class="line"><span class="comment">/* ... Elsewhere generate offset ofs as key. */</span></div>
<div class="line">word <span class="keywordflow">default</span> = {.str_arena_offset = ofs, .cnt = 1};</div>
<div class="line">fomap_entry *e = entry_r(&amp;fom, &amp;ofs);</div>
<div class="line">e = and_modify(e, increment)</div>
<div class="line">word *w = or_insert(e, &amp;<span class="keywordflow">default</span>.e);</div>
</div><!-- fragment --><p>Using the first method in your code may expand the code evaluated in different <code>_Generic</code> cases greatly increasing compilation memory use and time (I have not yet measured the validity of these concerns). Such nesting concerns are not relevant if the container specific versions of these functions are used. Traits are completely opt-in by including the <code><a class="el" href="traits_8h.html" title="The C Container Collection Traits Interface.">traits.h</a></code> header.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Allocation</h1>
<p>When allocation is required, this collection offers the following interface. The user provides this function to containers upon initialization.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">void</span> *<a class="code hl_typedef" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a>(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size, <span class="keywordtype">void</span> *aux);</div>
<div class="ttc" id="atypes_8h_html_a8be6e2d1b150a5b77b2eba5ae85764f2"><div class="ttname"><a href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a></div><div class="ttdeci">void * ccc_alloc_fn(void *ptr, size_t size, void *aux)</div><div class="ttdoc">An allocation function at the core of all containers.</div><div class="ttdef"><b>Definition:</b> types.h:195</div></div>
</div><!-- fragment --><p>An allocation function implements the following behavior, where ptr is pointer to memory, size is number of bytes to allocate, and aux is a reference to any supplementary information required for allocation, deallocation, or reallocation. The aux parameter is passed to a container upon its initialization and the programmer may choose how to best utilize this reference (read on for more on aux).</p>
<ul>
<li>If NULL is provided with a size of 0, NULL is returned.</li>
<li>If NULL is provided with a non-zero size, new memory is allocated/returned.</li>
<li>If ptr is non-NULL it has been previously allocated by the alloc function.</li>
<li>If ptr is non-NULL with non-zero size, ptr is resized to at least size size. The pointer returned is NULL if resizing fails. Upon success, the pointer returned might not be equal to the pointer provided.</li>
<li>If ptr is non-NULL and size is 0, ptr is freed and NULL is returned.</li>
</ul>
<p>One may be tempted to use realloc to check all of these boxes but realloc is implementation defined on some of these points. The aux parameter also discourages users from providing realloc. For example, one solution using the standard library allocator might be implemented as follows (aux is not needed):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *</div>
<div class="line">std_alloc(<span class="keywordtype">void</span> *<span class="keyword">const</span> ptr, <span class="keywordtype">size_t</span> <span class="keyword">const</span> size, <span class="keywordtype">void</span> *)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr &amp;&amp; !size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> malloc(size);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!size)</div>
<div class="line">    {</div>
<div class="line">        free(ptr);</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> realloc(ptr, size);</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, the above example is only useful if the standard library allocator is used. Any allocator that implements the required behavior is sufficient. For ideas of how to utilize the aux parameter, see the sample programs. Using custom arena allocators or container compositions are cases when aux is helpful in taming lifetimes and simplifying allocation.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Constructors</h2>
<p>Another concern for the programmer related to allocation may be constructors and destructors, a C++ shaped peg for a C shaped hole. In general, this library has some limited support for destruction but does not provide an interface for direct constructors as C++ would define them; though this may change.</p>
<p>Consider a constructor. If the container is allowed to allocate, and the user wants to insert a new element, they may see an interface like this (pseudocode as all containers are slightly different).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *insert(container *c, container_elem *e);</div>
</div><!-- fragment --><p>Because the user has wrapped the intrusive container element in their type, the entire user type will be written to the new allocation. All interfaces can also confirm when insertion succeeds if global state needs to be set in this case. So, if some action beyond setting values needs to be performed, there are multiple opportunities to do so.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Destructors</h2>
<p>For destructors, the argument is similar but the container does offer more help. If an action other than freeing the memory of a user type is needed upon removal, there are options in an interface to obtain the element to be removed. Associative containers offer functions that can obtain entries (similar to Rust's Entry API). This reference can then be examined and complex destructor actions can occur before removal. Other containers like lists or priority queues offer references to an element of interest such as front, back, max, min, etc. These can all allow destructor-like actions before removal. One exception is the following interfaces.</p>
<p>The clear function works for pointer stable containers and flat containers.</p>
<div class="fragment"><div class="line">result clear(container *c, destructor_fn *fn);</div>
</div><!-- fragment --><p>The clear and free function works for flat containers.</p>
<div class="fragment"><div class="line">result clear_and_free(container *c, destructor_fn *fn);</div>
</div><!-- fragment --><p>The above functions free the resources of the container. Because there is no way to access each element before it is freed when this function is called, a destructor callback can be passed to operate on each element before deallocation.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Samples</h1>
<p>For examples of what code that uses these ideas looks like, read and use the sample programs in the <code>samples/</code>. I try to only add non-trivial samples that do something mildly interesting to give a good idea of how to take advantage of this flexible memory philosophy.</p>
<p>The samples are not included in the release. To build them, clone the repository. Usage instructions should be available with the <code>-h</code> flag to any program or at the top of the file.</p>
<p>Clang.</p>
<div class="fragment"><div class="line">make all-clang-rel</div>
<div class="line">./build/bin/[SAMPLE] [SAMPLE CLI ARGS]</div>
</div><!-- fragment --><p>GCC.</p>
<div class="fragment"><div class="line">make all-gcc-rel</div>
<div class="line">./build/bin/[SAMPLE] [SAMPLE CLI ARGS]</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
Tests</h1>
<p>The tests also include various use cases that may be of interest. Tests are not included in the release. Clone the repository.</p>
<p>Clang.</p>
<div class="fragment"><div class="line">make all-clang-rel</div>
<div class="line">make rtest</div>
</div><!-- fragment --><p>GCC.</p>
<div class="fragment"><div class="line">make all-gcc-rel</div>
<div class="line">make rtest</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md16"></a>
Miscellaneous Why?</h1>
<ul>
<li>Why are non-allocating containers needed? They are quite common in Operating Systems development. Kernel code may manage a process or thread that is part of many OS subsystems: the CPU scheduler, the virtual memory paging system, the child and parent process spawn and wait mechanisms. All of these systems require that the process use or be a part of some data structures. It is easiest to separate participation in these data structures from memory allocation. The process holds handles to intrusive elements to participate in these data structures because the thread/task/process will live until it has finished executing meaning its lifetime is greater than or equal to the longest lifetime data structure of which it is a part. Embedded developers also often seem interested in non-allocating containers when an entire program's memory use is known before execution begins. However, this library explores if non-allocating containers can have more general applications for creative C programming.</li>
<li>Why is initialization so ugly? Yes, this is a valid concern. Upfront complexity helps eliminate the need for a <code>container_of</code> macro for the user see the no container_of macros section for more.</li>
<li>Why callbacks? Freedom for more varied comparisons and allocations. Learn to love auxiliary data. Also you have the chance to craft the optimal function for your application; for example writing a perfectly tailored hash function for your data set.</li>
<li>Why not header only? Readability, maintainability, and update ability, for changing implementations in the source files. If the user wants to explore the implementation everything should be easily understandable. Smaller object size and easier modular compilation is also nice.</li>
<li>Why not opaque pointers and true implementation hiding? This is not possible in C if the user is in charge of memory. The container types must be complete if the user wishes to store them on the stack or data segment. I try to present a clean interface.</li>
<li>Why flat maps? Mostly experimenting. Flat maps track the tree structure through indices not pointers. This makes the data structure copyable, relocatable, serializable, or writable to disk at the cost of pointer stability in most cases. This can also make logging and recording program state easier.</li>
<li>Why not a better hash map? Haven't gotten to it yet. This container has the most room for improvement. There are many exciting recent developments in hash tables that can be built upon to improve this container.</li>
<li>Why C23? It is a great standard that helps with some initialization and macro ideas implemented in the library. Clang covers all of the features used on many platforms. Newer gcc versions also have them covered.</li>
</ul>
<h1><a class="anchor" id="autotoc_md17"></a>
Related</h1>
<p>If these containers do not fit your needs, here are some excellent data structure libraries I have found for C. They are clever, fast, and elegant, taking care of all memory management for you.</p>
<ul>
<li><a href="https://github.com/stclib/STC">STC - Smart Template Containers</a></li>
<li><a href="https://github.com/glouw/ctl">C Template Library (CTL)</a></li>
<li><a href="https://github.com/JacksonAllan/CC">CC: Convenient Containers</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
