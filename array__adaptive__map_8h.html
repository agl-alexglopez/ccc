<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/array_adaptive_map.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('array__adaptive__map_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">array_adaptive_map.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Array Adaptive Map Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;private/private_array_adaptive_map.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for array_adaptive_map.h:</div>
<div class="dyncontent">
<div class="center"><img src="array__adaptive__map_8h__incl.png" border="0" usemap="#accc_2array__adaptive__map_8h" alt=""/></div>
<map name="accc_2array__adaptive__map_8h" id="accc_2array__adaptive__map_8h">
<area shape="rect" title="The Array Adaptive Map Interface." alt="" coords="5,5,151,45"/>
<area shape="rect" href="private__array__adaptive__map_8h_source.html" title=" " alt="" coords="57,93,216,133"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="17,181,99,207"/>
<area shape="rect" href="private__types_8h_source.html" title=" " alt="" coords="10,255,183,280"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="array__adaptive__map_8h__dep__incl.png" border="0" usemap="#accc_2array__adaptive__map_8hdep" alt=""/></div>
<map name="accc_2array__adaptive__map_8hdep" id="accc_2array__adaptive__map_8hdep">
<area shape="rect" title="The Array Adaptive Map Interface." alt="" coords="5,5,151,45"/>
<area shape="rect" href="private__traits_8h_source.html" title=" " alt="" coords="7,93,149,133"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="31,181,125,207"/>
</map>
</div>
</div>
<p><a href="array__adaptive__map_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Array Adaptive Map Interface. </p>
<p>A array adaptive map is a contiguously stored map offering storage and retrieval by key. Because the data structure is self-optimizing it is not a suitable map in a realtime environment where strict runtime bounds are needed. Also, searching the map is not a const thread-safe operation as indicated by the function signatures. The map is optimized upon every new search in attempt to adapt to the usage pattern. In many cases the self-optimizing structure of the map may be beneficial when considering non-uniform access patterns. In the best case, repeated searches of the same value yield an <code>O(1)</code> access and many other frequently searched values will remain close to the root of the map.</p>
<p>The array version of the adaptive map promises contiguous storage and random access if needed. Handles remain valid until an element is removed even if other elements are inserted, other elements are removed, or resizing occurs. All elements in the map track their relationships to one another via indices in the array. Therefore, this data structure can be relocated, copied, serialized, or written to disk and all internal data structure references will remain valid. Insertion may invoke an O(N) operation if resizing occurs. Finally, if allocation is prohibited upon initialization, and the user provides a capacity of <code>N</code> upon initialization, one slot will be used for a sentinel node. The user available capacity is <code>N - 1</code>.</p>
<p>All interface functions accept <code>void *</code> references to either the key or the full type the user is storing in the map. Therefore, it is important for the user to be aware if they are passing a reference to the key or the full type depending on the function requirements.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ARRAY_ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>CCC_</code> prefix. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Initialize the container with memory, callbacks, and permissions. </p>
</td></tr>
<tr class="memitem:a411c1d286e78f2c5b2a26045aee802ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a411c1d286e78f2c5b2a26045aee802ce">CCC_array_adaptive_map_declare_fixed_map</a>(fixed_map_type_name,  type_name,  capacity)</td></tr>
<tr class="memdesc:a411c1d286e78f2c5b2a26045aee802ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a fixed size map type for use in the stack, heap, or data segment. Does not return a value.  <br /></td></tr>
<tr class="separator:a411c1d286e78f2c5b2a26045aee802ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e80f373bb1e9b7f5893fc79b4791ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a89e80f373bb1e9b7f5893fc79b4791ab">CCC_array_adaptive_map_fixed_capacity</a>(fixed_map_type_name)&#160;&#160;&#160;    CCC_private_array_adaptive_map_fixed_capacity(fixed_map_type_name)</td></tr>
<tr class="memdesc:a89e80f373bb1e9b7f5893fc79b4791ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the capacity previously chosen for the fixed size map type.  <br /></td></tr>
<tr class="separator:a89e80f373bb1e9b7f5893fc79b4791ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4c870e8ae161237fbe9fb16f1dc325"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#afb4c870e8ae161237fbe9fb16f1dc325">CCC_array_adaptive_map_initialize</a>(memory_pointer,  type_name,  type_intruder_field,  compare,  allocate,  context_data,  capacity)</td></tr>
<tr class="memdesc:afb4c870e8ae161237fbe9fb16f1dc325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the map at runtime or compile time.  <br /></td></tr>
<tr class="separator:afb4c870e8ae161237fbe9fb16f1dc325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70d531a34998ec0218121458ef38aae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#af70d531a34998ec0218121458ef38aae">CCC_array_adaptive_map_from</a>(type_key_field,  compare,  allocate,  context_data,  optional_capacity,  type_compound_literal_array...)</td></tr>
<tr class="memdesc:af70d531a34998ec0218121458ef38aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a dynamic map at runtime from an initializer list.  <br /></td></tr>
<tr class="separator:af70d531a34998ec0218121458ef38aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2379e48c78cbcf77f9fcf8567d6b0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#afc2379e48c78cbcf77f9fcf8567d6b0d">CCC_array_adaptive_map_with_capacity</a>( type_name,  type_key_field,  compare,  allocate,  context_data,  capacity)</td></tr>
<tr class="memdesc:afc2379e48c78cbcf77f9fcf8567d6b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a dynamic map at runtime with at least the specified capacity.  <br /></td></tr>
<tr class="separator:afc2379e48c78cbcf77f9fcf8567d6b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0547f59ae3d0b1297228816fa22e39df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a0547f59ae3d0b1297228816fa22e39df">CCC_array_adaptive_map_copy</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *destination, <a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *source, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:a0547f59ae3d0b1297228816fa22e39df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the map at source to destination.  <br /></td></tr>
<tr class="separator:a0547f59ae3d0b1297228816fa22e39df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052a37b91d2460ef5415c4a21fa92494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a052a37b91d2460ef5415c4a21fa92494">CCC_array_adaptive_map_reserve</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, size_t to_add, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:a052a37b91d2460ef5415c4a21fa92494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for at least to_add more elements.  <br /></td></tr>
<tr class="separator:a052a37b91d2460ef5415c4a21fa92494"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Membership Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Test membership or obtain references to stored user types directly. </p>
</td></tr>
<tr class="memitem:a7107f7852dada205ca4ddcdce669ef56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a7107f7852dada205ca4ddcdce669ef56">CCC_array_adaptive_map_as</a>(map_pointer,  type_name,  array_index...)&#160;&#160;&#160;    CCC_private_array_adaptive_map_as(map_pointer, type_name, array_index)</td></tr>
<tr class="memdesc:a7107f7852dada205ca4ddcdce669ef56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the user type in the table at the handle.  <br /></td></tr>
<tr class="separator:a7107f7852dada205ca4ddcdce669ef56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a3b1e7db48fb6daec6f36df24dbe0f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a59a3b1e7db48fb6daec6f36df24dbe0f">CCC_array_adaptive_map_at</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map, <a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> index)</td></tr>
<tr class="memdesc:a59a3b1e7db48fb6daec6f36df24dbe0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the user data at the provided handle.  <br /></td></tr>
<tr class="separator:a59a3b1e7db48fb6daec6f36df24dbe0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6066660ff6db8775634ec22c44cda83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ad6066660ff6db8775634ec22c44cda83">CCC_array_adaptive_map_contains</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void const *key)</td></tr>
<tr class="memdesc:ad6066660ff6db8775634ec22c44cda83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the map for the presence of key.  <br /></td></tr>
<tr class="separator:ad6066660ff6db8775634ec22c44cda83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956042ad2f4073329e6bf251869f0146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a956042ad2f4073329e6bf251869f0146">CCC_array_adaptive_map_get_key_value</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void const *key)</td></tr>
<tr class="memdesc:a956042ad2f4073329e6bf251869f0146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference into the map at handle key.  <br /></td></tr>
<tr class="separator:a956042ad2f4073329e6bf251869f0146"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Handle Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and operate on container handles for efficient queries when non-trivial control flow is needed. </p>
</td></tr>
<tr class="memitem:ae38d277c09750eaf0a57250b8122f808"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ae38d277c09750eaf0a57250b8122f808">CCC_array_adaptive_map_swap_handle_wrap</a>(map_pointer,  type_output_pointer)</td></tr>
<tr class="memdesc:ae38d277c09750eaf0a57250b8122f808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value wrapping type.  <br /></td></tr>
<tr class="separator:ae38d277c09750eaf0a57250b8122f808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c9caa87fd345aeedb51f1a6bbd7051"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a69c9caa87fd345aeedb51f1a6bbd7051">CCC_array_adaptive_map_try_insert_wrap</a>(map_pointer,  type_pointer)</td></tr>
<tr class="memdesc:a69c9caa87fd345aeedb51f1a6bbd7051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the key value wrapping type.  <br /></td></tr>
<tr class="separator:a69c9caa87fd345aeedb51f1a6bbd7051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe39139c57071844161f3bfdb9a38b14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#abe39139c57071844161f3bfdb9a38b14">CCC_array_adaptive_map_try_insert_with</a>(map_pointer,  key,  type_compound_literal...)</td></tr>
<tr class="memdesc:abe39139c57071844161f3bfdb9a38b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">lazily insert type_compound_literal into the map at key if key is absent.  <br /></td></tr>
<tr class="separator:abe39139c57071844161f3bfdb9a38b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778a7ef33e0baa380904d704e3137a1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a778a7ef33e0baa380904d704e3137a1b">CCC_array_adaptive_map_insert_or_assign_with</a>(map_pointer,  key,  type_compound_literal...)</td></tr>
<tr class="memdesc:a778a7ef33e0baa380904d704e3137a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new key value pair or overwrites the existing handle.  <br /></td></tr>
<tr class="separator:a778a7ef33e0baa380904d704e3137a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7e3b59cd02463e1724f493d590d91e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#abe7e3b59cd02463e1724f493d590d91e">CCC_array_adaptive_map_remove_key_value_wrap</a>(map_pointer,  type_output_pointer)</td></tr>
<tr class="memdesc:abe7e3b59cd02463e1724f493d590d91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key value in the map storing the old value, if present, in the struct containing type_output provided by the user.  <br /></td></tr>
<tr class="separator:abe7e3b59cd02463e1724f493d590d91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1746c2db663f3408059b8a025b6cfb96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a1746c2db663f3408059b8a025b6cfb96">CCC_array_adaptive_map_handle_wrap</a>(array_pointer,  key_pointer)</td></tr>
<tr class="memdesc:a1746c2db663f3408059b8a025b6cfb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a handle for the provided key in the map for future use.  <br /></td></tr>
<tr class="separator:a1746c2db663f3408059b8a025b6cfb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9d55c908afc361a54596c0bb3d3be3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a3d9d55c908afc361a54596c0bb3d3be3">CCC_array_adaptive_map_and_modify_with</a>(array_pointer,  type_name,  closure_over_T...)</td></tr>
<tr class="memdesc:a3d9d55c908afc361a54596c0bb3d3be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an Occupied handle with a closure over user type T.  <br /></td></tr>
<tr class="separator:a3d9d55c908afc361a54596c0bb3d3be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1ea6b149b2e49f2cf6484e747e40f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a4b1ea6b149b2e49f2cf6484e747e40f6">CCC_array_adaptive_map_or_insert_with</a>(array_pointer,  type_compound_literal...)</td></tr>
<tr class="memdesc:a4b1ea6b149b2e49f2cf6484e747e40f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily insert the desired key value into the handle if it is Vacant.  <br /></td></tr>
<tr class="separator:a4b1ea6b149b2e49f2cf6484e747e40f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f15a63d7c037f810617791c38e9d4d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a6f15a63d7c037f810617791c38e9d4d4">CCC_array_adaptive_map_insert_array_with</a>(array_pointer,  type_compound_literal...)</td></tr>
<tr class="memdesc:a6f15a63d7c037f810617791c38e9d4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of the compound literal type_compound_literal to a node.  <br /></td></tr>
<tr class="separator:a6f15a63d7c037f810617791c38e9d4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331d96f78d0c0706c60a44eb53fd29ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a331d96f78d0c0706c60a44eb53fd29ae">CCC_array_adaptive_map_remove_handle_wrap</a>(array_pointer)</td></tr>
<tr class="memdesc:a331d96f78d0c0706c60a44eb53fd29ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the handle from the map if Occupied.  <br /></td></tr>
<tr class="separator:a331d96f78d0c0706c60a44eb53fd29ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e3313f0460ecdb3140ad48de2e3d61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Handle.html">CCC_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a12e3313f0460ecdb3140ad48de2e3d61">CCC_array_adaptive_map_swap_handle</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void *type_output)</td></tr>
<tr class="memdesc:a12e3313f0460ecdb3140ad48de2e3d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value wrapping type.  <br /></td></tr>
<tr class="separator:a12e3313f0460ecdb3140ad48de2e3d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615526c758a02c6c994784d21eb756fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Handle.html">CCC_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a615526c758a02c6c994784d21eb756fe">CCC_array_adaptive_map_try_insert</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void const *type)</td></tr>
<tr class="memdesc:a615526c758a02c6c994784d21eb756fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the key value wrapping type.  <br /></td></tr>
<tr class="separator:a615526c758a02c6c994784d21eb756fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf570b3ea9a14f0e6c3e32c30bb29c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Handle.html">CCC_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#aacdf570b3ea9a14f0e6c3e32c30bb29c">CCC_array_adaptive_map_insert_or_assign</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void const *type)</td></tr>
<tr class="memdesc:aacdf570b3ea9a14f0e6c3e32c30bb29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts or overwrites a user struct into the map.  <br /></td></tr>
<tr class="separator:aacdf570b3ea9a14f0e6c3e32c30bb29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab51d4696e0a25ea272e46c35c200dd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Handle.html">CCC_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#aab51d4696e0a25ea272e46c35c200dd8">CCC_array_adaptive_map_remove_key_value</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void *type_output)</td></tr>
<tr class="memdesc:aab51d4696e0a25ea272e46c35c200dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key value in the map storing the old value, if present, in the struct containing type_output provided by the user.  <br /></td></tr>
<tr class="separator:aab51d4696e0a25ea272e46c35c200dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4229d887c2308cc660616136695726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#adc4229d887c2308cc660616136695726">CCC_array_adaptive_map_handle</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void const *key)</td></tr>
<tr class="memdesc:adc4229d887c2308cc660616136695726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a handle for the provided key in the map for future use.  <br /></td></tr>
<tr class="separator:adc4229d887c2308cc660616136695726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058ecd325865647858f89b14e6e6a9e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a058ecd325865647858f89b14e6e6a9e3">CCC_array_adaptive_map_and_modify</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> *handle, <a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *modify)</td></tr>
<tr class="memdesc:a058ecd325865647858f89b14e6e6a9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the provided handle if it is Occupied.  <br /></td></tr>
<tr class="separator:a058ecd325865647858f89b14e6e6a9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360847e030447c7150da28a91bd8e349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a360847e030447c7150da28a91bd8e349">CCC_array_adaptive_map_and_modify_context</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> *handle, <a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *modify, void *context)</td></tr>
<tr class="memdesc:a360847e030447c7150da28a91bd8e349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the provided handle if it is Occupied.  <br /></td></tr>
<tr class="separator:a360847e030447c7150da28a91bd8e349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f38daab50a3397e9f8f13f27aa6cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a44f38daab50a3397e9f8f13f27aa6cef">CCC_array_adaptive_map_or_insert</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *handle, void const *type)</td></tr>
<tr class="memdesc:a44f38daab50a3397e9f8f13f27aa6cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the struct with user type if the handle is Vacant.  <br /></td></tr>
<tr class="separator:a44f38daab50a3397e9f8f13f27aa6cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57ee6a897f22ff36add416aeda62363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ad57ee6a897f22ff36add416aeda62363">CCC_array_adaptive_map_insert_handle</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *handle, void const *type)</td></tr>
<tr class="memdesc:ad57ee6a897f22ff36add416aeda62363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the provided handle invariantly.  <br /></td></tr>
<tr class="separator:ad57ee6a897f22ff36add416aeda62363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ead4b3654a7cb197b2236e27c6e06e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Handle.html">CCC_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a7ead4b3654a7cb197b2236e27c6e06e6">CCC_array_adaptive_map_remove_handle</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> *handle)</td></tr>
<tr class="memdesc:a7ead4b3654a7cb197b2236e27c6e06e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the handle from the map if Occupied.  <br /></td></tr>
<tr class="separator:a7ead4b3654a7cb197b2236e27c6e06e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f476486c9b0a433f3ee32a4fefeaff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ac3f476486c9b0a433f3ee32a4fefeaff">CCC_array_adaptive_map_unwrap</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *handle)</td></tr>
<tr class="memdesc:ac3f476486c9b0a433f3ee32a4fefeaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps the provided handle to obtain a view into the map element.  <br /></td></tr>
<tr class="separator:ac3f476486c9b0a433f3ee32a4fefeaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7d559597dacbe157cfc6d2e7bea051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#afe7d559597dacbe157cfc6d2e7bea051">CCC_array_adaptive_map_occupied</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *handle)</td></tr>
<tr class="memdesc:afe7d559597dacbe157cfc6d2e7bea051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vacant or Occupied status of the handle.  <br /></td></tr>
<tr class="separator:afe7d559597dacbe157cfc6d2e7bea051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf8f60286f2b25f56244f12f84ef1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a2bf8f60286f2b25f56244f12f84ef1b6">CCC_array_adaptive_map_insert_error</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *handle)</td></tr>
<tr class="memdesc:a2bf8f60286f2b25f56244f12f84ef1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the status of the handle should an insertion follow.  <br /></td></tr>
<tr class="separator:a2bf8f60286f2b25f56244f12f84ef1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5ccaca69382f2733c1b38776ef4cea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a282e45f45cb2493ec1709942eb5d958d">CCC_Handle_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a8c5ccaca69382f2733c1b38776ef4cea">CCC_array_adaptive_map_handle_status</a> (<a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *handle)</td></tr>
<tr class="memdesc:a8c5ccaca69382f2733c1b38776ef4cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the handle status from a container handle.  <br /></td></tr>
<tr class="separator:a8c5ccaca69382f2733c1b38776ef4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iterator Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and manage iterators over the container. </p>
</td></tr>
<tr class="memitem:ac6d689f62b1ae8bffbe5443dc65f3491"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ac6d689f62b1ae8bffbe5443dc65f3491">CCC_array_adaptive_map_equal_range_wrap</a>(map_pointer,  begin_and_end_key_pointers...)</td></tr>
<tr class="memdesc:ac6d689f62b1ae8bffbe5443dc65f3491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compound literal reference to the desired range. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ac6d689f62b1ae8bffbe5443dc65f3491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd82daf7a8cb0624eebefabb795d733"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a3cd82daf7a8cb0624eebefabb795d733">CCC_array_adaptive_map_equal_range_reverse_wrap</a>( map_pointer,  reverse_begin_and_reverse_end_key_pointers...)</td></tr>
<tr class="memdesc:a3cd82daf7a8cb0624eebefabb795d733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compound literal reference to the desired range_reverse. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a3cd82daf7a8cb0624eebefabb795d733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4a40014feb193966eeeaf61e8392db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Handle__range.html">CCC_Handle_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#acb4a40014feb193966eeeaf61e8392db">CCC_array_adaptive_map_equal_range</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void const *begin_key, void const *end_key)</td></tr>
<tr class="memdesc:acb4a40014feb193966eeeaf61e8392db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterable range of values from [begin_key, end_key). Amortized O(lg N).  <br /></td></tr>
<tr class="separator:acb4a40014feb193966eeeaf61e8392db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72607889c33e4fe4aee675bb7562fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa24094a0fb5618980a629b4accdd37d7">CCC_Handle_range_reverse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ac72607889c33e4fe4aee675bb7562fc5">CCC_array_adaptive_map_equal_range_reverse</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, void const *reverse_begin_key, void const *reverse_end_key)</td></tr>
<tr class="memdesc:ac72607889c33e4fe4aee675bb7562fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterable range_reverse of values from [reverse_begin_key, end_key). Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ac72607889c33e4fe4aee675bb7562fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87a0958591245c4d18082f5ab06b20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ad87a0958591245c4d18082f5ab06b20c">CCC_array_adaptive_map_begin</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:ad87a0958591245c4d18082f5ab06b20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start of an inorder traversal of the map. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ad87a0958591245c4d18082f5ab06b20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d56d3ffc6e1b1dfe2e042679fde994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ab3d56d3ffc6e1b1dfe2e042679fde994">CCC_array_adaptive_map_reverse_begin</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:ab3d56d3ffc6e1b1dfe2e042679fde994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start of a reverse inorder traversal of the map. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ab3d56d3ffc6e1b1dfe2e042679fde994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72c7016d5338f34ac39b3759b8997ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ad72c7016d5338f34ac39b3759b8997ba">CCC_array_adaptive_map_next</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map, <a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> iterator)</td></tr>
<tr class="memdesc:ad72c7016d5338f34ac39b3759b8997ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next element in an inorder traversal of the map. O(1).  <br /></td></tr>
<tr class="separator:ad72c7016d5338f34ac39b3759b8997ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bafba311dacf5f381d4badd03e74f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#af4bafba311dacf5f381d4badd03e74f3">CCC_array_adaptive_map_reverse_next</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map, <a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> iterator)</td></tr>
<tr class="memdesc:af4bafba311dacf5f381d4badd03e74f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse_next element in a reverse inorder traversal of the map. O(1).  <br /></td></tr>
<tr class="separator:af4bafba311dacf5f381d4badd03e74f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab311d349c681b7748451f9bd1eff34f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#ab311d349c681b7748451f9bd1eff34f8">CCC_array_adaptive_map_end</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:ab311d349c681b7748451f9bd1eff34f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end of an inorder traversal of the map. O(1).  <br /></td></tr>
<tr class="separator:ab311d349c681b7748451f9bd1eff34f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1a2b8804ec4f9d9023b04d08f63bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a7f1a2b8804ec4f9d9023b04d08f63bdd">CCC_array_adaptive_map_reverse_end</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:a7f1a2b8804ec4f9d9023b04d08f63bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse_end of a reverse inorder traversal of the map. O(1).  <br /></td></tr>
<tr class="separator:a7f1a2b8804ec4f9d9023b04d08f63bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Types available in the container interface. </p>
</td></tr>
<tr class="memitem:a3383e02ece054e21edbc2a638d3567f9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a3383e02ece054e21edbc2a638d3567f9">CCC_Array_adaptive_map</a></td></tr>
<tr class="memdesc:a3383e02ece054e21edbc2a638d3567f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A self-optimizing data structure offering amortized O(lg N) search, insert, and erase.  <br /></td></tr>
<tr class="separator:a3383e02ece054e21edbc2a638d3567f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ce76b9053351d5eabb334544cb2530"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionCCC__Array__adaptive__map__handle__wrap.html">CCC_Array_adaptive_map_handle_wrap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a67ce76b9053351d5eabb334544cb2530">CCC_Array_adaptive_map_handle</a></td></tr>
<tr class="memdesc:a67ce76b9053351d5eabb334544cb2530"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container specific handle used to implement the Handle Interface.  <br /></td></tr>
<tr class="separator:a67ce76b9053351d5eabb334544cb2530"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Deallocate the container. </p>
</td></tr>
<tr class="memitem:a7d7640632d28dcb6f4f780ec97abcc2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a7d7640632d28dcb6f4f780ec97abcc2f">CCC_array_adaptive_map_clear</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy)</td></tr>
<tr class="memdesc:a7d7640632d28dcb6f4f780ec97abcc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the map for use without affecting capacity.  <br /></td></tr>
<tr class="separator:a7d7640632d28dcb6f4f780ec97abcc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0554a3e3d434b715fa8358370e119a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#afe0554a3e3d434b715fa8358370e119a">CCC_array_adaptive_map_clear_and_free</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy)</td></tr>
<tr class="memdesc:afe0554a3e3d434b715fa8358370e119a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the map and frees the underlying buffer.  <br /></td></tr>
<tr class="separator:afe0554a3e3d434b715fa8358370e119a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeea17f39c030003d233a78c258ea6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a5eeea17f39c030003d233a78c258ea6e">CCC_array_adaptive_map_clear_and_free_reserve</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *map, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:a5eeea17f39c030003d233a78c258ea6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the array_adaptive_map and frees the underlying Buffer that was previously dynamically reserved with the reserve function.  <br /></td></tr>
<tr class="separator:a5eeea17f39c030003d233a78c258ea6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain the container state. </p>
</td></tr>
<tr class="memitem:a88e7f7da52c9d9ae7355a6872edac3eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a88e7f7da52c9d9ae7355a6872edac3eb">CCC_array_adaptive_map_count</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:a88e7f7da52c9d9ae7355a6872edac3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of map occupied slots.  <br /></td></tr>
<tr class="separator:a88e7f7da52c9d9ae7355a6872edac3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee105753e1d54612949fe826bc187092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#aee105753e1d54612949fe826bc187092">CCC_array_adaptive_map_capacity</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:aee105753e1d54612949fe826bc187092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the map representing total possible slots.  <br /></td></tr>
<tr class="separator:aee105753e1d54612949fe826bc187092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa656d9645bcc7ccb2f603391089873b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#aa656d9645bcc7ccb2f603391089873b0">CCC_array_adaptive_map_is_empty</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:aa656d9645bcc7ccb2f603391089873b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size status of the map.  <br /></td></tr>
<tr class="separator:aa656d9645bcc7ccb2f603391089873b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f607d8d9612c0bb2222c8bf5a4377c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__adaptive__map_8h.html#a02f607d8d9612c0bb2222c8bf5a4377c">CCC_array_adaptive_map_validate</a> (<a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *map)</td></tr>
<tr class="memdesc:a02f607d8d9612c0bb2222c8bf5a4377c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validation of invariants for the map.  <br /></td></tr>
<tr class="separator:a02f607d8d9612c0bb2222c8bf5a4377c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3d9d55c908afc361a54596c0bb3d3be3" name="a3d9d55c908afc361a54596c0bb3d3be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9d55c908afc361a54596c0bb3d3be3">&#9670;&#160;</a></span>CCC_array_adaptive_map_and_modify_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_and_modify_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">closure_over_T...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="array__adaptive__map_8h.html#a67ce76b9053351d5eabb334544cb2530">CCC_Array_adaptive_map_handle</a>)                                           \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_array_adaptive_map_and_modify_with(                        \</div>
<div class="line">            array_pointer, type_name, closure_over_T)                          \</div>
<div class="line">    }</div>
<div class="ttc" id="aarray__adaptive__map_8h_html_a67ce76b9053351d5eabb334544cb2530"><div class="ttname"><a href="array__adaptive__map_8h.html#a67ce76b9053351d5eabb334544cb2530">CCC_Array_adaptive_map_handle</a></div><div class="ttdeci">union CCC_Array_adaptive_map_handle_wrap CCC_Array_adaptive_map_handle</div><div class="ttdoc">A container specific handle used to implement the Handle Interface.</div><div class="ttdef"><b>Definition:</b> array_adaptive_map.h:79</div></div>
</div><!-- fragment -->
<p>Modify an Occupied handle with a closure over user type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the obtained handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the user type stored in the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">closure_over_T</td><td>the code to be run on the reference to user type T, if Occupied. This may be a semicolon separated list of statements to execute on T or a section of code wrapped in braces {code here} which may be preferred for formatting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the modified handle if it was occupied or a vacant handle if it was vacant. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>T is a reference to the user type stored in the handle guaranteed to be non-NULL if the closure executes.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#define ARRAY_ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="comment">// Increment the count if found otherwise do nothing.</span></div>
<div class="line">Array_adaptive_map_handle *e =</div>
<div class="line">    array_adaptive_map_and_modify_with(</div>
<div class="line">        handle_wrap(&amp;array_adaptive_map, &amp;k),</div>
<div class="line">        Word,</div>
<div class="line">        T-&gt;cnt++;</div>
<div class="line">    );</div>
<div class="line"><span class="comment">// Increment the count if found otherwise insert a default value.</span></div>
<div class="line">Handle_index w =</div>
<div class="line">    array_adaptive_map_or_insert_with(</div>
<div class="line">        array_adaptive_map_and_modify_with(</div>
<div class="line">            handle_wrap(&amp;array_adaptive_map, &amp;k),</div>
<div class="line">            Word,</div>
<div class="line">            { T-&gt;cnt++; }</div>
<div class="line">        ),</div>
<div class="line">        (Word){.key = k, .cnt = 1}</div>
<div class="line">    );</div>
</div><!-- fragment --><p>Note that any code written is only evaluated if the handle is Occupied and the container can deliver the user type T. This means any function calls are lazily evaluated in the closure scope. </p>

</div>
</div>
<a id="a7107f7852dada205ca4ddcdce669ef56" name="a7107f7852dada205ca4ddcdce669ef56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7107f7852dada205ca4ddcdce669ef56">&#9670;&#160;</a></span>CCC_array_adaptive_map_as</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_as</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_index...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_array_adaptive_map_as(map_pointer, type_name, array_index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the user type in the table at the handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>name of the user type stored in each slot of the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_index</td><td>the index handle obtained from previous map operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the handle at handle in the map as the type the user has stored in the map. </dd></dl>

</div>
</div>
<a id="a411c1d286e78f2c5b2a26045aee802ce" name="a411c1d286e78f2c5b2a26045aee802ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411c1d286e78f2c5b2a26045aee802ce">&#9670;&#160;</a></span>CCC_array_adaptive_map_declare_fixed_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_declare_fixed_map</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fixed_map_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_array_adaptive_map_declare_fixed_map(fixed_map_type_name,      \</div>
<div class="line">                                                     type_name, capacity)</div>
</div><!-- fragment -->
<p>Declare a fixed size map type for use in the stack, heap, or data segment. Does not return a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_map_type_name</td><td>the user chosen name of the fixed sized map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the type the user plans to store in the map. It may have a key and value field as well as any additional fields. For set-like behavior, wrap a field in a struct/union (e.g. <code>union int_node {int e;};</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the desired number of user accessible nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>the map will use one slot of the specified capacity for a sentinel node. This is not important to the user unless an exact allocation count is needed in which case 1 should be added to desired capacity.</dd></dl>
<p>Once the location for the fixed size map is chosen&ndash;stack, heap, or data segment&ndash;provide a pointer to the map for the initialization macro.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><a class="code hl_define" href="array__adaptive__map_8h.html#a411c1d286e78f2c5b2a26045aee802ce">CCC_array_adaptive_map_declare_fixed_map</a>(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line"><span class="keyword">static</span> Array_adaptive_map static_map = array_adaptive_map_initialize(</div>
<div class="line">    &amp;(<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">    <span class="keyword">struct </span>Val,</div>
<div class="line">    key,</div>
<div class="line">    array_adaptive_map_key_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    array_adaptive_map_fixed_capacity(Small_fixed_map)</div>
<div class="line">);</div>
<div class="ttc" id="aarray__adaptive__map_8h_html_a411c1d286e78f2c5b2a26045aee802ce"><div class="ttname"><a href="array__adaptive__map_8h.html#a411c1d286e78f2c5b2a26045aee802ce">CCC_array_adaptive_map_declare_fixed_map</a></div><div class="ttdeci">#define CCC_array_adaptive_map_declare_fixed_map(fixed_map_type_name, type_name, capacity)</div><div class="ttdoc">Declare a fixed size map type for use in the stack, heap, or data segment. Does not return a value.</div><div class="ttdef"><b>Definition:</b> array_adaptive_map.h:152</div></div>
</div><!-- fragment --><p>Similarly, a fixed size map can be used on the stack.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><a class="code hl_define" href="array__adaptive__map_8h.html#a411c1d286e78f2c5b2a26045aee802ce">CCC_array_adaptive_map_declare_fixed_map</a>(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Array_adaptive_map map = array_adaptive_map_initialize(</div>
<div class="line">        &amp;(Small_fixed_map){},</div>
<div class="line">        <span class="keyword">struct </span>Val,</div>
<div class="line">        key,</div>
<div class="line">        array_adaptive_map_key_order,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        array_adaptive_map_fixed_capacity(Small_fixed_map)</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The CCC_array_adaptive_map_fixed_capacity macro can be used to obtain the previously provided capacity when declaring the fixed map type. Finally, one could allocate a fixed size map on the heap; however, it is usually better to initialize a dynamic map and use the CCC_array_adaptive_map_reserve function for such a use case.</p>
<p>This macro is not needed when a dynamic resizing map is needed. For dynamic maps, pass NULL and 0 capacity to the initialization macro along with the desired allocation function. </p>

</div>
</div>
<a id="a3cd82daf7a8cb0624eebefabb795d733" name="a3cd82daf7a8cb0624eebefabb795d733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd82daf7a8cb0624eebefabb795d733">&#9670;&#160;</a></span>CCC_array_adaptive_map_equal_range_reverse_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_equal_range_reverse_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reverse_begin_and_reverse_end_key_pointers...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="types_8h.html#aa24094a0fb5618980a629b4accdd37d7">CCC_Handle_range_reverse</a>)                                                \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_array_adaptive_map_equal_range_reverse(                            \</div>
<div class="line">            map_pointer, reverse_begin_and_reverse_end_key_pointers)           \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
<div class="ttc" id="atypes_8h_html_aa24094a0fb5618980a629b4accdd37d7"><div class="ttname"><a href="types_8h.html#aa24094a0fb5618980a629b4accdd37d7">CCC_Handle_range_reverse</a></div><div class="ttdeci">union CCC_Handle_range_reverse_wrap CCC_Handle_range_reverse</div><div class="ttdoc">The result of a range_reverse query on iterable containers.</div><div class="ttdef"><b>Definition:</b> types.h:68</div></div>
</div><!-- fragment -->
<p>Returns a compound literal reference to the desired range_reverse. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse_begin_and_reverse_end_key_pointers</td><td>pointers to the reverse_begin and reverse_end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the produced range_reverse associated with the enclosing scope. This reference is always valid. </dd></dl>

</div>
</div>
<a id="ac6d689f62b1ae8bffbe5443dc65f3491" name="ac6d689f62b1ae8bffbe5443dc65f3491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d689f62b1ae8bffbe5443dc65f3491">&#9670;&#160;</a></span>CCC_array_adaptive_map_equal_range_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_equal_range_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">begin_and_end_key_pointers...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Handle__range.html">CCC_Handle_range</a>)                                                        \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_array_adaptive_map_equal_range(map_pointer,                        \</div>
<div class="line">                                           begin_and_end_key_pointers)         \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
<div class="ttc" id="astructCCC__Handle__range_html"><div class="ttname"><a href="structCCC__Handle__range.html">CCC_Handle_range</a></div><div class="ttdef"><b>Definition:</b> private_types.h:173</div></div>
</div><!-- fragment -->
<p>Returns a compound literal reference to the desired range. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_and_end_key_pointers</td><td>pointers to the begin and end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the produced range associated with the enclosing scope. This reference is always be valid. </dd></dl>

</div>
</div>
<a id="a89e80f373bb1e9b7f5893fc79b4791ab" name="a89e80f373bb1e9b7f5893fc79b4791ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e80f373bb1e9b7f5893fc79b4791ab">&#9670;&#160;</a></span>CCC_array_adaptive_map_fixed_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_fixed_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fixed_map_type_name</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_array_adaptive_map_fixed_capacity(fixed_map_type_name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the capacity previously chosen for the fixed size map type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_map_type_name</td><td>the name of a previously declared map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size_t capacity previously specified for this type by user. </dd></dl>

</div>
</div>
<a id="af70d531a34998ec0218121458ef38aae" name="af70d531a34998ec0218121458ef38aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70d531a34998ec0218121458ef38aae">&#9670;&#160;</a></span>CCC_array_adaptive_map_from</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_from</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal_array...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_array_adaptive_map_from(type_key_field, compare, allocate,     \</div>
<div class="line">                                        context_data, optional_capacity,       \</div>
<div class="line">                                        type_compound_literal_array)</div>
</div><!-- fragment -->
<p>Initialize a dynamic map at runtime from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_key_field</td><td>the field of the struct used for key storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the CCC_Key_comparator the user intends to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>context data that is needed for hashing or comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_capacity</td><td>optionally specify the capacity of the map if different from the size of the compound literal array initializer. If the capacity is greater than the size of the compound literal array initializer, it is respected and the capacity is reserved. If the capacity is less than the size of the compound array initializer, the compound literal array initializer size is set as the capacity. Therefore, 0 is valid if one is not concerned with the size of the underlying reservation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal_array</td><td>a list of key value pairs of the type intended to be stored in the map, using array compound literal initialization syntax (e.g <code>(struct my_type[]){{.k = 0, .v 0}, {.k = 1, .v = 1}}</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map directly initialized on the right hand side of the equality operator (i.e. <a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> map = <a class="el" href="array__adaptive__map_8h.html#af70d531a34998ec0218121458ef38aae" title="Initialize a dynamic map at runtime from an initializer list.">CCC_array_adaptive_map_from(...)</a>;) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>An allocation function is required. This initializer is only available for dynamic maps. </dd>
<dd>
When duplicate keys appear in the initializer list, the last occurrence replaces earlier ones by value (all fields are overwritten). </dd>
<dd>
If initialization fails all subsequent queries, insertions, or removals will indicate the error: either memory related or lack of an allocation function provided.</dd></dl>
<p>Initialize a dynamic map at run time. This example requires no context data for initialization.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ARRAY_ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Array_adaptive_map static_map = array_adaptive_map_from(</div>
<div class="line">        key,</div>
<div class="line">        array_adaptive_map_key_order,</div>
<div class="line">        std_allocate,</div>
<div class="line">        NULL,</div>
<div class="line">        0,</div>
<div class="line">        (<span class="keyword">struct</span> Val[]) {</div>
<div class="line">            {.key = 1, .val = 1},</div>
<div class="line">            {.key = 2, .val = 2},</div>
<div class="line">            {.key = 3, .val = 3},</div>
<div class="line">        },</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Only dynamic maps may be initialized this way due the inability of the map map to protect its invariants from user error at compile time. </p>

</div>
</div>
<a id="a1746c2db663f3408059b8a025b6cfb96" name="a1746c2db663f3408059b8a025b6cfb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1746c2db663f3408059b8a025b6cfb96">&#9670;&#160;</a></span>CCC_array_adaptive_map_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="array__adaptive__map_8h.html#a67ce76b9053351d5eabb334544cb2530">CCC_Array_adaptive_map_handle</a>)                                           \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_array_adaptive_map_handle((array_pointer), (key_pointer)).private  \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Obtains a handle for the provided key in the map for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>the map to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>the key used to search the map matching the stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to a specialized handle for use with other functions in the Handle Interface. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the contents of a handle should not be examined or modified. Use the provided functions, only.</dd></dl>
<p>A handle is a search result that provides either an Occupied or Vacant handle in the map. An occupied handle signifies that the search was successful. A Vacant handle means the search was not successful but a handle is gained to where in the map such an element should be inserted.</p>
<p>A handle is rarely useful on its own. It should be passed in a functional style to subsequent calls in the Handle Interface. </p>

</div>
</div>
<a id="afb4c870e8ae161237fbe9fb16f1dc325" name="afb4c870e8ae161237fbe9fb16f1dc325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4c870e8ae161237fbe9fb16f1dc325">&#9670;&#160;</a></span>CCC_array_adaptive_map_initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_initialize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memory_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_intruder_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_array_adaptive_map_initialize(                                 \</div>
<div class="line">        memory_pointer, type_name, type_intruder_field, compare, allocate,     \</div>
<div class="line">        context_data, capacity)</div>
</div><!-- fragment -->
<p>Initializes the map at runtime or compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memory_pointer</td><td>a pointer to the contiguous user types or ((T )NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the user type stored in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_intruder_field</td><td>the name of the field in user type used as key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the key comparison function (see <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function or NULL if allocation is banned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>a pointer to any context data for comparison or destruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the capacity at data_pointer or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the struct initialized adaptive map for direct assignment (i.e. <a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> m = <a class="el" href="array__adaptive__map_8h.html#afb4c870e8ae161237fbe9fb16f1dc325" title="Initializes the map at runtime or compile time.">CCC_array_adaptive_map_initialize(...)</a>;). </dd></dl>

</div>
</div>
<a id="a6f15a63d7c037f810617791c38e9d4d4" name="a6f15a63d7c037f810617791c38e9d4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f15a63d7c037f810617791c38e9d4d4">&#9670;&#160;</a></span>CCC_array_adaptive_map_insert_array_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_insert_array_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_array_adaptive_map_insert_array_with(array_pointer,            \</div>
<div class="line">                                                     type_compound_literal)</div>
</div><!-- fragment -->
<p>Write the contents of the compound literal type_compound_literal to a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the obtained handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal to write to a new slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly inserted or overwritten user type. NULL is returned if allocation failed or is not allowed when required. </dd></dl>

</div>
</div>
<a id="a778a7ef33e0baa380904d704e3137a1b" name="a778a7ef33e0baa380904d704e3137a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778a7ef33e0baa380904d704e3137a1b">&#9670;&#160;</a></span>CCC_array_adaptive_map_insert_or_assign_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_insert_or_assign_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Handle.html">CCC_Handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_array_adaptive_map_insert_or_assign_with(                  \</div>
<div class="line">            map_pointer, key, type_compound_literal)                           \</div>
<div class="line">    }</div>
<div class="ttc" id="astructCCC__Handle_html"><div class="ttname"><a href="structCCC__Handle.html">CCC_Handle</a></div><div class="ttdef"><b>Definition:</b> private_types.h:80</div></div>
</div><!-- fragment -->
<p>Inserts a new key value pair or overwrites the existing handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key to be searched in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal to insert or use for overwrite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the handle of the existing or newly inserted value. Occupied indicates the key existed, Vacant indicates the key was absent. Unwrapping in any case provides the current value unless an error occurs that prevents insertion. An insertion error will flag such a case.</dd></dl>
<p>Note that for brevity and convenience the user need not write the key to the lazy value compound literal as well. This function ensures the key in the compound literal matches the searched key. </p>

</div>
</div>
<a id="a4b1ea6b149b2e49f2cf6484e747e40f6" name="a4b1ea6b149b2e49f2cf6484e747e40f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1ea6b149b2e49f2cf6484e747e40f6">&#9670;&#160;</a></span>CCC_array_adaptive_map_or_insert_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_or_insert_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_array_adaptive_map_or_insert_with(array_pointer,               \</div>
<div class="line">                                                  type_compound_literal)</div>
</div><!-- fragment -->
<p>Lazily insert the desired key value into the handle if it is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the obtained handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal to construct in place if the handle is Vacant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the unwrapped user type in the handle, either the unmodified reference if the handle was Occupied or the newly inserted element if the handle was Vacant. NULL is returned if resizing is required but fails or is not allowed.</dd></dl>
<p>Note that if the compound literal uses any function calls to generate values or other data, such functions will not be called if the handle is Occupied. </p>

</div>
</div>
<a id="a331d96f78d0c0706c60a44eb53fd29ae" name="a331d96f78d0c0706c60a44eb53fd29ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331d96f78d0c0706c60a44eb53fd29ae">&#9670;&#160;</a></span>CCC_array_adaptive_map_remove_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_remove_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Handle.html">CCC_Handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_array_adaptive_map_remove_handle((array_pointer)).private          \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the handle from the map if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>pointer to the map handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference containing no valid reference but information about the old handle. If Occupied a handle in the map existed and was removed. If Vacant, no prior handle existed to be removed. </dd></dl>

</div>
</div>
<a id="abe7e3b59cd02463e1724f493d590d91e" name="abe7e3b59cd02463e1724f493d590d91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7e3b59cd02463e1724f493d590d91e">&#9670;&#160;</a></span>CCC_array_adaptive_map_remove_key_value_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_remove_key_value_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_output_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Handle.html">CCC_Handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_array_adaptive_map_remove_key_value((map_pointer),                 \</div>
<div class="line">                                                (type_output_pointer))         \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Removes the key value in the map storing the old value, if present, in the struct containing type_output provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the adaptive map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output_pointer</td><td>the handle to the user type wrapping map elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to a handle. If Occupied the struct containing type_output holds the old value. If Vacant the key value pair was not stored in the map. If bad input is provided an input error is set.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in a handle to provide information about the old value. </p>

</div>
</div>
<a id="ae38d277c09750eaf0a57250b8122f808" name="ae38d277c09750eaf0a57250b8122f808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38d277c09750eaf0a57250b8122f808">&#9670;&#160;</a></span>CCC_array_adaptive_map_swap_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_swap_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_output_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Handle.html">CCC_Handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_array_adaptive_map_swap_handle((map_pointer),                      \</div>
<div class="line">                                           (type_output_pointer))              \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invariantly inserts the key value wrapping type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the adaptive map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output_pointer</td><td>the handle to the user type wrapping map elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to a handle. If Vacant, no prior element with key existed and the type wrapping type_output remains unchanged. If Occupied the old value is written to the type wrapping type_output and may be unwrapped to view. If more space is needed but allocation fails or has been forbidden, an insert error is set.</dd></dl>
<p>Note that this function may write to the struct containing type_output and wraps it in a handle to provide information about the old value. </p>

</div>
</div>
<a id="abe39139c57071844161f3bfdb9a38b14" name="abe39139c57071844161f3bfdb9a38b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe39139c57071844161f3bfdb9a38b14">&#9670;&#160;</a></span>CCC_array_adaptive_map_try_insert_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_try_insert_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Handle.html">CCC_Handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_array_adaptive_map_try_insert_with(map_pointer, key,       \</div>
<div class="line">                                                       type_compound_literal)  \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>lazily insert type_compound_literal into the map at key if key is absent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the direct key r-value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal specifying the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the handle of the existing or newly inserted value. Occupied indicates the key existed, Vacant indicates the key was absent. Unwrapping in any case provides the current value unless an error occurs that prevents insertion. An insertion error will flag such a case.</dd></dl>
<p>Note that for brevity and convenience the user need not write the key to the lazy value compound literal as well. This function ensures the key in the compound literal matches the searched key. </p>

</div>
</div>
<a id="a69c9caa87fd345aeedb51f1a6bbd7051" name="a69c9caa87fd345aeedb51f1a6bbd7051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c9caa87fd345aeedb51f1a6bbd7051">&#9670;&#160;</a></span>CCC_array_adaptive_map_try_insert_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_try_insert_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Handle.html">CCC_Handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_array_adaptive_map_try_insert((map_pointer), (type_pointer))       \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Attempts to insert the key value wrapping type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_pointer</td><td>the handle to the user type wrapping map elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to a handle. If Occupied, the handle contains a reference to the key value user type in the map and may be unwrapped. If Vacant the handle contains a reference to the newly inserted handle in the map. If more space is needed but allocation fails an insert error is set. </dd></dl>

</div>
</div>
<a id="afc2379e48c78cbcf77f9fcf8567d6b0d" name="afc2379e48c78cbcf77f9fcf8567d6b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2379e48c78cbcf77f9fcf8567d6b0d">&#9670;&#160;</a></span>CCC_array_adaptive_map_with_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_array_adaptive_map_with_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_array_adaptive_map_with_capacity(                              \</div>
<div class="line">        type_name, type_key_field, compare, allocate, context_data, capacity)</div>
</div><!-- fragment -->
<p>Initialize a dynamic map at runtime with at least the specified capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the type being stored in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_key_field</td><td>the field of the struct used for key storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the CCC_Key_comparator the user intends to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>context data that is needed for comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the desired capacity for the map. A capacity of 0 results in an argument error and is a no-op after the map is initialized empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map directly initialized on the right hand side of the equality operator (i.e. <a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> map = <a class="el" href="array__adaptive__map_8h.html#afc2379e48c78cbcf77f9fcf8567d6b0d" title="Initialize a dynamic map at runtime with at least the specified capacity.">CCC_array_adaptive_map_with_capacity(...)</a>;) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>An allocation function is required. This initializer is only available for dynamic maps. </dd>
<dd>
If initialization fails all subsequent queries, insertions, or removals will indicate the error: either memory related or lack of an allocation function provided.</dd></dl>
<p>Initialize a dynamic map at run time. This example requires no context data for initialization.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ARRAY_ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Array_adaptive_map map = array_adaptive_map_with_capacity(</div>
<div class="line">        <span class="keyword">struct</span> Val,</div>
<div class="line">        key,</div>
<div class="line">        array_adaptive_map_key_order,</div>
<div class="line">        std_allocate,</div>
<div class="line">        NULL,</div>
<div class="line">        4096</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Only dynamic maps may be initialized this way as it simply combines the steps of initialization and reservation. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3383e02ece054e21edbc2a638d3567f9" name="a3383e02ece054e21edbc2a638d3567f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3383e02ece054e21edbc2a638d3567f9">&#9670;&#160;</a></span>CCC_Array_adaptive_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> <a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A self-optimizing data structure offering amortized O(lg N) search, insert, and erase. </p>
<dl class="section warning"><dt>Warning</dt><dd>it is undefined behavior to access an uninitialized container.</dd></dl>
<p>An array adaptive map can be initialized on the stack, heap, or data segment at runtime or compile time. </p>

</div>
</div>
<a id="a67ce76b9053351d5eabb334544cb2530" name="a67ce76b9053351d5eabb334544cb2530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ce76b9053351d5eabb334544cb2530">&#9670;&#160;</a></span>CCC_Array_adaptive_map_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionCCC__Array__adaptive__map__handle__wrap.html">CCC_Array_adaptive_map_handle_wrap</a> <a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container specific handle used to implement the Handle Interface. </p>
<p>The Handle Interface offers efficient search and subsequent insertion, deletion, or value update based on the needs of the user. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a058ecd325865647858f89b14e6e6a9e3" name="a058ecd325865647858f89b14e6e6a9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058ecd325865647858f89b14e6e6a9e3">&#9670;&#160;</a></span>CCC_array_adaptive_map_and_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> * CCC_array_adaptive_map_and_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *&#160;</td>
          <td class="paramname"><em>modify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the provided handle if it is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the handle obtained from a handle function or macro. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify</td><td>an update function in which the context argument is unused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated handle if it was Occupied or the unmodified vacant handle.</dd></dl>
<p>This function is intended to make the function chaining in the Handle Interface more succinct if the handle will be modified in place based on its own value without the need of the context argument a CCC_Type_modifier can provide. </p>

</div>
</div>
<a id="a360847e030447c7150da28a91bd8e349" name="a360847e030447c7150da28a91bd8e349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360847e030447c7150da28a91bd8e349">&#9670;&#160;</a></span>CCC_array_adaptive_map_and_modify_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> * CCC_array_adaptive_map_and_modify_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *&#160;</td>
          <td class="paramname"><em>modify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the provided handle if it is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the handle obtained from a handle function or macro. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify</td><td>an update function that requires context data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>context data required for the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated handle if it was Occupied or the unmodified vacant handle.</dd></dl>
<p>This function makes full use of a CCC_Type_modifier capability, meaning a complete CCC_update object will be passed to the update function callback. </p>

</div>
</div>
<a id="a59a3b1e7db48fb6daec6f36df24dbe0f" name="a59a3b1e7db48fb6daec6f36df24dbe0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a3b1e7db48fb6daec6f36df24dbe0f">&#9670;&#160;</a></span>CCC_array_adaptive_map_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_array_adaptive_map_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the user data at the provided handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the stable handle obtained by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type stored at the specified handle or NULL if an out of range handle or handle representing no data is provided. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this function can only check if the handle value is in range. If a handle represents a slot that has been taken by a new element because the old one has been removed that new element data will be returned. </dd>
<dd>
do not try to access data in the table manually with a handle. Always use this provided interface function when a reference to data is needed. </dd></dl>

</div>
</div>
<a id="ad87a0958591245c4d18082f5ab06b20c" name="ad87a0958591245c4d18082f5ab06b20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87a0958591245c4d18082f5ab06b20c">&#9670;&#160;</a></span>CCC_array_adaptive_map_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the start of an inorder traversal of the map. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle for the minimum element of the map. </dd></dl>

</div>
</div>
<a id="aee105753e1d54612949fe826bc187092" name="aee105753e1d54612949fe826bc187092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee105753e1d54612949fe826bc187092">&#9670;&#160;</a></span>CCC_array_adaptive_map_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_array_adaptive_map_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the capacity of the map representing total possible slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity or an argument error is set if array_adaptive_map is NULL. </dd></dl>

</div>
</div>
<a id="a7d7640632d28dcb6f4f780ec97abcc2f" name="a7d7640632d28dcb6f4f780ec97abcc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7640632d28dcb6f4f780ec97abcc2f">&#9670;&#160;</a></span>CCC_array_adaptive_map_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_array_adaptive_map_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the map for use without affecting capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the map before their slots are forfeit.</td></tr>
  </table>
  </dd>
</dl>
<p>If NULL is passed as the destructor function time is O(1), else O(size). </p>

</div>
</div>
<a id="afe0554a3e3d434b715fa8358370e119a" name="afe0554a3e3d434b715fa8358370e119a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0554a3e3d434b715fa8358370e119a">&#9670;&#160;</a></span>CCC_array_adaptive_map_clear_and_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_array_adaptive_map_clear_and_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the map and frees the underlying buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the map before their slots are forfeit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of free operation. If no allocate function is provided it is an error to attempt to free the Buffer and a memory error is returned. Otherwise, an OK result is returned.</dd></dl>
<p>If NULL is passed as the destructor function time is O(1), else O(size). </p>

</div>
</div>
<a id="a5eeea17f39c030003d233a78c258ea6e" name="a5eeea17f39c030003d233a78c258ea6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeea17f39c030003d233a78c258ea6e">&#9670;&#160;</a></span>CCC_array_adaptive_map_clear_and_free_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_array_adaptive_map_clear_and_free_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the array_adaptive_map and frees the underlying Buffer that was previously dynamically reserved with the reserve function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the array_adaptive_map before their slots are dropped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function to provide to a dynamically reserved array_adaptive_map. Any context data provided upon initialization will be passed to the allocation function when called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of free operation. OK if success, or an error status to indicate the error. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is an error to call this function on a array_adaptive_map that was not reserved with the provided CCC_Allocator. The array_adaptive_map must have existing memory to free.</dd></dl>
<p>This function covers the edge case of reserving a dynamic capacity for a array_adaptive_map at runtime but denying the array_adaptive_map allocation permission to resize. This can help prevent a array_adaptive_map from growing untree. The user in this case knows the array_adaptive_map does not have allocation permission and therefore no further memory will be dedicated to the array_adaptive_map.</p>
<p>However, to free the array_adaptive_map in such a case this function must be used because the array_adaptive_map has no ability to free itself. Just as the allocation function is required to reserve memory so to is it required to free memory.</p>
<p>This function will work normally if called on a array_adaptive_map with allocation permission however the normal CCC_array_adaptive_map_clear_and_free is sufficient for that use case. </p>

</div>
</div>
<a id="ad6066660ff6db8775634ec22c44cda83" name="ad6066660ff6db8775634ec22c44cda83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6066660ff6db8775634ec22c44cda83">&#9670;&#160;</a></span>CCC_array_adaptive_map_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_array_adaptive_map_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the map for the presence of key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>pointer to the key matching the key type of the user struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the struct containing key is stored, false if not. Error if array_adaptive_map or key is NULL. </dd></dl>

</div>
</div>
<a id="a0547f59ae3d0b1297228816fa22e39df" name="a0547f59ae3d0b1297228816fa22e39df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0547f59ae3d0b1297228816fa22e39df">&#9670;&#160;</a></span>CCC_array_adaptive_map_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_array_adaptive_map_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the map at source to destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>the initialized destination for the copy of the source map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the initialized source of the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function to resize destination or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the copy operation. If the destination capacity is less than the source capacity and no allocation function is provided an input error is returned. If resizing is required and resizing of destination fails a memory error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>destination must have capacity greater than or equal to source. If destination capacity is less than source, an allocation function must be provided with the fn argument.</dd></dl>
<p>Note that there are two ways to copy data from source to destination: provide sufficient memory and pass NULL as fn, or allow the copy function to take care of allocation for the copy.</p>
<p>Manual memory management with no allocation function provided.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ARRAY_ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><a class="code hl_define" href="array__adaptive__map_8h.html#a411c1d286e78f2c5b2a26045aee802ce">CCC_array_adaptive_map_declare_fixed_map</a>(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line"><span class="keyword">static</span> Array_tree_map source = array_adaptive_map_initialize(</div>
<div class="line">    &amp;(<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">    <span class="keyword">struct </span>Val,</div>
<div class="line">    key,</div>
<div class="line">    array_adaptive_map_key_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    array_adaptive_map_fixed_capacity(Small_fixed_map)</div>
<div class="line">);</div>
<div class="line">insert_rand_vals(&amp;source);</div>
<div class="line"><span class="keyword">static</span> Array_tree_map destination = array_adaptive_map_initialize(</div>
<div class="line">    &amp;(<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">    <span class="keyword">struct </span>Val,</div>
<div class="line">    key,</div>
<div class="line">    array_adaptive_map_key_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    array_adaptive_map_fixed_capacity(Small_fixed_map)</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = array_adaptive_map_copy(&amp;destination, &amp;source, NULL);</div>
<div class="ttc" id="atypes_8h_html_aa1ded61d294b114942f11e711b331dcf"><div class="ttname"><a href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a></div><div class="ttdeci">CCC_Result</div><div class="ttdoc">A result of actions on containers.</div><div class="ttdef"><b>Definition:</b> types.h:148</div></div>
</div><!-- fragment --><p>The above requires destination capacity be greater than or equal to source capacity. Here is memory management handed over to the copy function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ARRAY_ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> Array_adaptive_map source = array_adaptive_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    key_order,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line">insert_rand_vals(&amp;source);</div>
<div class="line"><span class="keyword">static</span> Array_adaptive_map destination = array_adaptive_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    key_order,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = array_adaptive_map_copy(&amp;destination, &amp;source, std_allocate);</div>
</div><!-- fragment --><p>The above allows destination to have a capacity less than that of the source as long as copy has been provided an allocation function to resize destination. Note that this would still work if copying to a destination that the user wants as a fixed size map.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ARRAY_ADAPTIVE_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> Array_adaptive_map source = array_adaptive_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    key_order,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line">insert_rand_vals(&amp;source);</div>
<div class="line"><span class="keyword">static</span> Array_adaptive_map destination = array_adaptive_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    key_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res</div>
<div class="line">    = array_adaptive_map_copy(&amp;destination, &amp;source, std_allocate);</div>
</div><!-- fragment --><p>The above sets up destination with fixed size while source is a dynamic map. Because an allocation function is provided, the destination is resized once for the copy and retains its fixed size after the copy is complete. This would require the user to manually free the underlying Buffer at destination eventually if this method is used. Usually it is better to allocate the memory explicitly before the copy if copying between maps without allocation permission.</p>
<p>These options allow users to stay consistent across containers with their memory management strategies. </p>

</div>
</div>
<a id="a88e7f7da52c9d9ae7355a6872edac3eb" name="a88e7f7da52c9d9ae7355a6872edac3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e7f7da52c9d9ae7355a6872edac3eb">&#9670;&#160;</a></span>CCC_array_adaptive_map_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_array_adaptive_map_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the count of map occupied slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the map or an argument error is set if array_adaptive_map is NULL. </dd></dl>

</div>
</div>
<a id="ab311d349c681b7748451f9bd1eff34f8" name="ab311d349c681b7748451f9bd1eff34f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab311d349c681b7748451f9bd1eff34f8">&#9670;&#160;</a></span>CCC_array_adaptive_map_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the end of an inorder traversal of the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle for the maximum element of the map. </dd></dl>

</div>
</div>
<a id="acb4a40014feb193966eeeaf61e8392db" name="acb4a40014feb193966eeeaf61e8392db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4a40014feb193966eeeaf61e8392db">&#9670;&#160;</a></span>CCC_array_adaptive_map_equal_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Handle__range.html">CCC_Handle_range</a> CCC_array_adaptive_map_equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>begin_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>end_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterable range of values from [begin_key, end_key). Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_key</td><td>a pointer to the key intended as the start of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_key</td><td>a pointer to the key intended as the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range containing the first element NOT LESS than the begin_key and the first element GREATER than end_key.</dd></dl>
<p>Note that due to the variety of values that can be returned in the range, using the provided range iteration functions from <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a> or <a class="el" href="traits_8h.html" title="The C Container Collection Traits Interface.">traits.h</a> is recommended for example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> index = range_begin(&amp;range);</div>
<div class="line">     index != range_end(&amp;range);</div>
<div class="line">     index = next(&amp;map, index))</div>
<div class="line">{}</div>
<div class="ttc" id="atypes_8h_html_a4043390f03f4ec5162e3782152360be9"><div class="ttname"><a href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a></div><div class="ttdeci">size_t CCC_Handle_index</div><div class="ttdoc">A stable index to user data in a container that uses a flat array as the underlying storage method.</div><div class="ttdef"><b>Definition:</b> types.h:109</div></div>
</div><!-- fragment --><p>This avoids any possible errors in handling an end range element that is in the map versus the end map sentinel. </p>

</div>
</div>
<a id="ac72607889c33e4fe4aee675bb7562fc5" name="ac72607889c33e4fe4aee675bb7562fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72607889c33e4fe4aee675bb7562fc5">&#9670;&#160;</a></span>CCC_array_adaptive_map_equal_range_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa24094a0fb5618980a629b4accdd37d7">CCC_Handle_range_reverse</a> CCC_array_adaptive_map_equal_range_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>reverse_begin_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>reverse_end_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterable range_reverse of values from [reverse_begin_key, end_key). Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse_begin_key</td><td>a pointer to the key intended as the start of the range_reverse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse_end_key</td><td>a pointer to the key intended as the end of the range_reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range_reverse containing the first element NOT GREATER than the begin_key and the first element LESS than reverse_end_key.</dd></dl>
<p>Note that due to the variety of values that can be returned in the range_reverse, using the provided range_reverse iteration functions from <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a> or <a class="el" href="traits_8h.html" title="The C Container Collection Traits Interface.">traits.h</a> is recommended for example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> index = range_reverse_begin(&amp;range);</div>
<div class="line">     index != range_reverse_end(&amp;range);</div>
<div class="line">     index = next(&amp;map, index))</div>
<div class="line">{}</div>
</div><!-- fragment --><p>This avoids any possible errors in handling an reverse_end range_reverse element that is in the map versus the end map sentinel. </p>

</div>
</div>
<a id="a956042ad2f4073329e6bf251869f0146" name="a956042ad2f4073329e6bf251869f0146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956042ad2f4073329e6bf251869f0146">&#9670;&#160;</a></span>CCC_array_adaptive_map_get_key_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_get_key_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference into the map at handle key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the adaptive map to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key to search matching stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the map handle if it is present, else NULL. </dd></dl>

</div>
</div>
<a id="adc4229d887c2308cc660616136695726" name="adc4229d887c2308cc660616136695726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4229d887c2308cc660616136695726">&#9670;&#160;</a></span>CCC_array_adaptive_map_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> CCC_array_adaptive_map_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a handle for the provided key in the map for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key used to search the map matching the stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a specialized handle for use with other functions in the Handle Interface. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the contents of a handle should not be examined or modified. Use the provided functions, only.</dd></dl>
<p>A handle is a search result that provides either an Occupied or Vacant handle in the map. An occupied handle signifies that the search was successful. A Vacant handle means the search was not successful but a handle is gained to where in the map such an element should be inserted.</p>
<p>A handle is rarely useful on its own. It should be passed in a functional style to subsequent calls in the Handle Interface. </p>

</div>
</div>
<a id="a8c5ccaca69382f2733c1b38776ef4cea" name="a8c5ccaca69382f2733c1b38776ef4cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5ccaca69382f2733c1b38776ef4cea">&#9670;&#160;</a></span>CCC_array_adaptive_map_handle_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a282e45f45cb2493ec1709942eb5d958d">CCC_Handle_status</a> CCC_array_adaptive_map_handle_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the handle status from a container handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>a pointer to the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the status stored in the handle after the required action on the container completes. If h is NULL a handle input error is returned so ensure e is non-NULL to avoid an inaccurate status returned.</dd></dl>
<p>Note that this function can be useful for debugging or if more detailed messages are needed for logging purposes. See <a class="el" href="types_8h.html#af6a83e001fc3b4308832db6da69d8277" title="Obtain a string message with a description of the handle status.">CCC_handle_status_message()</a> in <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">ccc/types.h</a> for more information on detailed handle statuses. </p>

</div>
</div>
<a id="a2bf8f60286f2b25f56244f12f84ef1b6" name="a2bf8f60286f2b25f56244f12f84ef1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf8f60286f2b25f56244f12f84ef1b6">&#9670;&#160;</a></span>CCC_array_adaptive_map_insert_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_array_adaptive_map_insert_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the status of the handle should an insertion follow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the handle from a query to the table via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a handle obtained from an insertion attempt failed to insert due to an allocation failure when allocation success was expected. Error if h is NULL. </dd></dl>

</div>
</div>
<a id="ad57ee6a897f22ff36add416aeda62363" name="ad57ee6a897f22ff36add416aeda62363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57ee6a897f22ff36add416aeda62363">&#9670;&#160;</a></span>CCC_array_adaptive_map_insert_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_insert_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the provided handle invariantly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the handle returned from a call obtaining a handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>a handle to the struct the user intends to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inserted element or NULL upon allocation failure.</dd></dl>
<p>This method can be used when the old value in the map does not need to be preserved. See the regular insert method if the old value is of interest. </p>

</div>
</div>
<a id="aacdf570b3ea9a14f0e6c3e32c30bb29c" name="aacdf570b3ea9a14f0e6c3e32c30bb29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf570b3ea9a14f0e6c3e32c30bb29c">&#9670;&#160;</a></span>CCC_array_adaptive_map_insert_or_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Handle.html">CCC_Handle</a> CCC_array_adaptive_map_insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts or overwrites a user struct into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the handle to the wrapping user struct key value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle. If Occupied a handle was overwritten by the new key value. If Vacant no prior map handle existed.</dd></dl>
<p>Note that this function can be used when the old user type is not needed but the information regarding its presence is helpful. </p>

</div>
</div>
<a id="aa656d9645bcc7ccb2f603391089873b0" name="aa656d9645bcc7ccb2f603391089873b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa656d9645bcc7ccb2f603391089873b0">&#9670;&#160;</a></span>CCC_array_adaptive_map_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_array_adaptive_map_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size status of the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty else false. Error if array_adaptive_map is NULL. </dd></dl>

</div>
</div>
<a id="ad72c7016d5338f34ac39b3759b8997ba" name="ad72c7016d5338f34ac39b3759b8997ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72c7016d5338f34ac39b3759b8997ba">&#9670;&#160;</a></span>CCC_array_adaptive_map_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next element in an inorder traversal of the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>pointer to the current iterator user type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle for the next user type stored in the map in an inorder traversal. </dd></dl>

</div>
</div>
<a id="afe7d559597dacbe157cfc6d2e7bea051" name="afe7d559597dacbe157cfc6d2e7bea051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7d559597dacbe157cfc6d2e7bea051">&#9670;&#160;</a></span>CCC_array_adaptive_map_occupied()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_array_adaptive_map_occupied </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Vacant or Occupied status of the handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the handle from a query to the map via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the handle is occupied, false if not. Error if h is NULL. </dd></dl>

</div>
</div>
<a id="a44f38daab50a3397e9f8f13f27aa6cef" name="a44f38daab50a3397e9f8f13f27aa6cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f38daab50a3397e9f8f13f27aa6cef">&#9670;&#160;</a></span>CCC_array_adaptive_map_or_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_or_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the struct with user type if the handle is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the handle obtained via function or macro call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>handle to the struct to be inserted to Vacant handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to handle in the map invariantly. NULL on error.</dd></dl>
<p>Because this functions takes a handle and inserts if it is Vacant, the only reason NULL shall be returned is when an insertion error occurs, usually due to a user struct allocation failure.</p>
<p>If no allocation is permitted, this function assumes the user struct wrapping elem has been allocated with the appropriate lifetime and scope by the user. </p>

</div>
</div>
<a id="a7ead4b3654a7cb197b2236e27c6e06e6" name="a7ead4b3654a7cb197b2236e27c6e06e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ead4b3654a7cb197b2236e27c6e06e6">&#9670;&#160;</a></span>CCC_array_adaptive_map_remove_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Handle.html">CCC_Handle</a> CCC_array_adaptive_map_remove_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the handle from the map if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>a pointer to the map handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle containing no valid reference but information about removed element. If Occupied a handle in the map existed and was removed. If Vacant, no prior handle existed to be removed. </dd></dl>

</div>
</div>
<a id="aab51d4696e0a25ea272e46c35c200dd8" name="aab51d4696e0a25ea272e46c35c200dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab51d4696e0a25ea272e46c35c200dd8">&#9670;&#160;</a></span>CCC_array_adaptive_map_remove_key_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Handle.html">CCC_Handle</a> CCC_array_adaptive_map_remove_key_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>type_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the key value in the map storing the old value, if present, in the struct containing type_output provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the adaptive map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output</td><td>the handle to the user type wrapping map elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed handle. If Occupied the struct containing type_output holds the old value. If Vacant the key value pair was not stored in the map. If bad input is provided an input error is set.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in a handle to provide information about the old value. </p>

</div>
</div>
<a id="a052a37b91d2460ef5415c4a21fa92494" name="a052a37b91d2460ef5415c4a21fa92494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052a37b91d2460ef5415c4a21fa92494">&#9670;&#160;</a></span>CCC_array_adaptive_map_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_array_adaptive_map_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves space for at least to_add more elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the array adaptive map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_add</td><td>the number of elements to add to the current size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function to use to reserve memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the reservation. OK if successful, otherwise an error status is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see the CCC_array_adaptive_map_clear_and_free_reserve function if this function is being used for a one-time dynamic reservation.</dd></dl>
<p>This function can be used for a dynamic array_adaptive_map with or without allocation permission. If the array_adaptive_map has allocation permission, it will reserve the required space and later resize if more space is needed.</p>
<p>If the array_adaptive_map has been initialized with no allocation permission and no memory this function can serve as a one-time reservation. This is helpful when a fixed size is needed but that size is only known dynamically at runtime. To free the array_adaptive_map in such a case see the CCC_array_adaptive_map_clear_and_free_reserve function. </p>

</div>
</div>
<a id="ab3d56d3ffc6e1b1dfe2e042679fde994" name="ab3d56d3ffc6e1b1dfe2e042679fde994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d56d3ffc6e1b1dfe2e042679fde994">&#9670;&#160;</a></span>CCC_array_adaptive_map_reverse_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_reverse_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the start of a reverse inorder traversal of the map. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle for the maximum element of the map. </dd></dl>

</div>
</div>
<a id="a7f1a2b8804ec4f9d9023b04d08f63bdd" name="a7f1a2b8804ec4f9d9023b04d08f63bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1a2b8804ec4f9d9023b04d08f63bdd">&#9670;&#160;</a></span>CCC_array_adaptive_map_reverse_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_reverse_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse_end of a reverse inorder traversal of the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle for the minimum element of the map. </dd></dl>

</div>
</div>
<a id="af4bafba311dacf5f381d4badd03e74f3" name="af4bafba311dacf5f381d4badd03e74f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bafba311dacf5f381d4badd03e74f3">&#9670;&#160;</a></span>CCC_array_adaptive_map_reverse_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_reverse_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse_next element in a reverse inorder traversal of the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>pointer to the current iterator user type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle for the reverse_next user type stored in the map in a reverse inorder traversal. </dd></dl>

</div>
</div>
<a id="a12e3313f0460ecdb3140ad48de2e3d61" name="a12e3313f0460ecdb3140ad48de2e3d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e3313f0460ecdb3140ad48de2e3d61">&#9670;&#160;</a></span>CCC_array_adaptive_map_swap_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Handle.html">CCC_Handle</a> CCC_array_adaptive_map_swap_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>type_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts the key value wrapping type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the adaptive map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output</td><td>the handle to the user type wrapping map elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle. If Vacant, no prior element with key existed and the type wrapping type_output remains unchanged. If Occupied the old value is written to the type wrapping type_output and may be unwrapped to view. If more space is needed but allocation fails or has been forbidden, an insert error is set.</dd></dl>
<p>Note that this function may write to the struct containing type_output and wraps it in a handle to provide information about the old value. </p>

</div>
</div>
<a id="a615526c758a02c6c994784d21eb756fe" name="a615526c758a02c6c994784d21eb756fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615526c758a02c6c994784d21eb756fe">&#9670;&#160;</a></span>CCC_array_adaptive_map_try_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Handle.html">CCC_Handle</a> CCC_array_adaptive_map_try_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert the key value wrapping type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the handle to the user type wrapping map elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle. If Occupied, the handle contains a reference to the key value user type in the map and may be unwrapped. If Vacant the handle contains a reference to the newly inserted handle in the map. If more space is needed but allocation fails, an insert error is set. </dd></dl>

</div>
</div>
<a id="ac3f476486c9b0a433f3ee32a4fefeaff" name="ac3f476486c9b0a433f3ee32a4fefeaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f476486c9b0a433f3ee32a4fefeaff">&#9670;&#160;</a></span>CCC_array_adaptive_map_unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a4043390f03f4ec5162e3782152360be9">CCC_Handle_index</a> CCC_array_adaptive_map_unwrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map__handle.html">CCC_Array_adaptive_map_handle</a> const *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwraps the provided handle to obtain a view into the map element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the handle from a query to the map via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view into the table handle if one is present, or NULL. </dd></dl>

</div>
</div>
<a id="a02f607d8d9612c0bb2222c8bf5a4377c" name="a02f607d8d9612c0bb2222c8bf5a4377c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f607d8d9612c0bb2222c8bf5a4377c">&#9670;&#160;</a></span>CCC_array_adaptive_map_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_array_adaptive_map_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Array__adaptive__map.html">CCC_Array_adaptive_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validation of invariants for the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the map to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all invariants hold, false if corruption occurs. Error if array_adaptive_mape is NULL. <br  />
 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="array__adaptive__map_8h.html">array_adaptive_map.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
