<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/buffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('buffer_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">buffer.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Buffer Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;private/private_buffer.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for buffer.h:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h__incl.png" border="0" usemap="#accc_2buffer_8h" alt=""/></div>
<map name="accc_2buffer_8h" id="accc_2buffer_8h">
<area shape="rect" title="The Buffer Interface." alt="" coords="107,5,203,31"/>
<area shape="rect" href="private__buffer_8h_source.html" title=" " alt="" coords="5,79,180,104"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="114,152,197,177"/>
<area shape="rect" href="private__types_8h_source.html" title=" " alt="" coords="69,225,242,251"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h__dep__incl.png" border="0" usemap="#accc_2buffer_8hdep" alt=""/></div>
<map name="accc_2buffer_8hdep" id="accc_2buffer_8hdep">
<area shape="rect" title="The Buffer Interface." alt="" coords="116,5,212,31"/>
<area shape="rect" href="flat__priority__queue_8h.html" title="The Flat Priority Queue Interface." alt="" coords="5,174,187,199"/>
<area shape="rect" href="private__traits_8h_source.html" title=" " alt="" coords="153,255,295,295"/>
<area shape="rect" href="private__flat__double__ended__queue_8h_source.html" title=" " alt="" coords="262,79,469,119"/>
<area shape="rect" href="private__flat__priority__queue_8h_source.html" title=" " alt="" coords="24,79,187,119"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="177,343,271,368"/>
<area shape="rect" href="flat__double__ended__queue_8h.html" title="The Flat Double Ended Queue Interface." alt="" coords="271,167,438,207"/>
</map>
</div>
</div>
<p><a href="buffer_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Buffer Interface. </p>
<p>Buffer usage is similar to a C++ vector, with more flexible functions provided to support higher level containers and abstractions. While useful on its own&ndash;a stack could be implemented with the provided functions&ndash;a buffer is often used as the lower level abstraction for the flat data structures in this library that provide more specialized operations. A Buffer does not require the user accommodate any intrusive elements.</p>
<p>A Buffer offers a more flexible interface than a standard C++ vector. There are functions that assume elements are stored contiguously from <code>[0, N)</code> where <code>N</code> is the count of elements. However, there are also functions that let the user access any Buffer slot that is within the bounds of Buffer capacity. This requires the user pay closer attention to Buffer usage but ultimately allows a wider variety of abstractions on top of the buffer.</p>
<p>Interface functions in the slot management section offer data movement and writing operations that do not affect the size of the container. If writing a more complex higher level container that does not need size management these functions offer more custom control over the buffer.</p>
<p>A Buffer with allocation permission will re-size as required when a new element is inserted in a contiguous fashion. Interface functions in the allocation management section assume elements are stored contiguously and adjust size accordingly.</p>
<p>If allocation is not permitted, resizing will not occur and the insertion function will fail when capacity is reached, returning some value to indicate failure.</p>
<p>If shorter names are desired, define the following preprocessor directive.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>Then, the <code>CCC_</code> prefix can be dropped from all types and functions. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Initialize the container with memory, callbacks, and permissions. </p>
</td></tr>
<tr class="memitem:ac3e1da3a4a6c2e2f47da32769cf6bd74"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ac3e1da3a4a6c2e2f47da32769cf6bd74">CCC_buffer_initialize</a>(data_pointer,  type_name,  allocate,  context_data,  capacity,  optional_count...)</td></tr>
<tr class="memdesc:ac3e1da3a4a6c2e2f47da32769cf6bd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a contiguous Buffer of user a specified type, allocation policy, capacity, and optional starting size.  <br /></td></tr>
<tr class="separator:ac3e1da3a4a6c2e2f47da32769cf6bd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb78598277e9204689fda554bc892fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#adfb78598277e9204689fda554bc892fa">CCC_buffer_from</a>(allocate,  context_data,  optional_capacity,  compound_literal_array...)</td></tr>
<tr class="memdesc:adfb78598277e9204689fda554bc892fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Buffer from a compound literal array initializer.  <br /></td></tr>
<tr class="separator:adfb78598277e9204689fda554bc892fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2226fb14031e86b6e43864058a176b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af2226fb14031e86b6e43864058a176b1">CCC_buffer_with_capacity</a>(type_name,  allocate,  context_data,  capacity)</td></tr>
<tr class="memdesc:af2226fb14031e86b6e43864058a176b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Buffer with a capacity.  <br /></td></tr>
<tr class="separator:af2226fb14031e86b6e43864058a176b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccfcf4af060e2069d711f7933925fa8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a9ccfcf4af060e2069d711f7933925fa8">CCC_buffer_with_compound_literal</a>(count,  compound_literal_array...)&#160;&#160;&#160;    CCC_private_buffer_with_compound_literal(count, compound_literal_array)</td></tr>
<tr class="memdesc:a9ccfcf4af060e2069d711f7933925fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a contiguous Buffer of user a specified type of fixed capacity with no allocation permission or context.  <br /></td></tr>
<tr class="separator:a9ccfcf4af060e2069d711f7933925fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ecd88b73c7b78721aaee93c1983647"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a93ecd88b73c7b78721aaee93c1983647">CCC_buffer_with_context_compound_literal</a>(context,  count,  compound_literal_array...)</td></tr>
<tr class="memdesc:a93ecd88b73c7b78721aaee93c1983647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a contiguous Buffer of user a specified type of fixed capacity with no allocation permission.  <br /></td></tr>
<tr class="separator:a93ecd88b73c7b78721aaee93c1983647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f96119efe2724e34ee6e879e511154c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a7f96119efe2724e34ee6e879e511154c">CCC_buffer_reserve</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t to_add, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:a7f96119efe2724e34ee6e879e511154c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for at least to_add more elements.  <br /></td></tr>
<tr class="separator:a7f96119efe2724e34ee6e879e511154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfa78ee925af6a65460029469f2719c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#afcfa78ee925af6a65460029469f2719c">CCC_buffer_copy</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *destination, <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *source, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:afcfa78ee925af6a65460029469f2719c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the buffer from source to newly initialized destination.  <br /></td></tr>
<tr class="separator:afcfa78ee925af6a65460029469f2719c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Insert and Remove Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions assume contiguity of elements in the Buffer and increase or decrease size accordingly. </p>
</td></tr>
<tr class="memitem:a81346fc5d7ca38637c67bb0377188662"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a81346fc5d7ca38637c67bb0377188662">CCC_buffer_emplace_back</a>(buffer_pointer,  type_compound_literal...)&#160;&#160;&#160;    CCC_private_buffer_emplace_back(buffer_pointer, type_compound_literal)</td></tr>
<tr class="memdesc:a81346fc5d7ca38637c67bb0377188662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the user provided compound literal directly to back of buffer and increments the size to reflect the newly added element.  <br /></td></tr>
<tr class="separator:a81346fc5d7ca38637c67bb0377188662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e46fb13f61b8ac0af8e8bc0de2c2a3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a1e46fb13f61b8ac0af8e8bc0de2c2a3d">CCC_buffer_allocate</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t capacity, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:a1e46fb13f61b8ac0af8e8bc0de2c2a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates the Buffer to the specified size according to the user defined allocation function.  <br /></td></tr>
<tr class="separator:a1e46fb13f61b8ac0af8e8bc0de2c2a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ef9e09512c211c549b8eaea2fed360"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a81ef9e09512c211c549b8eaea2fed360">CCC_buffer_allocate_back</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer)</td></tr>
<tr class="memdesc:a81ef9e09512c211c549b8eaea2fed360"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a new slot from the Buffer at the end of the contiguous array. A slot is equivalent to one of the element type specified when the Buffer is initialized.  <br /></td></tr>
<tr class="separator:a81ef9e09512c211c549b8eaea2fed360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692fb97bb1a475d6377ec6abb635819a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a692fb97bb1a475d6377ec6abb635819a">CCC_buffer_push_back</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, void const *data)</td></tr>
<tr class="memdesc:a692fb97bb1a475d6377ec6abb635819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the newly pushed data into the last slot of the buffer according to size.  <br /></td></tr>
<tr class="separator:a692fb97bb1a475d6377ec6abb635819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab508c7c3f2d3c7d969335e786d51cc1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aab508c7c3f2d3c7d969335e786d51cc1">CCC_buffer_insert</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t index, void const *data)</td></tr>
<tr class="memdesc:aab508c7c3f2d3c7d969335e786d51cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert data at slot index according to size of the Buffer maintaining contiguous storage of elements between 0 and size.  <br /></td></tr>
<tr class="separator:aab508c7c3f2d3c7d969335e786d51cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1cc37e0625a8420ac15f4890e32233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a3d1cc37e0625a8420ac15f4890e32233">CCC_buffer_pop_back</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer)</td></tr>
<tr class="memdesc:a3d1cc37e0625a8420ac15f4890e32233"><td class="mdescLeft">&#160;</td><td class="mdescRight">pop the back element from the Buffer according to size.  <br /></td></tr>
<tr class="separator:a3d1cc37e0625a8420ac15f4890e32233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfffcabc032f3e0e4da9eec3c1ce2950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#acfffcabc032f3e0e4da9eec3c1ce2950">CCC_buffer_pop_back_n</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t count)</td></tr>
<tr class="memdesc:acfffcabc032f3e0e4da9eec3c1ce2950"><td class="mdescLeft">&#160;</td><td class="mdescRight">pop count elements from the back of the Buffer according to size.  <br /></td></tr>
<tr class="separator:acfffcabc032f3e0e4da9eec3c1ce2950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d52d463c92d12e8296dfe2272c7285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a54d52d463c92d12e8296dfe2272c7285">CCC_buffer_erase</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t index)</td></tr>
<tr class="memdesc:a54d52d463c92d12e8296dfe2272c7285"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase element at slot index according to size of the Buffer maintaining contiguous storage of elements between 0 and size.  <br /></td></tr>
<tr class="separator:a54d52d463c92d12e8296dfe2272c7285"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Slot Management Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions interact with slots in the Buffer directly and do not modify the size of the buffer. These are best used for custom container types operating at a higher level of abstraction. </p>
</td></tr>
<tr class="memitem:af4afef12114bc504cc8409097b8794f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af4afef12114bc504cc8409097b8794f8">CCC_buffer_as</a>(buffer_pointer,  type_name,  index)&#160;&#160;&#160;    ((type_name *)<a class="el" href="buffer_8h.html#a27d4f58159938cfb550a76f9e085c5ff">CCC_buffer_at</a>(buffer_pointer, index))</td></tr>
<tr class="memdesc:af4afef12114bc504cc8409097b8794f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access en element at the specified index as the stored type.  <br /></td></tr>
<tr class="separator:af4afef12114bc504cc8409097b8794f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13024839aeeb1d26157257dad973eba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa13024839aeeb1d26157257dad973eba">CCC_buffer_back_as</a>(buffer_pointer,  type_name)&#160;&#160;&#160;    ((type_name *)<a class="el" href="buffer_8h.html#aec6b1eaf6c932cd901fb145e867aa2f6">CCC_buffer_back</a>(buffer_pointer))</td></tr>
<tr class="memdesc:aa13024839aeeb1d26157257dad973eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the final element in the Buffer according the current size.  <br /></td></tr>
<tr class="separator:aa13024839aeeb1d26157257dad973eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a986ae56f2d1ac5114433cb2e95b8fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a4a986ae56f2d1ac5114433cb2e95b8fb">CCC_buffer_front_as</a>(buffer_pointer,  type_name)&#160;&#160;&#160;    ((type_name *)<a class="el" href="buffer_8h.html#a4c9f5187b290d944a14f3d3e922f166c">CCC_buffer_front</a>(buffer_pointer))</td></tr>
<tr class="memdesc:a4a986ae56f2d1ac5114433cb2e95b8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the first element in the Buffer at index 0.  <br /></td></tr>
<tr class="separator:a4a986ae56f2d1ac5114433cb2e95b8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f31fd0b26817aca58935d4361370e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ae2f31fd0b26817aca58935d4361370e8">CCC_buffer_emplace</a>(buffer_pointer,  index,  type_compound_literal...)&#160;&#160;&#160;    CCC_private_buffer_emplace(buffer_pointer, index, type_compound_literal)</td></tr>
<tr class="memdesc:ae2f31fd0b26817aca58935d4361370e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a user provided compound literal directly to a Buffer slot.  <br /></td></tr>
<tr class="separator:ae2f31fd0b26817aca58935d4361370e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d4f58159938cfb550a76f9e085c5ff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a27d4f58159938cfb550a76f9e085c5ff">CCC_buffer_at</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer, size_t index)</td></tr>
<tr class="memdesc:a27d4f58159938cfb550a76f9e085c5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the element at slot index in buf.  <br /></td></tr>
<tr class="separator:a27d4f58159938cfb550a76f9e085c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3974ff2704b82ff5c05f3f379ada7b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a3974ff2704b82ff5c05f3f379ada7b04">CCC_buffer_index</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer, void const *slot)</td></tr>
<tr class="memdesc:a3974ff2704b82ff5c05f3f379ada7b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of an element known to be in the buffer.  <br /></td></tr>
<tr class="separator:a3974ff2704b82ff5c05f3f379ada7b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6b1eaf6c932cd901fb145e867aa2f6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aec6b1eaf6c932cd901fb145e867aa2f6">CCC_buffer_back</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:aec6b1eaf6c932cd901fb145e867aa2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the final element in the Buffer according the current size.  <br /></td></tr>
<tr class="separator:aec6b1eaf6c932cd901fb145e867aa2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f5187b290d944a14f3d3e922f166c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a4c9f5187b290d944a14f3d3e922f166c">CCC_buffer_front</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:a4c9f5187b290d944a14f3d3e922f166c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the first element in the Buffer at index 0.  <br /></td></tr>
<tr class="separator:a4c9f5187b290d944a14f3d3e922f166c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78297e7bdc97e441d81ab682ec4e3560"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a78297e7bdc97e441d81ab682ec4e3560">CCC_buffer_move</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t destination, size_t source)</td></tr>
<tr class="memdesc:a78297e7bdc97e441d81ab682ec4e3560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move data at index source to destination according to capacity.  <br /></td></tr>
<tr class="separator:a78297e7bdc97e441d81ab682ec4e3560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd334de1ebe17f2e329d501bd59ec99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#abfd334de1ebe17f2e329d501bd59ec99">CCC_buffer_write</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t index, void const *data)</td></tr>
<tr class="memdesc:abfd334de1ebe17f2e329d501bd59ec99"><td class="mdescLeft">&#160;</td><td class="mdescRight">write data to Buffer at slot at index index according to capacity.  <br /></td></tr>
<tr class="separator:abfd334de1ebe17f2e329d501bd59ec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e624d6ffa19538935cbd17838b659b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af8e624d6ffa19538935cbd17838b659b">CCC_buffer_swap</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, void *temp, size_t index, size_t swap_index)</td></tr>
<tr class="memdesc:af8e624d6ffa19538935cbd17838b659b"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap elements at index and swap_index according to capacity of the bufer.  <br /></td></tr>
<tr class="separator:af8e624d6ffa19538935cbd17838b659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Types available in the container interface. </p>
</td></tr>
<tr class="memitem:af21c5e9b99c8ee4bb14f827f07b8a5af"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af21c5e9b99c8ee4bb14f827f07b8a5af">CCC_Buffer</a></td></tr>
<tr class="memdesc:af21c5e9b99c8ee4bb14f827f07b8a5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contiguous block of storage for elements of the same type.  <br /></td></tr>
<tr class="separator:af21c5e9b99c8ee4bb14f827f07b8a5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iteration Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following functions implement iterators over the buffer. </p>
</td></tr>
<tr class="memitem:ac29adf3440473ce2fbca058046a4038f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ac29adf3440473ce2fbca058046a4038f">CCC_buffer_begin</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:ac29adf3440473ce2fbca058046a4038f"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the base address of the Buffer in preparation for iteration.  <br /></td></tr>
<tr class="separator:ac29adf3440473ce2fbca058046a4038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78622f361e1e2a534bd6b954542cb5c1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a78622f361e1e2a534bd6b954542cb5c1">CCC_buffer_next</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer, void const *iterator)</td></tr>
<tr class="memdesc:a78622f361e1e2a534bd6b954542cb5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">advance the iterator to the next slot in the Buffer according to size.  <br /></td></tr>
<tr class="separator:a78622f361e1e2a534bd6b954542cb5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa156248e8c2feeec55da449e2b253836"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa156248e8c2feeec55da449e2b253836">CCC_buffer_end</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:aa156248e8c2feeec55da449e2b253836"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the end position of the Buffer according to size.  <br /></td></tr>
<tr class="separator:aa156248e8c2feeec55da449e2b253836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1abf17270ac322387227c6ca17c1d29"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ae1abf17270ac322387227c6ca17c1d29">CCC_buffer_capacity_end</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:ae1abf17270ac322387227c6ca17c1d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the end position of the Buffer according to capacity.  <br /></td></tr>
<tr class="separator:ae1abf17270ac322387227c6ca17c1d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d29d714feeec257bae6e418257b721b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a2d29d714feeec257bae6e418257b721b">CCC_buffer_reverse_begin</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:a2d29d714feeec257bae6e418257b721b"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the address of the last element in the Buffer in preparation for iteration according to size.  <br /></td></tr>
<tr class="separator:a2d29d714feeec257bae6e418257b721b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18fd0d8667ceb04699326ad376070fb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ab18fd0d8667ceb04699326ad376070fb">CCC_buffer_reverse_next</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer, void const *iterator)</td></tr>
<tr class="memdesc:ab18fd0d8667ceb04699326ad376070fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">advance the iterator to the next slot in the Buffer according to size and in reverse order.  <br /></td></tr>
<tr class="separator:ab18fd0d8667ceb04699326ad376070fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c0f886968ea798e393dfca19b44207"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af0c0f886968ea798e393dfca19b44207">CCC_buffer_reverse_end</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:af0c0f886968ea798e393dfca19b44207"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the reverse_end position of the buffer.  <br /></td></tr>
<tr class="separator:af0c0f886968ea798e393dfca19b44207"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions help manage or obtain state of the buffer. </p>
</td></tr>
<tr class="memitem:af5a69c3f3a8d8b48b03e57e2e35a1201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af5a69c3f3a8d8b48b03e57e2e35a1201">CCC_buffer_size_plus</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t count)</td></tr>
<tr class="memdesc:af5a69c3f3a8d8b48b03e57e2e35a1201"><td class="mdescLeft">&#160;</td><td class="mdescRight">add count to the size of the buffer.  <br /></td></tr>
<tr class="separator:af5a69c3f3a8d8b48b03e57e2e35a1201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6badf4f26a8c92175ed2fc4aea6fb9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ad6badf4f26a8c92175ed2fc4aea6fb9d">CCC_buffer_size_minus</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t count)</td></tr>
<tr class="memdesc:ad6badf4f26a8c92175ed2fc4aea6fb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract count from the size of the buffer.  <br /></td></tr>
<tr class="separator:ad6badf4f26a8c92175ed2fc4aea6fb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af864cb915c6a104d9a32b755ebaef56a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af864cb915c6a104d9a32b755ebaef56a">CCC_buffer_size_set</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, size_t count)</td></tr>
<tr class="memdesc:af864cb915c6a104d9a32b755ebaef56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Buffer size to n.  <br /></td></tr>
<tr class="separator:af864cb915c6a104d9a32b755ebaef56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1ef17e8011b57f1bd54cdf9911f3a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8b1ef17e8011b57f1bd54cdf9911f3a7">CCC_buffer_count</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:a8b1ef17e8011b57f1bd54cdf9911f3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the count of Buffer active slots.  <br /></td></tr>
<tr class="separator:a8b1ef17e8011b57f1bd54cdf9911f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2e525a7c101a550d664f095d9d4940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a6b2e525a7c101a550d664f095d9d4940">CCC_buffer_capacity</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:a6b2e525a7c101a550d664f095d9d4940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current capacity of total possible slots.  <br /></td></tr>
<tr class="separator:a6b2e525a7c101a550d664f095d9d4940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41c9e287da0c2cbcbe11222aa3f151e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ab41c9e287da0c2cbcbe11222aa3f151e">CCC_buffer_sizeof_type</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:ab41c9e287da0c2cbcbe11222aa3f151e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the type being stored contiguously in the buffer.  <br /></td></tr>
<tr class="separator:ab41c9e287da0c2cbcbe11222aa3f151e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1508cf027ec63833d14f1e4e01aa225f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a1508cf027ec63833d14f1e4e01aa225f">CCC_buffer_count_bytes</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:a1508cf027ec63833d14f1e4e01aa225f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bytes in the Buffer given the current count of active elements.  <br /></td></tr>
<tr class="separator:a1508cf027ec63833d14f1e4e01aa225f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649c96aab7afd1cca21078c56e41257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ac649c96aab7afd1cca21078c56e41257">CCC_buffer_capacity_bytes</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:ac649c96aab7afd1cca21078c56e41257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bytes in the Buffer given the current capacity elements.  <br /></td></tr>
<tr class="separator:ac649c96aab7afd1cca21078c56e41257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b1c67ea1a8bf3f711be12516fa008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a749b1c67ea1a8bf3f711be12516fa008">CCC_buffer_is_empty</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:a749b1c67ea1a8bf3f711be12516fa008"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the size of the Buffer is 0.  <br /></td></tr>
<tr class="separator:a749b1c67ea1a8bf3f711be12516fa008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdfb7c3d5fe253f5f55b662be3c03f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#adbdfb7c3d5fe253f5f55b662be3c03f4">CCC_buffer_is_full</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *buffer)</td></tr>
<tr class="memdesc:adbdfb7c3d5fe253f5f55b662be3c03f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the size of the Buffer equals capacity.  <br /></td></tr>
<tr class="separator:adbdfb7c3d5fe253f5f55b662be3c03f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Free the elements of the container and the underlying buffer. </p>
</td></tr>
<tr class="memitem:aa35951063c3bbf2883db36be8b6ca744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa35951063c3bbf2883db36be8b6ca744">CCC_buffer_clear_and_free_reserve</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:aa35951063c3bbf2883db36be8b6ca744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the buffer and frees the underlying Buffer that was previously dynamically reserved with the reserve function.  <br /></td></tr>
<tr class="separator:aa35951063c3bbf2883db36be8b6ca744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce332bdd62ac1ad8627c69b8e861275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a2ce332bdd62ac1ad8627c69b8e861275">CCC_buffer_clear_and_free</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy)</td></tr>
<tr class="memdesc:a2ce332bdd62ac1ad8627c69b8e861275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size of buffer to 0 and call destroy on each element if needed. Free the underlying Buffer setting the capacity to 0. O(1) if no destructor is provided, else O(N).  <br /></td></tr>
<tr class="separator:a2ce332bdd62ac1ad8627c69b8e861275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e65e04cebec9b2b5baa96ad76858e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a86e65e04cebec9b2b5baa96ad76858e9">CCC_buffer_clear</a> (<a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *buffer, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy)</td></tr>
<tr class="memdesc:a86e65e04cebec9b2b5baa96ad76858e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size of buffer to 0 and call destroy on each element if needed. O(1) if no destroy is provided, else O(N).  <br /></td></tr>
<tr class="separator:a86e65e04cebec9b2b5baa96ad76858e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af4afef12114bc504cc8409097b8794f8" name="af4afef12114bc504cc8409097b8794f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4afef12114bc504cc8409097b8794f8">&#9670;&#160;</a></span>CCC_buffer_as</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_as</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ((type_name *)<a class="el" href="buffer_8h.html#a27d4f58159938cfb550a76f9e085c5ff">CCC_buffer_at</a>(buffer_pointer, index))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access en element at the specified index as the stored type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_pointer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the stored type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index within capacity range of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element in the slot at position index or NULL if index is out of capacity range.</dd></dl>
<p>Note that as long as the index is valid within the capacity of the Buffer a valid pointer is returned, which may result in a slot of old or uninitialized data. It is up to the user to ensure the index provided is within the current size of the buffer. </p>

</div>
</div>
<a id="aa13024839aeeb1d26157257dad973eba" name="aa13024839aeeb1d26157257dad973eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13024839aeeb1d26157257dad973eba">&#9670;&#160;</a></span>CCC_buffer_back_as</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_back_as</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ((type_name *)<a class="el" href="buffer_8h.html#aec6b1eaf6c932cd901fb145e867aa2f6">CCC_buffer_back</a>(buffer_pointer))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the final element in the Buffer according the current size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_pointer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the stored type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer the final element in the Buffer according to the current size or NULL if the Buffer does not exist or is empty. </dd></dl>

</div>
</div>
<a id="ae2f31fd0b26817aca58935d4361370e8" name="ae2f31fd0b26817aca58935d4361370e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f31fd0b26817aca58935d4361370e8">&#9670;&#160;</a></span>CCC_buffer_emplace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_emplace</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_buffer_emplace(buffer_pointer, index, type_compound_literal)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a user provided compound literal directly to a Buffer slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_pointer</td><td>a pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the desired index at which to insert an element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the direct compound literal as provided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inserted element or NULL if insertion failed. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The index provided is only checked to be within capacity bounds so it is the user's responsibility to ensure the index is within the contiguous range of [0, size). This insert method does not increment the size of the buffer.</dd></dl>
<p>Any function calls that set fields of the compound literal will not be evaluated if the provided index is out of range of the Buffer capacity. </p>

</div>
</div>
<a id="a81346fc5d7ca38637c67bb0377188662" name="a81346fc5d7ca38637c67bb0377188662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81346fc5d7ca38637c67bb0377188662">&#9670;&#160;</a></span>CCC_buffer_emplace_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_emplace_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_buffer_emplace_back(buffer_pointer, type_compound_literal)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes the user provided compound literal directly to back of buffer and increments the size to reflect the newly added element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_pointer</td><td>a pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the direct compound literal as provided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inserted element or NULL if insertion failed.</dd></dl>
<p>Any function calls that set fields of the compound literal will not be evaluated if the Buffer fails to allocate a slot at the back of the buffer. This may occur if resizing fails or is prohibited. </p>

</div>
</div>
<a id="adfb78598277e9204689fda554bc892fa" name="adfb78598277e9204689fda554bc892fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb78598277e9204689fda554bc892fa">&#9670;&#160;</a></span>CCC_buffer_from</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_from</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal_array...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_buffer_from(allocate, context_data, optional_capacity,         \</div>
<div class="line">                            compound_literal_array)</div>
</div><!-- fragment -->
<p>Initialize a Buffer from a compound literal array initializer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>CCC_Allocator or NULL if no allocation is permitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>any context data needed for managing Buffer memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_capacity</td><td>optionally specify the capacity of the Buffer if different from the size of the compound literal array initializer. If the capacity is greater than the size of the compound literal array initializer, it is respected and the capacity is reserved. If the capacity is less than the size of the compound array initializer, the compound literal array initializer size is set as the capacity. Therefore, 0 is valid if one is not concerned with the underlying reservation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal_array</td><td>the initializer of the type stored in buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized buffer. Directly assign to Buffer on the right hand side of the equality operator (e.g. <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> b = <a class="el" href="buffer_8h.html#adfb78598277e9204689fda554bc892fa" title="Initialize a Buffer from a compound literal array initializer.">CCC_buffer_from(...)</a>;).</dd></dl>
<p>Initialize a dynamic Buffer with a compound literal array.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Buffer b = buffer_from(std_allocate, NULL, 0,</div>
<div class="line">        (<span class="keywordtype">int</span>[]){ 0, 1, 2, 3 }</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Initialize a dynamic Buffer with a compound literal array with capacity.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Buffer b = buffer_from(std_allocate, NULL, 4096,</div>
<div class="line">        (<span class="keywordtype">int</span>[]){ 0, 1, 2, 3 }</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Only dynamic buffers may be initialized this way. For static or stack based initialization of fixed buffers with contents known at compile time, see the <a class="el" href="buffer_8h.html#ac3e1da3a4a6c2e2f47da32769cf6bd74" title="Initialize a contiguous Buffer of user a specified type, allocation policy, capacity,...">CCC_buffer_initialize()</a> macro. </p>

</div>
</div>
<a id="a4a986ae56f2d1ac5114433cb2e95b8fb" name="a4a986ae56f2d1ac5114433cb2e95b8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a986ae56f2d1ac5114433cb2e95b8fb">&#9670;&#160;</a></span>CCC_buffer_front_as</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_front_as</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ((type_name *)<a class="el" href="buffer_8h.html#a4c9f5187b290d944a14f3d3e922f166c">CCC_buffer_front</a>(buffer_pointer))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the first element in the Buffer at index 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_pointer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the stored type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the front element or NULL if the Buffer does not exist or is empty. </dd></dl>

</div>
</div>
<a id="ac3e1da3a4a6c2e2f47da32769cf6bd74" name="ac3e1da3a4a6c2e2f47da32769cf6bd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e1da3a4a6c2e2f47da32769cf6bd74">&#9670;&#160;</a></span>CCC_buffer_initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_initialize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_count...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_buffer_initialize(data_pointer, type_name, allocate,           \</div>
<div class="line">                                  context_data, capacity, optional_count)</div>
</div><!-- fragment -->
<p>Initialize a contiguous Buffer of user a specified type, allocation policy, capacity, and optional starting size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_pointer</td><td>the pointer to existing memory or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the user type in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>CCC_Allocator or NULL if no allocation is permitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>any context data needed for managing Buffer memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the capacity of memory at data_pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_count</td><td>optional starting size of the Buffer &lt;= capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized buffer. Directly assign to Buffer on the right hand side of the equality operator (e.g. <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> b = <a class="el" href="buffer_8h.html#ac3e1da3a4a6c2e2f47da32769cf6bd74" title="Initialize a contiguous Buffer of user a specified type, allocation policy, capacity,...">CCC_buffer_initialize(...)</a>;).</dd></dl>
<p>Initialization of a Buffer can occur at compile time or run time depending on the arguments. The memory pointer should be of the same type one intends to store in the buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Buffer stack = buffer_initialize(&amp;(<span class="keyword">static</span> <span class="keywordtype">int</span>[4096]){}, int, NULL, NULL,</div>
<div class="line">4096);</div>
</div><!-- fragment --><p>Initialize a fixed Buffer with some elements occupied.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Buffer stack</div>
<div class="line">    = buffer_initialize(&amp;(<span class="keyword">static</span> <span class="keywordtype">int</span>[4096]){0, 1, 2, 3}, int, NULL, NULL, 4096,</div>
<div class="line">4);</div>
</div><!-- fragment --><p>This initializer determines memory control for the lifetime of the buffer. If the Buffer points to memory of a predetermined and fixed capacity do not provide an allocation function. If a dynamic Buffer is preferred, provide the allocation function as defined by the signature in <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a>. If resizing is desired on memory that has already been allocated, ensure allocation has occurred with the provided allocation function. </p>

</div>
</div>
<a id="af2226fb14031e86b6e43864058a176b1" name="af2226fb14031e86b6e43864058a176b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2226fb14031e86b6e43864058a176b1">&#9670;&#160;</a></span>CCC_buffer_with_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_with_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_buffer_with_capacity(type_name, allocate, context_data,        \</div>
<div class="line">                                     capacity)</div>
</div><!-- fragment -->
<p>Initialize a Buffer with a capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>any user or language standard type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>CCC_Allocator or NULL if no allocation is permitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>any context data needed for managing Buffer memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the capacity of the Buffer to reserve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized buffer. Directly assign to Buffer on the right hand side of the equality operator (e.g. <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> b = <a class="el" href="buffer_8h.html#af2226fb14031e86b6e43864058a176b1" title="Initialize a Buffer with a capacity.">CCC_buffer_with_capacity(...)</a>;).</dd></dl>
<p>Initialize a dynamic buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Buffer b = buffer_from(std_allocate, NULL, 4096);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Only dynamic buffers may be initialized this way. For static or stack based initialization of fixed buffers with contents known at compile time, see the <a class="el" href="buffer_8h.html#ac3e1da3a4a6c2e2f47da32769cf6bd74" title="Initialize a contiguous Buffer of user a specified type, allocation policy, capacity,...">CCC_buffer_initialize()</a> macro. </p>

</div>
</div>
<a id="a9ccfcf4af060e2069d711f7933925fa8" name="a9ccfcf4af060e2069d711f7933925fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccfcf4af060e2069d711f7933925fa8">&#9670;&#160;</a></span>CCC_buffer_with_compound_literal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_with_compound_literal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal_array...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_buffer_with_compound_literal(count, compound_literal_array)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a contiguous Buffer of user a specified type of fixed capacity with no allocation permission or context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>starting count of the Buffer &lt;= capacity of input literal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal_array</td><td>the compound literal array of types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized buffer. Directly assign to Buffer on the right hand side of the equality operator (e.g. <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> b = <a class="el" href="buffer_8h.html#a9ccfcf4af060e2069d711f7933925fa8" title="Initialize a contiguous Buffer of user a specified type of fixed capacity with no allocation permissi...">CCC_buffer_with_compound_literal(...)</a>;).</dd></dl>
<p>Initialization of a Buffer can occur at compile time or run time but always lacks any allocation permissions. The memory pointer should be of the same type one intends to store in the buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Buffer stack = buffer_with_compound_literal(0, (<span class="keyword">static</span> <span class="keywordtype">int</span>[4096]){});</div>
</div><!-- fragment --><p>Compile time creation of fixed capacity buffers can be a helpful use case when wrapping static or stack based arrays. </p>

</div>
</div>
<a id="a93ecd88b73c7b78721aaee93c1983647" name="a93ecd88b73c7b78721aaee93c1983647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ecd88b73c7b78721aaee93c1983647">&#9670;&#160;</a></span>CCC_buffer_with_context_compound_literal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_buffer_with_context_compound_literal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal_array...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_buffer_with_context_compound_literal(context, count,           \</div>
<div class="line">                                                     compound_literal_array)</div>
</div><!-- fragment -->
<p>Initialize a contiguous Buffer of user a specified type of fixed capacity with no allocation permission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>a pointer to any context needed for each element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>starting count of the Buffer &lt;= capacity of input literal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal_array</td><td>the compound literal array of types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized buffer. Directly assign to Buffer on the right hand side of the equality operator (e.g. <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> b = <a class="el" href="buffer_8h.html#a93ecd88b73c7b78721aaee93c1983647" title="Initialize a contiguous Buffer of user a specified type of fixed capacity with no allocation permissi...">CCC_buffer_with_context_compound_literal(...)</a>;).</dd></dl>
<p>Initialization of a Buffer can occur at compile time or run time but always lacks any allocation permissions. The memory pointer should be of the same type one intends to store in the buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Buffer stack = buffer_with_context_compound_literal(</div>
<div class="line">    &amp;module_context,</div>
<div class="line">    0,</div>
<div class="line">    (<span class="keyword">static</span> <span class="keywordtype">int</span>[5]){0, 1, 2, 3, 4}</div>
<div class="line">);</div>
</div><!-- fragment --><p>Compile time creation of fixed capacity buffers can be a helpful use case when wrapping static or stack based arrays. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af21c5e9b99c8ee4bb14f827f07b8a5af" name="af21c5e9b99c8ee4bb14f827f07b8a5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21c5e9b99c8ee4bb14f827f07b8a5af">&#9670;&#160;</a></span>CCC_Buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> <a class="el" href="structCCC__Buffer.html">CCC_Buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A contiguous block of storage for elements of the same type. </p>
<dl class="section warning"><dt>Warning</dt><dd>it is undefined behavior to use an uninitialized buffer.</dd></dl>
<p>A Buffer may be initialized on the stack, heap, or data segment at compile time or runtime. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1e46fb13f61b8ac0af8e8bc0de2c2a3d" name="a1e46fb13f61b8ac0af8e8bc0de2c2a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e46fb13f61b8ac0af8e8bc0de2c2a3d">&#9670;&#160;</a></span>CCC_buffer_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates the Buffer to the specified size according to the user defined allocation function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the newly desired capacity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function defined by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of reallocation.</dd></dl>
<p>This function takes the allocation function as an argument in case no allocation function has been provided upon initialization and the user is managing allocations and resizing directly. If an allocation function has been provided than the use of this function should be rare as the buffer will reallocate more memory when necessary. </p>

</div>
</div>
<a id="a81ef9e09512c211c549b8eaea2fed360" name="a81ef9e09512c211c549b8eaea2fed360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ef9e09512c211c549b8eaea2fed360">&#9670;&#160;</a></span>CCC_buffer_allocate_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_allocate_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a new slot from the Buffer at the end of the contiguous array. A slot is equivalent to one of the element type specified when the Buffer is initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory or NULL if no Buffer is provided or the Buffer is unable to allocate more memory. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container.</dd></dl>
<p>A Buffer can be used as the backing for more complex data structures. Requesting new space from a Buffer as an allocator can be helpful for these higher level organizations. </p>

</div>
</div>
<a id="a27d4f58159938cfb550a76f9e085c5ff" name="a27d4f58159938cfb550a76f9e085c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d4f58159938cfb550a76f9e085c5ff">&#9670;&#160;</a></span>CCC_buffer_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the element at slot index in buf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index within capacity range of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element in the slot at position index or NULL if index is out of capacity range.</dd></dl>
<p>Note that as long as the index is valid within the capacity of the Buffer a valid pointer is returned, which may result in a slot of old or uninitialized data. It is up to the user to ensure the index provided is within the current size of the buffer. </p>

</div>
</div>
<a id="aec6b1eaf6c932cd901fb145e867aa2f6" name="aec6b1eaf6c932cd901fb145e867aa2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6b1eaf6c932cd901fb145e867aa2f6">&#9670;&#160;</a></span>CCC_buffer_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the final element in the Buffer according the current size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer the final element in the Buffer according to the current size or NULL if the Buffer does not exist or is empty. </dd></dl>

</div>
</div>
<a id="ac29adf3440473ce2fbca058046a4038f" name="ac29adf3440473ce2fbca058046a4038f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29adf3440473ce2fbca058046a4038f">&#9670;&#160;</a></span>CCC_buffer_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the base address of the Buffer in preparation for iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base address of the buffer. This will be equivalent to the buffer end iterator if the Buffer size is 0. NULL is returned if a NULL argument is provided or the Buffer has not yet been allocated. </dd></dl>

</div>
</div>
<a id="a6b2e525a7c101a550d664f095d9d4940" name="a6b2e525a7c101a550d664f095d9d4940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2e525a7c101a550d664f095d9d4940">&#9670;&#160;</a></span>CCC_buffer_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_buffer_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current capacity of total possible slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of elements the can be stored in the buffer. This value remains the same until a resize occurs. An argument error is set if buffer is NULL. </dd></dl>

</div>
</div>
<a id="ac649c96aab7afd1cca21078c56e41257" name="ac649c96aab7afd1cca21078c56e41257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac649c96aab7afd1cca21078c56e41257">&#9670;&#160;</a></span>CCC_buffer_capacity_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_buffer_capacity_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bytes in the Buffer given the current capacity elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes occupied by the current capacity elements.</dd></dl>
<p>For total possible bytes that can be stored in the Buffer given the current element count see CCC_buffer_count_bytes. </p>

</div>
</div>
<a id="ae1abf17270ac322387227c6ca17c1d29" name="ae1abf17270ac322387227c6ca17c1d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1abf17270ac322387227c6ca17c1d29">&#9670;&#160;</a></span>CCC_buffer_capacity_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_capacity_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the end position of the Buffer according to capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the position one past capacity. It is undefined to access this position for any reason. NULL is returned if NULL is provided or Buffer has not yet been allocated.</dd></dl>
<p>Note that end is determined by the capcity of the Buffer and will not change until a resize has occured, if permitted. </p>

</div>
</div>
<a id="a86e65e04cebec9b2b5baa96ad76858e9" name="a86e65e04cebec9b2b5baa96ad76858e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e65e04cebec9b2b5baa96ad76858e9">&#9670;&#160;</a></span>CCC_buffer_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size of buffer to 0 and call destroy on each element if needed. O(1) if no destroy is provided, else O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to the buf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destroy if needed or NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if destroy is non-NULL it will be called on each element in the buf. However, the underlying Buffer for the buffer is not freed. If the destructor is NULL, setting the size to 0 is O(1). Elements are assumed to be contiguous from the 0th index to index at size - 1. </p>

</div>
</div>
<a id="a2ce332bdd62ac1ad8627c69b8e861275" name="a2ce332bdd62ac1ad8627c69b8e861275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce332bdd62ac1ad8627c69b8e861275">&#9670;&#160;</a></span>CCC_buffer_clear_and_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_clear_and_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size of buffer to 0 and call destroy on each element if needed. Free the underlying Buffer setting the capacity to 0. O(1) if no destructor is provided, else O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to the buf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destroy if needed or NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if destroy is non-NULL it will be called on each element in the buf. After all elements are processed the Buffer is freed and capacity is 0. If destroy is NULL the Buffer is freed directly and capacity is 0. Elements are assumed to be contiguous from the 0th index to index at size - 1. </p>

</div>
</div>
<a id="aa35951063c3bbf2883db36be8b6ca744" name="aa35951063c3bbf2883db36be8b6ca744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35951063c3bbf2883db36be8b6ca744">&#9670;&#160;</a></span>CCC_buffer_clear_and_free_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_clear_and_free_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the buffer and frees the underlying Buffer that was previously dynamically reserved with the reserve function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the Buffer to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destroy for each element. NULL can be passed if no maintenance is required on the elements in the buffer before their slots are dropped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function to provide to a dynamically reserved buf. Any context data provided upon initialization will be passed to the allocation function when called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of free operation. OK if success, or an error status to indicate the error. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is an error to call this function on a buffer that was not reserved with the provided CCC_Allocator. The buffer must have existing memory to free.</dd></dl>
<p>This function covers the edge case of reserving a dynamic capacity for a buf at runtime but denying the buffer allocation permission to resize. This can help prevent a buffer from growing untree. The user in this case knows the buffer does not have allocation permission and therefore no further memory will be dedicated to the buf.</p>
<p>However, to free the buffer in such a case this function must be used because the buf has no ability to free itself. Just as the allocation function is required to reserve memory so to is it required to free memory.</p>
<p>This function will work normally if called on a buffer with allocation permission however the normal CCC_buffer_clear_and_free is sufficient for that use case. Elements are assumed to be contiguous from the 0th index to index at size - 1. </p>

</div>
</div>
<a id="afcfa78ee925af6a65460029469f2719c" name="afcfa78ee925af6a65460029469f2719c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfa78ee925af6a65460029469f2719c">&#9670;&#160;</a></span>CCC_buffer_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the buffer from source to newly initialized destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>the destination that will copy the source buf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the source of the buf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function in case resizing of destination is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the copy operation. If the destination capacity is less than the source capacity and no allocation function is provided an input error is returned. If resizing is required and resizing of destination fails a memory error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>destination must have capacity greater than or equal to source. If destination capacity is less than source, an allocation function must be provided with the allocate argument.</dd></dl>
<p>Note that there are two ways to copy data from source to destination: provide sufficient memory and pass NULL as allocate, or allow the copy function to take care of allocation for the copy.</p>
<p>Manual memory management with no allocation function provided.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line">Buffer source = buffer_initialize((<span class="keywordtype">int</span>[10]){}, int, NULL, NULL, 10);</div>
<div class="line"><span class="keywordtype">int</span> *new_data = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * buffer_capacity(&amp;source).count);</div>
<div class="line">Buffer destination</div>
<div class="line">    = buffer_initialize(new_data, <span class="keywordtype">int</span>, NULL, NULL,</div>
<div class="line">buffer_capacity(&amp;source).count); <a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = buffer_copy(&amp;destination,</div>
<div class="line">&amp;source, NULL);</div>
<div class="ttc" id="atypes_8h_html_aa1ded61d294b114942f11e711b331dcf"><div class="ttname"><a href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a></div><div class="ttdeci">CCC_Result</div><div class="ttdoc">A result of actions on containers.</div><div class="ttdef"><b>Definition:</b> types.h:148</div></div>
</div><!-- fragment --><p>The above requires destination capacity be greater than or equal to source capacity. Here is memory management handed over to the copy function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line">Buffer source = buffer_initialize(NULL, <span class="keywordtype">int</span>, std_allocate, NULL, 0);</div>
<div class="line">(void)CCC_buffer_push_back_range(&amp;source, 5, (<span class="keywordtype">int</span>[5]){0,1,2,3,4});</div>
<div class="line">Buffer destination = buffer_initialize(NULL, <span class="keywordtype">int</span>, std_allocate, NULL, 0);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = buffer_copy(&amp;destination, &amp;source, std_allocate);</div>
</div><!-- fragment --><p>The above allows destination to have a capacity less than that of the source as long as copy has been provided an allocation function to resize destination. Note that this would still work if copying to a destination that the user wants as a fixed size buffer (ring buffer).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
<div class="line">Buffer source = buffer_initialize(NULL, <span class="keywordtype">int</span>, std_allocate, NULL, 0);</div>
<div class="line">(void)CCC_buffer_push_back_range(&amp;source, 5, (<span class="keywordtype">int</span>[5]){0,1,2,3,4});</div>
<div class="line">Buffer destination = buffer_initialize(NULL, <span class="keywordtype">int</span>, NULL, NULL, 0);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = buffer_copy(&amp;destination, &amp;source, std_allocate);</div>
</div><!-- fragment --><p>Because an allocation function is provided, the destination is resized once for the copy and retains its fixed size after the copy is complete. This would require the user to manually free the underlying Buffer at destination eventually if this method is used. Usually it is better to allocate the memory explicitly before the copy if copying between ring buffers.</p>
<p>These options allow users to stay consistent across containers with their memory management strategies. </p>

</div>
</div>
<a id="a8b1ef17e8011b57f1bd54cdf9911f3a7" name="a8b1ef17e8011b57f1bd54cdf9911f3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1ef17e8011b57f1bd54cdf9911f3a7">&#9670;&#160;</a></span>CCC_buffer_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_buffer_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the count of Buffer active slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quantity of elements stored in the buffer. An argument error is set if buffer is NULL.</dd></dl>
<p>Note that size must be less than or equal to capacity. </p>

</div>
</div>
<a id="a1508cf027ec63833d14f1e4e01aa225f" name="a1508cf027ec63833d14f1e4e01aa225f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1508cf027ec63833d14f1e4e01aa225f">&#9670;&#160;</a></span>CCC_buffer_count_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_buffer_count_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bytes in the Buffer given the current count of active elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes occupied by the current count of elements.</dd></dl>
<p>For total possible bytes that can be stored in the Buffer see CCC_buffer_capacity_bytes. </p>

</div>
</div>
<a id="aa156248e8c2feeec55da449e2b253836" name="aa156248e8c2feeec55da449e2b253836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa156248e8c2feeec55da449e2b253836">&#9670;&#160;</a></span>CCC_buffer_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the end position of the Buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the end position. It is undefined to access this position for any reason. NULL is returned if NULL is provided or Buffer has not yet been allocated.</dd></dl>
<p>Note that end is determined by the size of the Buffer dynamically. </p>

</div>
</div>
<a id="a54d52d463c92d12e8296dfe2272c7285" name="a54d52d463c92d12e8296dfe2272c7285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d52d463c92d12e8296dfe2272c7285">&#9670;&#160;</a></span>CCC_buffer_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase element at slot index according to size of the Buffer maintaining contiguous storage of elements between 0 and size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result, CCC_RESULT_OK if the input is valid. If no Buffer exists or i is out of range of size then an input error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container.</dd></dl>
<p>Note that this function assumes elements must be maintained contiguously according to size meaning a bulk copy of elements sliding down to fill the space left by index will occur. </p>

</div>
</div>
<a id="a4c9f5187b290d944a14f3d3e922f166c" name="a4c9f5187b290d944a14f3d3e922f166c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9f5187b290d944a14f3d3e922f166c">&#9670;&#160;</a></span>CCC_buffer_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the first element in the Buffer at index 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the front element or NULL if the Buffer does not exist or is empty. </dd></dl>

</div>
</div>
<a id="a3974ff2704b82ff5c05f3f379ada7b04" name="a3974ff2704b82ff5c05f3f379ada7b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3974ff2704b82ff5c05f3f379ada7b04">&#9670;&#160;</a></span>CCC_buffer_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_buffer_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the index of an element known to be in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>the pointer to the element stored in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index if the slot provided is within the capacity range of the buffer, otherwise an argument error is set. </dd></dl>

</div>
</div>
<a id="aab508c7c3f2d3c7d969335e786d51cc1" name="aab508c7c3f2d3c7d969335e786d51cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab508c7c3f2d3c7d969335e786d51cc1">&#9670;&#160;</a></span>CCC_buffer_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert data at slot index according to size of the Buffer maintaining contiguous storage of elements between 0 and size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index at which to insert data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data copied into the Buffer at index index of the same size as elements stored in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the inserted element or NULL if bad input is provided, the Buffer is full and no resizing is allowed, or resizing fails when resizing is allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container.</dd></dl>
<p>Note that this function assumes elements must be maintained contiguously according to size of the Buffer meaning a bulk move of elements sliding down to accommodate index will occur. </p>

</div>
</div>
<a id="a749b1c67ea1a8bf3f711be12516fa008" name="a749b1c67ea1a8bf3f711be12516fa008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749b1c67ea1a8bf3f711be12516fa008">&#9670;&#160;</a></span>CCC_buffer_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_buffer_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if the size of the Buffer is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size is 0 false if not. Error if buffer is NULL. </dd></dl>

</div>
</div>
<a id="adbdfb7c3d5fe253f5f55b662be3c03f4" name="adbdfb7c3d5fe253f5f55b662be3c03f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdfb7c3d5fe253f5f55b662be3c03f4">&#9670;&#160;</a></span>CCC_buffer_is_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_buffer_is_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if the size of the Buffer equals capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size equals the capacity. Error if buffer is NULL. </dd></dl>

</div>
</div>
<a id="a78297e7bdc97e441d81ab682ec4e3560" name="a78297e7bdc97e441d81ab682ec4e3560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78297e7bdc97e441d81ab682ec4e3560">&#9670;&#160;</a></span>CCC_buffer_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move data at index source to destination according to capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>the index of destination within bounds of capacity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the index of source within bounds of capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the slot at destination or NULL if bad input is provided. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function does NOT modify the size of the container.</dd></dl>
<p>Note that destination and source are only required to be valid within bounds of capacity of the buffer. It is up to the user to ensure destination and source are within the size bounds of the buffer, if required. </p>

</div>
</div>
<a id="a78622f361e1e2a534bd6b954542cb5c1" name="a78622f361e1e2a534bd6b954542cb5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78622f361e1e2a534bd6b954542cb5c1">&#9670;&#160;</a></span>CCC_buffer_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>advance the iterator to the next slot in the Buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>the pointer to the current slot of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next iterator position according to size. </dd></dl>

</div>
</div>
<a id="a3d1cc37e0625a8420ac15f4890e32233" name="a3d1cc37e0625a8420ac15f4890e32233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1cc37e0625a8420ac15f4890e32233">&#9670;&#160;</a></span>CCC_buffer_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pop the back element from the Buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the attempted pop. CCC_RESULT_OK upon success or an input error if bad input is provided. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container. </dd></dl>

</div>
</div>
<a id="acfffcabc032f3e0e4da9eec3c1ce2950" name="acfffcabc032f3e0e4da9eec3c1ce2950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfffcabc032f3e0e4da9eec3c1ce2950">&#9670;&#160;</a></span>CCC_buffer_pop_back_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_pop_back_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pop count elements from the back of the Buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the number of elements to pop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the attempted pop. CCC_RESULT_OK if the Buffer exists and n is within the bounds of size. If the Buffer does not exist an input error is returned. If count is greater than the size of the Buffer size is set to zero and input error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container. </dd></dl>

</div>
</div>
<a id="a692fb97bb1a475d6377ec6abb635819a" name="a692fb97bb1a475d6377ec6abb635819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692fb97bb1a475d6377ec6abb635819a">&#9670;&#160;</a></span>CCC_buffer_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the newly pushed data into the last slot of the buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the pointer to the data of element size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the newly pushed element or NULL if no Buffer exists or resizing has failed due to memory exhuastion or no allocation allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container.</dd></dl>
<p>The data is copied into the Buffer at the final slot if there is remaining capacity. If size is equal to capacity resizing will be attempted but may fail if no allocation function is provided or the allocator provided is exhausted. </p>

</div>
</div>
<a id="a7f96119efe2724e34ee6e879e511154c" name="a7f96119efe2724e34ee6e879e511154c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f96119efe2724e34ee6e879e511154c">&#9670;&#160;</a></span>CCC_buffer_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves space for at least to_add more elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_add</td><td>the number of elements to add to the current size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function to use to reserve memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the reservation. OK if successful, otherwise an error status is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see the CCC_buffer_clear_and_free_reserve function if this function is being used for a one-time dynamic reservation.</dd></dl>
<p>This function can be used for a dynamic buffer with or without allocation permission. If the buffer has allocation permission, it will reserve the required space and later resize if more space is needed.</p>
<p>If the buffer has been initialized with no allocation permission and no memory this function can serve as a one-time reservation. To free the buffer in such a case see the CCC_buffer_clear_and_free_reserve function. </p>

</div>
</div>
<a id="a2d29d714feeec257bae6e418257b721b" name="a2d29d714feeec257bae6e418257b721b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d29d714feeec257bae6e418257b721b">&#9670;&#160;</a></span>CCC_buffer_reverse_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_reverse_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the address of the last element in the Buffer in preparation for iteration according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the last element buffer. This will be equivalent to the Buffer reverse_end iterator if the Buffer size is 0. NULL is returned if a NULL argument is provided or the Buffer has not yet been allocated. </dd></dl>

</div>
</div>
<a id="af0c0f886968ea798e393dfca19b44207" name="af0c0f886968ea798e393dfca19b44207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c0f886968ea798e393dfca19b44207">&#9670;&#160;</a></span>CCC_buffer_reverse_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_reverse_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the reverse_end position of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the reverse_end position. It is undefined to access this position for any reason. NULL is returned if NULL is provided or Buffer has not yet been allocated. </dd></dl>

</div>
</div>
<a id="ab18fd0d8667ceb04699326ad376070fb" name="ab18fd0d8667ceb04699326ad376070fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18fd0d8667ceb04699326ad376070fb">&#9670;&#160;</a></span>CCC_buffer_reverse_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_buffer_reverse_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>advance the iterator to the next slot in the Buffer according to size and in reverse order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>the pointer to the current slot of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next iterator position according to size and in reverse order. NULL is returned if bad input is provided or the Buffer has not been allocated. </dd></dl>

</div>
</div>
<a id="ad6badf4f26a8c92175ed2fc4aea6fb9d" name="ad6badf4f26a8c92175ed2fc4aea6fb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6badf4f26a8c92175ed2fc4aea6fb9d">&#9670;&#160;</a></span>CCC_buffer_size_minus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_size_minus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract count from the size of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the quantity to subtract from the current Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of resizing. CCC_RESULT_OK if no errors occur or an error indicating bad input has been provided.</dd></dl>
<p>If count would reduce the size to less than 0, the Buffer size is set to 0 and the input error status is returned. </p>

</div>
</div>
<a id="af5a69c3f3a8d8b48b03e57e2e35a1201" name="af5a69c3f3a8d8b48b03e57e2e35a1201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a69c3f3a8d8b48b03e57e2e35a1201">&#9670;&#160;</a></span>CCC_buffer_size_plus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_size_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add count to the size of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the quantity to add to the current Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of resizing. CCC_RESULT_OK if no errors occur or an error indicating bad input has been provided.</dd></dl>
<p>If count would exceed the current capacity of the Buffer the size is set to capacity and the input error status is returned. </p>

</div>
</div>
<a id="af864cb915c6a104d9a32b755ebaef56a" name="af864cb915c6a104d9a32b755ebaef56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af864cb915c6a104d9a32b755ebaef56a">&#9670;&#160;</a></span>CCC_buffer_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_size_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Buffer size to n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the new size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of setting the size. CCC_RESULT_OK if no errors occur or an error indicating bad input has been provided.</dd></dl>
<p>If count is larger than the capacity of the Buffer the size is set equal to the capacity and an error is returned. </p>

</div>
</div>
<a id="ab41c9e287da0c2cbcbe11222aa3f151e" name="ab41c9e287da0c2cbcbe11222aa3f151e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41c9e287da0c2cbcbe11222aa3f151e">&#9670;&#160;</a></span>CCC_buffer_sizeof_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_buffer_sizeof_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the type being stored contiguously in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the type being stored in the buffer. 0 if buffer is NULL because a zero sized object is not possible for a buffer. </dd></dl>

</div>
</div>
<a id="af8e624d6ffa19538935cbd17838b659b" name="af8e624d6ffa19538935cbd17838b659b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e624d6ffa19538935cbd17838b659b">&#9670;&#160;</a></span>CCC_buffer_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>swap_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swap elements at index and swap_index according to capacity of the bufer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp</td><td>the pointer to the temporary Buffer of the same size as an element stored in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of an element in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap_index</td><td>the index of an element in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the swap, CCC_RESULT_OK if no error occurs. If no buffer exists, no temp exists, index is out of capacity range, or swap_index is out of capacity range, an input error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function does NOT modify the size of the container.</dd></dl>
<p>Note that index and swap_index are only checked to be within capacity range of the buffer. It is the user's responsibility to check for index and swap_index within bounds of size if such behavior is needed. </p>

</div>
</div>
<a id="abfd334de1ebe17f2e329d501bd59ec99" name="abfd334de1ebe17f2e329d501bd59ec99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd334de1ebe17f2e329d501bd59ec99">&#9670;&#160;</a></span>CCC_buffer_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_buffer_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Buffer.html">CCC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write data to Buffer at slot at index index according to capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index within bounds of capacity of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data that will be written to slot at i. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the write, CCC_RESULT_OK if success. If no Buffer or data exists input error is returned. If index is outside of the range of capacity input error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function does NOT modify the size of the container.</dd></dl>
<p>Note that data will be written to the slot at index i, according to the capacity of the buffer. It is up to the user to ensure index is within size of the Buffer if such behavior is desired. No elements are moved to be preserved meaning any data at index is overwritten. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="buffer_8h.html">buffer.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
