<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/buffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('buffer_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">buffer.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Buffer Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;impl/impl_buffer.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for buffer.h:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h__incl.png" border="0" usemap="#accc_2buffer_8h" alt=""/></div>
<map name="accc_2buffer_8h" id="accc_2buffer_8h">
<area shape="rect" title="The Buffer Interface." alt="" coords="81,5,177,31"/>
<area shape="rect" href="impl__buffer_8h_source.html" title=" " alt="" coords="5,79,145,104"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="87,152,170,177"/>
<area shape="rect" href="impl__types_8h_source.html" title=" " alt="" coords="59,225,198,251"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h__dep__incl.png" border="0" usemap="#accc_2buffer_8hdep" alt=""/></div>
<map name="accc_2buffer_8hdep" id="accc_2buffer_8hdep">
<area shape="rect" title="The Buffer Interface." alt="" coords="375,5,471,31"/>
<area shape="rect" href="impl__flat__double__ended__queue_8h_source.html" title=" " alt="" coords="5,79,184,119"/>
<area shape="rect" href="impl__traits_8h_source.html" title=" " alt="" coords="348,255,511,280"/>
<area shape="rect" href="impl__flat__hash__map_8h_source.html" title=" " alt="" coords="274,79,411,119"/>
<area shape="rect" href="impl__flat__ordered__map_8h_source.html" title=" " alt="" coords="449,79,586,119"/>
<area shape="rect" href="impl__flat__priority__queue_8h_source.html" title=" " alt="" coords="637,79,774,119"/>
<area shape="rect" href="impl__flat__realtime__ordered__map_8h_source.html" title=" " alt="" coords="821,79,1011,119"/>
<area shape="rect" href="flat__double__ended__queue_8h.html" title="The Flat Double Ended Queue Interface." alt="" coords="14,167,181,207"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="383,328,476,353"/>
<area shape="rect" href="flat__hash__map_8h.html" title="The Flat Hash Map Interface." alt="" coords="259,174,413,199"/>
<area shape="rect" href="flat__ordered__map_8h.html" title="The Flat Ordered Map Interface." alt="" coords="437,174,611,199"/>
<area shape="rect" href="flat__priority__queue_8h.html" title="The Flat Priority Queue Interface." alt="" coords="635,174,816,199"/>
<area shape="rect" href="flat__realtime__ordered__map_8h.html" title="The Flat Realtime Ordered Map Interface." alt="" coords="840,167,1027,207"/>
</map>
</div>
</div>
<p><a href="buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a66b89d47e24996c7be07dea5d827e649"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a66b89d47e24996c7be07dea5d827e649">ccc_buf_init</a>(mem_ptr,  alloc_fn,  aux_data,  capacity,  optional_size...)&#160;&#160;&#160;    ccc_impl_buf_init(mem_ptr, alloc_fn, aux_data, capacity, optional_size)</td></tr>
<tr class="memdesc:a66b89d47e24996c7be07dea5d827e649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a contiguous buffer of user a specified type, allocation policy, capacity, and optional starting size.  <br /></td></tr>
<tr class="separator:a66b89d47e24996c7be07dea5d827e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d8dfe1437e87b31e7f5522d85080aba"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_buf_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a></td></tr>
<tr class="memdesc:a7d8dfe1437e87b31e7f5522d85080aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contiguous block of storage for elements of the same type.  <br /></td></tr>
<tr class="separator:a7d8dfe1437e87b31e7f5522d85080aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Insert and Remove Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions assume contiguity of elements in the buffer and increase or decrease size accordingly. </p>
</td></tr>
<tr class="memitem:ae2359dd2088ea0cd0b7bfb8260cbaa66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ae2359dd2088ea0cd0b7bfb8260cbaa66">ccc_buf_alloc</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t capacity, <a class="el" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a> *fn)</td></tr>
<tr class="memdesc:ae2359dd2088ea0cd0b7bfb8260cbaa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates the buffer to the specified size according to the user defined allocation function.  <br /></td></tr>
<tr class="separator:ae2359dd2088ea0cd0b7bfb8260cbaa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176afe75a0442da95a8663efbb6ec8b3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a176afe75a0442da95a8663efbb6ec8b3">ccc_buf_alloc_back</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf)</td></tr>
<tr class="memdesc:a176afe75a0442da95a8663efbb6ec8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a new slot from the buffer at the end of the contiguous array. A slot is equivalent to one of the element type specified when the buffer is initialized.  <br /></td></tr>
<tr class="separator:a176afe75a0442da95a8663efbb6ec8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52c4be9804b8639755e424e4177173c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af52c4be9804b8639755e424e4177173c">ccc_buf_push_back</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, void const *data)</td></tr>
<tr class="memdesc:af52c4be9804b8639755e424e4177173c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the newly pushed data into the last slot of the buffer according to size.  <br /></td></tr>
<tr class="separator:af52c4be9804b8639755e424e4177173c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82c527efc9dc329c39375260d9384ed"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ae82c527efc9dc329c39375260d9384ed">ccc_buf_insert</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t i, void const *data)</td></tr>
<tr class="memdesc:ae82c527efc9dc329c39375260d9384ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert data at slot i according to size of the buffer maintaining contiguous storage of elements between 0 and size.  <br /></td></tr>
<tr class="separator:ae82c527efc9dc329c39375260d9384ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1150613b4392aae875aaf3c96146a39a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a1150613b4392aae875aaf3c96146a39a">ccc_buf_pop_back</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf)</td></tr>
<tr class="memdesc:a1150613b4392aae875aaf3c96146a39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pop the back element from the buffer according to size.  <br /></td></tr>
<tr class="separator:a1150613b4392aae875aaf3c96146a39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac24a10e4e20cc59c7b7b4a81b4704b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aeac24a10e4e20cc59c7b7b4a81b4704b">ccc_buf_pop_back_n</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t n)</td></tr>
<tr class="memdesc:aeac24a10e4e20cc59c7b7b4a81b4704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">pop n elements from the back of the buffer according to size.  <br /></td></tr>
<tr class="separator:aeac24a10e4e20cc59c7b7b4a81b4704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3fe998c43ec179e503d9f7c98f2b83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#acd3fe998c43ec179e503d9f7c98f2b83">ccc_buf_erase</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t i)</td></tr>
<tr class="memdesc:acd3fe998c43ec179e503d9f7c98f2b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase element at slot i according to size of the buffer maintaining contiguous storage of elements between 0 and size.  <br /></td></tr>
<tr class="separator:acd3fe998c43ec179e503d9f7c98f2b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Slot Management Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions interact with slots in the buffer directly and do not modify the size of the buffer. These are best used for custom container implementations operating at a higher level of abstraction. </p>
</td></tr>
<tr class="memitem:a5f45a54a635295a962f520afcf61f3ad"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a5f45a54a635295a962f520afcf61f3ad">ccc_buf_at</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf, size_t i)</td></tr>
<tr class="memdesc:a5f45a54a635295a962f520afcf61f3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the element at slot i in buf.  <br /></td></tr>
<tr class="separator:a5f45a54a635295a962f520afcf61f3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab113a7b29c2288ec307c81a1dffe47a6"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ab113a7b29c2288ec307c81a1dffe47a6">ccc_buf_i</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf, void const *slot)</td></tr>
<tr class="memdesc:ab113a7b29c2288ec307c81a1dffe47a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of an element known to be in the buffer.  <br /></td></tr>
<tr class="separator:ab113a7b29c2288ec307c81a1dffe47a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e900d415ab4c7fca82ad65756d9b6a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a63e900d415ab4c7fca82ad65756d9b6a">ccc_buf_back</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a63e900d415ab4c7fca82ad65756d9b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the final element in the buffer according the current size.  <br /></td></tr>
<tr class="separator:a63e900d415ab4c7fca82ad65756d9b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910cea92529561713753a3450e34c436"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a910cea92529561713753a3450e34c436">ccc_buf_front</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a910cea92529561713753a3450e34c436"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the first element in the buffer at index 0.  <br /></td></tr>
<tr class="separator:a910cea92529561713753a3450e34c436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83006ab67af03f193634e446a5bd3ce9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a83006ab67af03f193634e446a5bd3ce9">ccc_buf_copy</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t dst, size_t src)</td></tr>
<tr class="memdesc:a83006ab67af03f193634e446a5bd3ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy data at index src to dst according to capacity.  <br /></td></tr>
<tr class="separator:a83006ab67af03f193634e446a5bd3ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764b6e66be33497355956c55b22712a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a764b6e66be33497355956c55b22712a9">ccc_buf_write</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t i, void const *data)</td></tr>
<tr class="memdesc:a764b6e66be33497355956c55b22712a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">write data to buffer at slot at index i according to capacity.  <br /></td></tr>
<tr class="separator:a764b6e66be33497355956c55b22712a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140e6e4c58ece0874c72524eed8ce0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a140e6e4c58ece0874c72524eed8ce0c4">ccc_buf_swap</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, char tmp[], size_t i, size_t j)</td></tr>
<tr class="memdesc:a140e6e4c58ece0874c72524eed8ce0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap elements at i and j according to capacity of the bufer.  <br /></td></tr>
<tr class="separator:a140e6e4c58ece0874c72524eed8ce0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iteration Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following functions implement iterators over the buffer. </p>
</td></tr>
<tr class="memitem:aa2025e9fa8daa95cd7b1f84147ecc14b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa2025e9fa8daa95cd7b1f84147ecc14b">ccc_buf_begin</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:aa2025e9fa8daa95cd7b1f84147ecc14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the base address of the buffer in preparation for iteration.  <br /></td></tr>
<tr class="separator:aa2025e9fa8daa95cd7b1f84147ecc14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735cf0a859dca1708431410398dfdbdf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a735cf0a859dca1708431410398dfdbdf">ccc_buf_next</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf, void const *iter)</td></tr>
<tr class="memdesc:a735cf0a859dca1708431410398dfdbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">advance the iter to the next slot in the buffer according to size.  <br /></td></tr>
<tr class="separator:a735cf0a859dca1708431410398dfdbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b30824e5b5244058aa4bbf8d9d4660"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a80b30824e5b5244058aa4bbf8d9d4660">ccc_buf_end</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a80b30824e5b5244058aa4bbf8d9d4660"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the end position of the buffer according to size.  <br /></td></tr>
<tr class="separator:a80b30824e5b5244058aa4bbf8d9d4660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d42a75bb27fe09f0e6947b20148a6c5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a4d42a75bb27fe09f0e6947b20148a6c5">ccc_buf_capacity_end</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a4d42a75bb27fe09f0e6947b20148a6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the end position of the buffer according to capacity.  <br /></td></tr>
<tr class="separator:a4d42a75bb27fe09f0e6947b20148a6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77438a7cc61c4b76776db6a5ff6d9316"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a77438a7cc61c4b76776db6a5ff6d9316">ccc_buf_rbegin</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a77438a7cc61c4b76776db6a5ff6d9316"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the address of the last element in the buffer in preparation for iteration according to size.  <br /></td></tr>
<tr class="separator:a77438a7cc61c4b76776db6a5ff6d9316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61080f33c02ed033f249e6639e6b4ec6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a61080f33c02ed033f249e6639e6b4ec6">ccc_buf_rnext</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf, void const *iter)</td></tr>
<tr class="memdesc:a61080f33c02ed033f249e6639e6b4ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">advance the iter to the next slot in the buffer according to size and in reverse order.  <br /></td></tr>
<tr class="separator:a61080f33c02ed033f249e6639e6b4ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d000d8e2b263a44fd0d754a98513931"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a4d000d8e2b263a44fd0d754a98513931">ccc_buf_rend</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a4d000d8e2b263a44fd0d754a98513931"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the rend position of the buffer.  <br /></td></tr>
<tr class="separator:a4d000d8e2b263a44fd0d754a98513931"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions help manage or obtain state of the buffer. </p>
</td></tr>
<tr class="memitem:a771c734d199d4cc35654bcd5d62b3fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a771c734d199d4cc35654bcd5d62b3fb3">ccc_buf_size_plus</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t n)</td></tr>
<tr class="memdesc:a771c734d199d4cc35654bcd5d62b3fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">add n to the size of the buffer.  <br /></td></tr>
<tr class="separator:a771c734d199d4cc35654bcd5d62b3fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12150474cd794575ba4eb7442247d327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a12150474cd794575ba4eb7442247d327">ccc_buf_size_minus</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t n)</td></tr>
<tr class="memdesc:a12150474cd794575ba4eb7442247d327"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract n from the size of the buffer.  <br /></td></tr>
<tr class="separator:a12150474cd794575ba4eb7442247d327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddb0477e6fb68d75086489a973afc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a38ddb0477e6fb68d75086489a973afc4">ccc_buf_size_set</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *buf, size_t n)</td></tr>
<tr class="memdesc:a38ddb0477e6fb68d75086489a973afc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the buffer size to n.  <br /></td></tr>
<tr class="separator:a38ddb0477e6fb68d75086489a973afc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55856605715417962185d9d011b1693e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a55856605715417962185d9d011b1693e">ccc_buf_capacity</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a55856605715417962185d9d011b1693e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the current capacity of the buffer.  <br /></td></tr>
<tr class="separator:a55856605715417962185d9d011b1693e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660b33dcdef5e9f4f13e1863955c0757"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a660b33dcdef5e9f4f13e1863955c0757">ccc_buf_elem_size</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a660b33dcdef5e9f4f13e1863955c0757"><td class="mdescLeft">&#160;</td><td class="mdescRight">the size of the type being stored contiguously in the buffer.  <br /></td></tr>
<tr class="separator:a660b33dcdef5e9f4f13e1863955c0757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85c4278eebbbb17f8b8e08c7d8c659d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ad85c4278eebbbb17f8b8e08c7d8c659d">ccc_buf_size</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:ad85c4278eebbbb17f8b8e08c7d8c659d"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the size of the buffer.  <br /></td></tr>
<tr class="separator:ad85c4278eebbbb17f8b8e08c7d8c659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cd0299aeb6c718195677dc3f0cddd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a06cd0299aeb6c718195677dc3f0cddd1">ccc_buf_is_empty</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:a06cd0299aeb6c718195677dc3f0cddd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the size of the buffer is 0.  <br /></td></tr>
<tr class="separator:a06cd0299aeb6c718195677dc3f0cddd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61275a99d04957d8c19d411c7053e4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa61275a99d04957d8c19d411c7053e4a">ccc_buf_is_full</a> (<a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *buf)</td></tr>
<tr class="memdesc:aa61275a99d04957d8c19d411c7053e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the size of the buffer equals capacity.  <br /></td></tr>
<tr class="separator:aa61275a99d04957d8c19d411c7053e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Buffer Interface. </p>
<p>Buffer usage is similar to a C++ vector, with more flexible functions provided to support higher level containers and abstractions. While useful on its own&ndash;a stack could be implemented with the provided functions&ndash;a buffer is often used as the lower level abstraction for the flat data structures in this library that provide more specialized operations. A buffer does not require the user accommodate any intrusive elements.</p>
<p>A buffer with allocation permission will re-size when a new element is inserted in a contiguous fashion. Interface in the allocation management section assume elements are stored contiguously and adjust size accordingly.</p>
<p>Interface in the slot management section offer data movement and writing operations that do not affect the size of the container. If writing a more complex higher level container that does not need size management these functions offer more custom control over the buffer.</p>
<p>If allocation is not permitted, resizing will not occur and the insertion function will fail when capacity is reached, returning some value to indicate failure.</p>
<p>If shorter names are desired, define the following preprocessor directive.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>Then, the <code>ccc_</code> prefix can be dropped from all types and functions. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a66b89d47e24996c7be07dea5d827e649" name="a66b89d47e24996c7be07dea5d827e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b89d47e24996c7be07dea5d827e649">&#9670;&#160;</a></span>ccc_buf_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_buf_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mem_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alloc_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">aux_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_size...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_buf_init(mem_ptr, alloc_fn, aux_data, capacity, optional_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a contiguous buffer of user a specified type, allocation policy, capacity, and optional starting size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_ptr</td><td>the pointer to existing memory or ((Type *)NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_fn</td><td>ccc_alloc_fn or NULL if no allocation is permitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the capacity of memory at mem_ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_size</td><td>optional starting size of the buffer &lt;= capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized buffer. Directly assign to buffer on the right hand side of the equality operator (e.g. ccc_buffer b = <a class="el" href="buffer_8h.html#a66b89d47e24996c7be07dea5d827e649" title="Initialize a contiguous buffer of user a specified type, allocation policy, capacity,...">ccc_buf_init(...)</a>;).</dd></dl>
<p>Initialization of a buffer can occur at compile time or run time depending on the arguments. The memory pointer should be of the same type one intends to store in the buffer. Therefore, if one desires a dynamic buffer with a starting capacity of 0 and mem_ptr of NULL, casting to a type is required (e.g. (int*)NULL).</p>
<p>This initializer determines memory control for the lifetime of the buffer. If the buffer points to memory of a predetermined and fixed capacity do not provide an allocation function. If a dynamic buffer is preferred, provide the allocation function as defined by the signature in <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a>. If resizing is desired on memory that has already been allocated, ensure allocation has occurred with the provided allocation function. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7d8dfe1437e87b31e7f5522d85080aba" name="a7d8dfe1437e87b31e7f5522d85080aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8dfe1437e87b31e7f5522d85080aba">&#9670;&#160;</a></span>ccc_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_buf_ <a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A contiguous block of storage for elements of the same type. </p>
<dl class="section warning"><dt>Warning</dt><dd>it is undefined behavior to use an uninitialized buffer.</dd></dl>
<p>A buffer may be initialized on the stack, heap, or data segment at compile time or runtime. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae2359dd2088ea0cd0b7bfb8260cbaa66" name="ae2359dd2088ea0cd0b7bfb8260cbaa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2359dd2088ea0cd0b7bfb8260cbaa66">&#9670;&#160;</a></span>ccc_buf_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates the buffer to the specified size according to the user defined allocation function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>a pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the newly desired capacity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the allocation function defined by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of reallocation.</dd></dl>
<p>This function takes the allocation function as an argument in case no allocation function has been provided upon initialization and the user is managing allocations and resizing directly. If an allocation function has been provided than the use of this function should be rare as the buffer will reallocate more memory when necessary. </p>

</div>
</div>
<a id="a176afe75a0442da95a8663efbb6ec8b3" name="a176afe75a0442da95a8663efbb6ec8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176afe75a0442da95a8663efbb6ec8b3">&#9670;&#160;</a></span>ccc_buf_alloc_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_alloc_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a new slot from the buffer at the end of the contiguous array. A slot is equivalent to one of the element type specified when the buffer is initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>a pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory or NULL if no buffer is provided or the buffer is unable to allocate more memory. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container.</dd></dl>
<p>A buffer can be used as the backing for more complex data structures. Requesting new space from a buffer as an allocator can be helpful for these higher level organizations. </p>

</div>
</div>
<a id="a5f45a54a635295a962f520afcf61f3ad" name="a5f45a54a635295a962f520afcf61f3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f45a54a635295a962f520afcf61f3ad">&#9670;&#160;</a></span>ccc_buf_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the element at slot i in buf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index within capacity range of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element in the slot at position i or NULL if i is out of capacity range.</dd></dl>
<p>Note that as long as the index is valid within the capacity of the buffer a valid pointer is returned, which may result in a slot of old or uninitialized data. It is up to the user to ensure the index provided is within the current size of the buffer. </p>

</div>
</div>
<a id="a63e900d415ab4c7fca82ad65756d9b6a" name="a63e900d415ab4c7fca82ad65756d9b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e900d415ab4c7fca82ad65756d9b6a">&#9670;&#160;</a></span>ccc_buf_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the final element in the buffer according the current size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer the final element in the buffer according to the current size or NULL if the buffer does not exist or is empty. </dd></dl>

</div>
</div>
<a id="aa2025e9fa8daa95cd7b1f84147ecc14b" name="aa2025e9fa8daa95cd7b1f84147ecc14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2025e9fa8daa95cd7b1f84147ecc14b">&#9670;&#160;</a></span>ccc_buf_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the base address of the buffer in preparation for iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base address of the buffer. This will be equivalent to the buffer end iterator if the buffer size is 0. NULL is returned if a NULL argument is provided or the buffer has not yet been allocated. </dd></dl>

</div>
</div>
<a id="a55856605715417962185d9d011b1693e" name="a55856605715417962185d9d011b1693e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55856605715417962185d9d011b1693e">&#9670;&#160;</a></span>ccc_buf_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_buf_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the current capacity of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of elements the can be stored in the buffer. This value remains the same until a resize occurs. </dd></dl>

</div>
</div>
<a id="a4d42a75bb27fe09f0e6947b20148a6c5" name="a4d42a75bb27fe09f0e6947b20148a6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d42a75bb27fe09f0e6947b20148a6c5">&#9670;&#160;</a></span>ccc_buf_capacity_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_capacity_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the end position of the buffer according to capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the position one past capacity. It is undefined to access this position for any reason. NULL is returned if NULL is provided or buffer has not yet been allocated.</dd></dl>
<p>Note that end is determined by the capcity of the buffer and will not change until a resize has occured, if permitted. </p>

</div>
</div>
<a id="a83006ab67af03f193634e446a5bd3ce9" name="a83006ab67af03f193634e446a5bd3ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83006ab67af03f193634e446a5bd3ce9">&#9670;&#160;</a></span>ccc_buf_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy data at index src to dst according to capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>the index of destination within bounds of capacity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the index of source within bounds of capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the slot at dst or NULL if bad input is provided. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function does NOT modify the size of the container.</dd></dl>
<p>Note that destination and source are only required to be valid within bounds of capacity of the buffer. It is up to the user to ensure destination and source are within the size bounds of the buffer. </p>

</div>
</div>
<a id="a660b33dcdef5e9f4f13e1863955c0757" name="a660b33dcdef5e9f4f13e1863955c0757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660b33dcdef5e9f4f13e1863955c0757">&#9670;&#160;</a></span>ccc_buf_elem_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_buf_elem_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the size of the type being stored contiguously in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the type being stored in the buffer. </dd></dl>

</div>
</div>
<a id="a80b30824e5b5244058aa4bbf8d9d4660" name="a80b30824e5b5244058aa4bbf8d9d4660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b30824e5b5244058aa4bbf8d9d4660">&#9670;&#160;</a></span>ccc_buf_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the end position of the buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the end position. It is undefined to access this position for any reason. NULL is returned if NULL is provided or buffer has not yet been allocated.</dd></dl>
<p>Note that end is determined by the size of the buffer dynamically. </p>

</div>
</div>
<a id="acd3fe998c43ec179e503d9f7c98f2b83" name="acd3fe998c43ec179e503d9f7c98f2b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3fe998c43ec179e503d9f7c98f2b83">&#9670;&#160;</a></span>ccc_buf_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase element at slot i according to size of the buffer maintaining contiguous storage of elements between 0 and size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index of the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result, CCC_OK if the input is valid. If no buffer exists or i is out of range of size then an input error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container.</dd></dl>
<p>Note that this function assumes elements must be maintained contiguously according to size meaning a bulk copy of elements sliding down to fill the space left by i will occur. </p>

</div>
</div>
<a id="a910cea92529561713753a3450e34c436" name="a910cea92529561713753a3450e34c436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910cea92529561713753a3450e34c436">&#9670;&#160;</a></span>ccc_buf_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the first element in the buffer at index 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the front element or NULL if the buffer does not exist or is empty. </dd></dl>

</div>
</div>
<a id="ab113a7b29c2288ec307c81a1dffe47a6" name="ab113a7b29c2288ec307c81a1dffe47a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab113a7b29c2288ec307c81a1dffe47a6">&#9670;&#160;</a></span>ccc_buf_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t ccc_buf_i </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the index of an element known to be in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>the pointer to the element stored in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index if the slot provided is within the capacity range of the buffer, otherwise -1. </dd></dl>

</div>
</div>
<a id="ae82c527efc9dc329c39375260d9384ed" name="ae82c527efc9dc329c39375260d9384ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82c527efc9dc329c39375260d9384ed">&#9670;&#160;</a></span>ccc_buf_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert data at slot i according to size of the buffer maintaining contiguous storage of elements between 0 and size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index at which to insert data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data copied into the buffer at index i of the same size as elements stored in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the inserted element or NULL if bad input is provided, the buffer is full and no resizing is allowed, or resizing fails when resizing is allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container.</dd></dl>
<p>Note that this function assumes elements must be maintained contiguously according to size of the buffer meaning a bulk move of elements sliding down to accommodate i will occur. </p>

</div>
</div>
<a id="a06cd0299aeb6c718195677dc3f0cddd1" name="a06cd0299aeb6c718195677dc3f0cddd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cd0299aeb6c718195677dc3f0cddd1">&#9670;&#160;</a></span>ccc_buf_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_buf_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if the size of the buffer is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size is 0 false if not. </dd></dl>

</div>
</div>
<a id="aa61275a99d04957d8c19d411c7053e4a" name="aa61275a99d04957d8c19d411c7053e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61275a99d04957d8c19d411c7053e4a">&#9670;&#160;</a></span>ccc_buf_is_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_buf_is_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if the size of the buffer equals capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size equals the capacity. </dd></dl>

</div>
</div>
<a id="a735cf0a859dca1708431410398dfdbdf" name="a735cf0a859dca1708431410398dfdbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735cf0a859dca1708431410398dfdbdf">&#9670;&#160;</a></span>ccc_buf_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>advance the iter to the next slot in the buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the pointer to the current slot of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next iterator position according to size. </dd></dl>

</div>
</div>
<a id="a1150613b4392aae875aaf3c96146a39a" name="a1150613b4392aae875aaf3c96146a39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1150613b4392aae875aaf3c96146a39a">&#9670;&#160;</a></span>ccc_buf_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pop the back element from the buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the attempted pop. CCC_OK upon success or an input error if bad input is provided. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container. </dd></dl>

</div>
</div>
<a id="aeac24a10e4e20cc59c7b7b4a81b4704b" name="aeac24a10e4e20cc59c7b7b4a81b4704b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac24a10e4e20cc59c7b7b4a81b4704b">&#9670;&#160;</a></span>ccc_buf_pop_back_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_pop_back_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pop n elements from the back of the buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of elements to pop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the attempted pop. CCC_OK if the buffer exists and n is within the bounds of size. If the buffer does not exist an input error is returned. If n is greater than the size of the buffer size is set to zero and input error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container. </dd></dl>

</div>
</div>
<a id="af52c4be9804b8639755e424e4177173c" name="af52c4be9804b8639755e424e4177173c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52c4be9804b8639755e424e4177173c">&#9670;&#160;</a></span>ccc_buf_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the newly pushed data into the last slot of the buffer according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the pointer to the data of element size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the newly pushed element or NULL if no buffer exists or resizing has failed due to memory exhuastion or no allocation allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies the size of the container.</dd></dl>
<p>The data is copied into the buffer at the final slot if there is remaining capacity. If size is equal to capacity resizing will be attempted but may fail if no allocation function is provided or the allocator provided is exhausted. </p>

</div>
</div>
<a id="a77438a7cc61c4b76776db6a5ff6d9316" name="a77438a7cc61c4b76776db6a5ff6d9316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77438a7cc61c4b76776db6a5ff6d9316">&#9670;&#160;</a></span>ccc_buf_rbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the address of the last element in the buffer in preparation for iteration according to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the last element buffer. This will be equivalent to the buffer rend iterator if the buffer size is 0. NULL is returned if a NULL argument is provided or the buffer has not yet been allocated. </dd></dl>

</div>
</div>
<a id="a4d000d8e2b263a44fd0d754a98513931" name="a4d000d8e2b263a44fd0d754a98513931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d000d8e2b263a44fd0d754a98513931">&#9670;&#160;</a></span>ccc_buf_rend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the rend position of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the rend position. It is undefined to access this position for any reason. NULL is returned if NULL is provided or buffer has not yet been allocated. </dd></dl>

</div>
</div>
<a id="a61080f33c02ed033f249e6639e6b4ec6" name="a61080f33c02ed033f249e6639e6b4ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61080f33c02ed033f249e6639e6b4ec6">&#9670;&#160;</a></span>ccc_buf_rnext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_buf_rnext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>advance the iter to the next slot in the buffer according to size and in reverse order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>the pointer to the current slot of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next iterator position according to size and in reverse order. NULL is returned if bad input is provided or the buffer has not been allocated. </dd></dl>

</div>
</div>
<a id="ad85c4278eebbbb17f8b8e08c7d8c659d" name="ad85c4278eebbbb17f8b8e08c7d8c659d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85c4278eebbbb17f8b8e08c7d8c659d">&#9670;&#160;</a></span>ccc_buf_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_buf_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the size of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quantity of elements stored in the buffer.</dd></dl>
<p>Note that size must be less than or equal to capacity. </p>

</div>
</div>
<a id="a12150474cd794575ba4eb7442247d327" name="a12150474cd794575ba4eb7442247d327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12150474cd794575ba4eb7442247d327">&#9670;&#160;</a></span>ccc_buf_size_minus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_size_minus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subtract n from the size of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the quantity to subtract from the current buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of resizing. CCC_OK if no errors occur or an error indicating bad input has been provided.</dd></dl>
<p>If n would reduce the size to less than 0, the buffer size is set to 0 and the input error status is returned. </p>

</div>
</div>
<a id="a771c734d199d4cc35654bcd5d62b3fb3" name="a771c734d199d4cc35654bcd5d62b3fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771c734d199d4cc35654bcd5d62b3fb3">&#9670;&#160;</a></span>ccc_buf_size_plus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_size_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add n to the size of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the quantity to add to the current buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of resizing. CCC_OK if no errors occur or an error indicating bad input has been provided.</dd></dl>
<p>If n would exceed the current capacity of the buffer the size is set to capacity and the input error status is returned. </p>

</div>
</div>
<a id="a38ddb0477e6fb68d75086489a973afc4" name="a38ddb0477e6fb68d75086489a973afc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ddb0477e6fb68d75086489a973afc4">&#9670;&#160;</a></span>ccc_buf_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_size_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the buffer size to n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the new size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of setting the size. CCC_OK if no errors occur or an error indicating bad input has been provided.</dd></dl>
<p>If n is larger than the capacity of the buffer the size is set equal to the capacity and an error is returned. </p>

</div>
</div>
<a id="a140e6e4c58ece0874c72524eed8ce0c4" name="a140e6e4c58ece0874c72524eed8ce0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140e6e4c58ece0874c72524eed8ce0c4">&#9670;&#160;</a></span>ccc_buf_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>tmp</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swap elements at i and j according to capacity of the bufer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>the pointer to the temporary buffer of the same size as an element stored in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index of an element in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>the index of an element in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the swap, CCC_OK if no error occurs. If no buffer exists, no tmp exists, i is out of capacity range, or j is out of capacity range, an input error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function does NOT modify the size of the container.</dd></dl>
<p>Note that i and j are only checked to be within capacity range of the buffer. It is the user's responsibility to check for i and j within bounds of size if such behavior is needed. </p>

</div>
</div>
<a id="a764b6e66be33497355956c55b22712a9" name="a764b6e66be33497355956c55b22712a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764b6e66be33497355956c55b22712a9">&#9670;&#160;</a></span>ccc_buf_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_buf_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a7d8dfe1437e87b31e7f5522d85080aba">ccc_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write data to buffer at slot at index i according to capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index within bounds of capacity of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data that will be written to slot at i. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the write, CCC_OK if success. If no buffer or data exists input error is returned. If i is outside of the range of capacity input error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function does NOT modify the size of the container.</dd></dl>
<p>Note that data will be written to the slot at index i, according to the capacity of the buffer. It is up to the user to ensure i is within size of the buffer if such behavior is desired. No elements are moved to be preserved meaning any data at i is overwritten. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="buffer_8h.html">buffer.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
