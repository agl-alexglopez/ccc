<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/flat_hash_map.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('flat__hash__map_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">flat_hash_map.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Flat Hash Map Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="private__flat__hash__map_8h_source.html">private/private_flat_hash_map.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for flat_hash_map.h:</div>
<div class="dyncontent">
<div class="center"><img src="flat__hash__map_8h__incl.png" border="0" usemap="#accc_2flat__hash__map_8h" alt=""/></div>
<map name="accc_2flat__hash__map_8h" id="accc_2flat__hash__map_8h">
<area shape="rect" title="The Flat Hash Map Interface." alt="" coords="5,5,160,31"/>
<area shape="rect" href="private__flat__hash__map_8h.html" title="Private Flat Hash Map Interface." alt="" coords="65,79,212,119"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="19,167,101,192"/>
<area shape="rect" href="private__types_8h_source.html" title=" " alt="" coords="12,240,185,265"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="flat__hash__map_8h__dep__incl.png" border="0" usemap="#accc_2flat__hash__map_8hdep" alt=""/></div>
<map name="accc_2flat__hash__map_8hdep" id="accc_2flat__hash__map_8hdep">
<area shape="rect" title="The Flat Hash Map Interface." alt="" coords="5,5,160,31"/>
<area shape="rect" href="private__traits_8h_source.html" title=" " alt="" coords="11,79,154,119"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="36,167,129,192"/>
</map>
</div>
</div>
<p><a href="flat__hash__map_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Flat Hash Map Interface. </p>
<p>A Flat Hash Map stores elements in a contiguous buffer and allows the user to retrieve them by key in amortized <code>O(1)</code>. Elements in the table may be copied and moved, especially when rehashing occurs, so no pointer stability is available in this implementation.</p>
<p>A flat hash map requires the user to provide a pointer to the map, a type, a key field, a hash function, and a key three way comparator function. The hasher should be well tailored to the key being stored in the table to prevent collisions. Good variety in the upper bits of the hashed value will also result in faster performance. Currently, the flat hash map does not offer any default hash functions or hash strengthening algorithms so strong hash functions should be obtained by the user for the data set.</p>
<p>The current implementation will seek to use the best platform specific Single Instruction Multiple Data (SIMD) or Single Register Multiple Data (SRMD) instructions available. However, if for any reason the user wishes to use the most portable Single Register Multiple Data fallback implementation, there are many options.</p>
<p>If building this library separately to include its library file, add the flag to the build (and read INSTALL.md for more details).</p>
<div class="fragment"><div class="line">cmake --preset=clang-release -DCCC_FLAT_HASH_MAP_PORTABLE</div>
</div><!-- fragment --><p>If an install location other than the release folder is desired don't forget to add the install prefix.</p>
<div class="fragment"><div class="line">cmake --preset=clang-release -DCCC_FLAT_HASH_MAP_PORTABLE \</div>
<div class="line">-DCMAKE_INSTALL_PREFIX=/my/path/</div>
</div><!-- fragment --><p>If this library is being built as part of your project then define the flag as part of your configuration.</p>
<div class="fragment"><div class="line">cmake --preset=my-preset -DCCC_FLAT_HASH_MAP_PORTABLE</div>
</div><!-- fragment --><p>Or, add the flag to your <code>CMakePresets.json</code>.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;cacheVariables&quot;</span>: {</div>
<div class="line">    <span class="stringliteral">&quot;CCC_FLAT_HASH_MAP_PORTABLE&quot;</span>: <span class="stringliteral">&quot;ON&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Or, enable on a per target basis in your <code>CMakeLists.txt</code>.</p>
<div class="fragment"><div class="line">target_compile_definitions(my_target PRIVATE CCC_FLAT_HASH_MAP_PORTABLE)</div>
</div><!-- fragment --><p>Or finally, just define it before including the flat hash map header.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CCC_FLAT_HASH_MAP_PORTABLE</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="flat__hash__map_8h.html">ccc/flat_hash_map.h</a>&quot;</span></div>
<div class="ttc" id="aflat__hash__map_8h_html"><div class="ttname"><a href="flat__hash__map_8h.html">flat_hash_map.h</a></div><div class="ttdoc">The Flat Hash Map Interface.</div></div>
</div><!-- fragment --><p>To shorten names in the interface, define the following preprocessor directive at the top of your file. The <code>CCC_</code> prefix may then be omitted for only this container.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="flat__hash__map_8h.html">ccc/flat_hash_map.h</a>&quot;</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>CCC_</code> prefix. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Initialize the container with memory, callbacks, and permissions. When a fixed size map is required that will not have allocation permission, the user must declare the type name and size of the map they will use. </p>
</td></tr>
<tr class="memitem:ac0d42fc4658620cffb6598b6b2792846"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ac0d42fc4658620cffb6598b6b2792846">CCC_flat_hash_map_declare_fixed</a>(fixed_map_type_name,  type_name,  capacity)</td></tr>
<tr class="memdesc:ac0d42fc4658620cffb6598b6b2792846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a fixed size map type for use in the stack, heap, or data segment. Does not return a value.  <br /></td></tr>
<tr class="separator:ac0d42fc4658620cffb6598b6b2792846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dac035c65b826f4f9ac3b269c395ba2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a3dac035c65b826f4f9ac3b269c395ba2">CCC_flat_hash_map_fixed_capacity</a>(fixed_map_type_name)&#160;&#160;&#160;    <a class="el" href="private__flat__hash__map_8h.html#acb4ac419bacd4c7cf728b5a56b99214a">CCC_private_flat_hash_map_fixed_capacity</a>(fixed_map_type_name)</td></tr>
<tr class="memdesc:a3dac035c65b826f4f9ac3b269c395ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the capacity previously chosen for the fixed size map type.  <br /></td></tr>
<tr class="separator:a3dac035c65b826f4f9ac3b269c395ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5bed49083f78e8f594e5c4c866b306"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a2e5bed49083f78e8f594e5c4c866b306">CCC_flat_hash_map_initialize</a>(map_pointer,  type_name,  key_field,  hash,  compare,  allocate,  context_data,  capacity)</td></tr>
<tr class="memdesc:a2e5bed49083f78e8f594e5c4c866b306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a map of types at compile time or runtime.  <br /></td></tr>
<tr class="separator:a2e5bed49083f78e8f594e5c4c866b306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c92e607eff75132bc53f47117a0897"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ae0c92e607eff75132bc53f47117a0897">CCC_flat_hash_map_from</a>(key_field,  hash,  compare,  allocate,  context_data,  optional_capacity,  array_compound_literal...)</td></tr>
<tr class="memdesc:ae0c92e607eff75132bc53f47117a0897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a dynamic map at runtime from an initializer list.  <br /></td></tr>
<tr class="separator:ae0c92e607eff75132bc53f47117a0897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c20255e47fb5ac259edf75b6d0db77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a00c20255e47fb5ac259edf75b6d0db77">CCC_flat_hash_map_with_capacity</a>(type_name,  key_field,  hash,  compare,  allocate,  context_data,  capacity)</td></tr>
<tr class="memdesc:a00c20255e47fb5ac259edf75b6d0db77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a dynamic map at runtime with at least the specified capacity.  <br /></td></tr>
<tr class="separator:a00c20255e47fb5ac259edf75b6d0db77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b3b5a76a1fabae8d23ff439f21e9ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ae1b3b5a76a1fabae8d23ff439f21e9ba">CCC_flat_hash_map_with_compound_literal</a>(key_field,  hash,  compare,  compound_literal)</td></tr>
<tr class="memdesc:ae1b3b5a76a1fabae8d23ff439f21e9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a fixed map at compile time or runtime from its previously declared type using a compound literal with no allocation permissions or context.  <br /></td></tr>
<tr class="separator:ae1b3b5a76a1fabae8d23ff439f21e9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0120e418b0f915afadd09ff18c3663d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a0120e418b0f915afadd09ff18c3663d5">CCC_flat_hash_map_with_context_compound_literal</a>( key_field,  hash,  compare,  context,  compound_literal)</td></tr>
<tr class="memdesc:a0120e418b0f915afadd09ff18c3663d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a fixed map at compile time or runtime from its previously declared type using a compound literal with no allocation permissions or context.  <br /></td></tr>
<tr class="separator:a0120e418b0f915afadd09ff18c3663d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50ef270ac4a8e36de917e7eb4244474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ad50ef270ac4a8e36de917e7eb4244474">CCC_flat_hash_map_copy</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *destination, <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *source, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:ad50ef270ac4a8e36de917e7eb4244474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the map at source to destination.  <br /></td></tr>
<tr class="separator:ad50ef270ac4a8e36de917e7eb4244474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde2c0903a9cb74a55ae6e22b58d0c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#abde2c0903a9cb74a55ae6e22b58d0c80">CCC_flat_hash_map_reserve</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, size_t to_add, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:abde2c0903a9cb74a55ae6e22b58d0c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space required to add a specified number of elements to the map. If the current capacity is sufficient, do nothing.  <br /></td></tr>
<tr class="separator:abde2c0903a9cb74a55ae6e22b58d0c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Entry Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and operate on container entries for efficient queries when non-trivial control flow is needed. </p>
</td></tr>
<tr class="memitem:a97ee836f2457c88d6e8cd2bf125adbed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a97ee836f2457c88d6e8cd2bf125adbed">CCC_flat_hash_map_entry_wrap</a>(map_pointer,  key_pointer)</td></tr>
<tr class="memdesc:a97ee836f2457c88d6e8cd2bf125adbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains an entry for the provided key in the table for future use.  <br /></td></tr>
<tr class="separator:a97ee836f2457c88d6e8cd2bf125adbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e842555142740fbc0f2138359fc9e21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a3e842555142740fbc0f2138359fc9e21">CCC_flat_hash_map_and_modify_with</a>(map_entry_pointer,  type_name,  closure_over_T...)</td></tr>
<tr class="memdesc:a3e842555142740fbc0f2138359fc9e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an Occupied entry with a closure over user type T.  <br /></td></tr>
<tr class="separator:a3e842555142740fbc0f2138359fc9e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615f68baccbd1dcf4df5f6e13cdbd511"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a615f68baccbd1dcf4df5f6e13cdbd511">CCC_flat_hash_map_or_insert_with</a>(map_entry_pointer,  type_compound_literal...)</td></tr>
<tr class="memdesc:a615f68baccbd1dcf4df5f6e13cdbd511"><td class="mdescLeft">&#160;</td><td class="mdescRight">lazily insert the desired key value into the entry if it is Vacant.  <br /></td></tr>
<tr class="separator:a615f68baccbd1dcf4df5f6e13cdbd511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07faeea63df39aefff6b141454356474"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a07faeea63df39aefff6b141454356474">CCC_flat_hash_map_insert_entry_with</a>(map_entry_pointer,  type_compound_literal...)</td></tr>
<tr class="memdesc:a07faeea63df39aefff6b141454356474"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the contents of the compound literal type_compound_literal to a slot.  <br /></td></tr>
<tr class="separator:a07faeea63df39aefff6b141454356474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922b69ba09e22ab0e5783b49e0b7c21c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a922b69ba09e22ab0e5783b49e0b7c21c">CCC_flat_hash_map_swap_entry_wrap</a>(map_pointer,  type_pointer)</td></tr>
<tr class="memdesc:a922b69ba09e22ab0e5783b49e0b7c21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value wrapping out_handle.  <br /></td></tr>
<tr class="separator:a922b69ba09e22ab0e5783b49e0b7c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f154fc20d4a033856736b7c31794f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a76f154fc20d4a033856736b7c31794f2">CCC_flat_hash_map_remove_entry_wrap</a>(map_entry_pointer)</td></tr>
<tr class="memdesc:a76f154fc20d4a033856736b7c31794f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the entry from the table if Occupied.  <br /></td></tr>
<tr class="separator:a76f154fc20d4a033856736b7c31794f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6389376b4967a060710c8acfb84932e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#aa6389376b4967a060710c8acfb84932e">CCC_flat_hash_map_try_insert_wrap</a>(map_pointer,  type_pointer)</td></tr>
<tr class="memdesc:aa6389376b4967a060710c8acfb84932e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the key value wrapping key_val_array_pointer.  <br /></td></tr>
<tr class="separator:aa6389376b4967a060710c8acfb84932e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918d165b1904c7ee4999a6a4981998da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a918d165b1904c7ee4999a6a4981998da">CCC_flat_hash_map_try_insert_with</a>(map_pointer,  key,  type_compound_literal...)</td></tr>
<tr class="memdesc:a918d165b1904c7ee4999a6a4981998da"><td class="mdescLeft">&#160;</td><td class="mdescRight">lazily insert type_compound_literal into the map at key if key is absent.  <br /></td></tr>
<tr class="separator:a918d165b1904c7ee4999a6a4981998da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602827385a448a0d2b794666a192ba03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a602827385a448a0d2b794666a192ba03">CCC_flat_hash_map_insert_or_assign_wrap</a>(map_pointer,  type_pointer)</td></tr>
<tr class="memdesc:a602827385a448a0d2b794666a192ba03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts or overwrites a user struct into the table.  <br /></td></tr>
<tr class="separator:a602827385a448a0d2b794666a192ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef5fea3c4f141ace47ee8bfca4b2dbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a4ef5fea3c4f141ace47ee8bfca4b2dbe">CCC_flat_hash_map_insert_or_assign_with</a>(map_pointer,  key,  type_compound_literal...)</td></tr>
<tr class="memdesc:a4ef5fea3c4f141ace47ee8bfca4b2dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new key value pair or overwrites the existing entry.  <br /></td></tr>
<tr class="separator:a4ef5fea3c4f141ace47ee8bfca4b2dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c531aa3bf8c6807a4aa6cd856d05167"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a9c531aa3bf8c6807a4aa6cd856d05167">CCC_flat_hash_map_remove_key_value_wrap</a>(map_pointer,  type_output_pointer)</td></tr>
<tr class="memdesc:a9c531aa3bf8c6807a4aa6cd856d05167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key value in the map storing the old value, if present, in the struct containing out_array_pointer provided by the user.  <br /></td></tr>
<tr class="separator:a9c531aa3bf8c6807a4aa6cd856d05167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace45b100db6fc706ad198de15f8daa5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ace45b100db6fc706ad198de15f8daa5b">CCC_flat_hash_map_entry</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, void const *key)</td></tr>
<tr class="memdesc:ace45b100db6fc706ad198de15f8daa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains an entry for the provided key in the table for future use.  <br /></td></tr>
<tr class="separator:ace45b100db6fc706ad198de15f8daa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d351f90feedb05cf3f34311f2b62f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a6d351f90feedb05cf3f34311f2b62f96">CCC_flat_hash_map_and_modify</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> *entry, <a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *modify)</td></tr>
<tr class="memdesc:a6d351f90feedb05cf3f34311f2b62f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the provided entry if it is Occupied.  <br /></td></tr>
<tr class="separator:a6d351f90feedb05cf3f34311f2b62f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d84c76e497eee6decb00b81b283c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ab6d84c76e497eee6decb00b81b283c8a">CCC_flat_hash_map_and_modify_context</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> *entry, <a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *modify, void *context)</td></tr>
<tr class="memdesc:ab6d84c76e497eee6decb00b81b283c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the provided entry if it is Occupied.  <br /></td></tr>
<tr class="separator:ab6d84c76e497eee6decb00b81b283c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a400f6483457e2b3c311aeb7b04ef1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a42a400f6483457e2b3c311aeb7b04ef1">CCC_flat_hash_map_or_insert</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *entry, void const *type)</td></tr>
<tr class="memdesc:a42a400f6483457e2b3c311aeb7b04ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the struct with handle elem if the entry is Vacant.  <br /></td></tr>
<tr class="separator:a42a400f6483457e2b3c311aeb7b04ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895708750e9e898587ff49ee93c39533"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a895708750e9e898587ff49ee93c39533">CCC_flat_hash_map_insert_entry</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *entry, void const *type)</td></tr>
<tr class="memdesc:a895708750e9e898587ff49ee93c39533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the provided entry invariantly.  <br /></td></tr>
<tr class="separator:a895708750e9e898587ff49ee93c39533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4affd82b919c9df2a4da1a6823211c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a4affd82b919c9df2a4da1a6823211c4f">CCC_flat_hash_map_swap_entry</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, void *type_output)</td></tr>
<tr class="memdesc:a4affd82b919c9df2a4da1a6823211c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value wrapping out_handle.  <br /></td></tr>
<tr class="separator:a4affd82b919c9df2a4da1a6823211c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1005ae1299c0d326c8e7f078c42a3d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a1005ae1299c0d326c8e7f078c42a3d03">CCC_flat_hash_map_remove_entry</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:a1005ae1299c0d326c8e7f078c42a3d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the entry from the table if Occupied.  <br /></td></tr>
<tr class="separator:a1005ae1299c0d326c8e7f078c42a3d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5322c01375471a6312397f436ce223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#aff5322c01375471a6312397f436ce223">CCC_flat_hash_map_try_insert</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, void const *type)</td></tr>
<tr class="memdesc:aff5322c01375471a6312397f436ce223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the key value wrapping key_val_handle.  <br /></td></tr>
<tr class="separator:aff5322c01375471a6312397f436ce223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198b193f16959066927c9b1094634edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a198b193f16959066927c9b1094634edc">CCC_flat_hash_map_insert_or_assign</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, void const *type)</td></tr>
<tr class="memdesc:a198b193f16959066927c9b1094634edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts or overwrites a user struct into the table.  <br /></td></tr>
<tr class="separator:a198b193f16959066927c9b1094634edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2413cd3ecd081b5374bfd38210b52e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Entry.html">CCC_Entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a2413cd3ecd081b5374bfd38210b52e13">CCC_flat_hash_map_remove_key_value</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, void *type_output)</td></tr>
<tr class="memdesc:a2413cd3ecd081b5374bfd38210b52e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key value in the map storing the old value, if present, in the struct containing out_handle provided by the user.  <br /></td></tr>
<tr class="separator:a2413cd3ecd081b5374bfd38210b52e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953016c4c7d20e30cd5f5c45a35953f5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a953016c4c7d20e30cd5f5c45a35953f5">CCC_flat_hash_map_unwrap</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:a953016c4c7d20e30cd5f5c45a35953f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps the provided entry to obtain a view into the table element.  <br /></td></tr>
<tr class="separator:a953016c4c7d20e30cd5f5c45a35953f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62e76725801241b7b0e19a755bd281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ada62e76725801241b7b0e19a755bd281">CCC_flat_hash_map_occupied</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:ada62e76725801241b7b0e19a755bd281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vacant or Occupied status of the entry.  <br /></td></tr>
<tr class="separator:ada62e76725801241b7b0e19a755bd281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7f98e257c4b9cfb7d4c673d1b532cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#aed7f98e257c4b9cfb7d4c673d1b532cd">CCC_flat_hash_map_insert_error</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:aed7f98e257c4b9cfb7d4c673d1b532cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the status of the entry should an insertion follow.  <br /></td></tr>
<tr class="separator:aed7f98e257c4b9cfb7d4c673d1b532cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fd776da1bab29f83e4c3e18d2b70f4"><td class="memItemLeft" align="right" valign="top">CCC_Entry_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a21fd776da1bab29f83e4c3e18d2b70f4">CCC_flat_hash_map_entry_status</a> (<a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *entry)</td></tr>
<tr class="memdesc:a21fd776da1bab29f83e4c3e18d2b70f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the entry status from a container entry.  <br /></td></tr>
<tr class="separator:a21fd776da1bab29f83e4c3e18d2b70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Types available in the container interface. </p>
</td></tr>
<tr class="memitem:a398f6327bbe30ab4faaae91bf3a0f236"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a398f6327bbe30ab4faaae91bf3a0f236">CCC_Flat_hash_map</a></td></tr>
<tr class="memdesc:a398f6327bbe30ab4faaae91bf3a0f236"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for storing key-value structures defined by the user in a contiguous buffer.  <br /></td></tr>
<tr class="separator:a398f6327bbe30ab4faaae91bf3a0f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c397e5235fefa94bd3b1f3298a1ae0"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionCCC__Flat__hash__map__entry__wrap.html">CCC_Flat_hash_map_entry_wrap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a11c397e5235fefa94bd3b1f3298a1ae0">CCC_Flat_hash_map_entry</a></td></tr>
<tr class="memdesc:a11c397e5235fefa94bd3b1f3298a1ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container specific entry used to implement the Entry Interface.  <br /></td></tr>
<tr class="separator:a11c397e5235fefa94bd3b1f3298a1ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Membership Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Test membership or obtain references to stored user types directly. </p>
</td></tr>
<tr class="memitem:a6df1e711fb8c15b8161b541a0738256f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a6df1e711fb8c15b8161b541a0738256f">CCC_flat_hash_map_contains</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map, void const *key)</td></tr>
<tr class="memdesc:a6df1e711fb8c15b8161b541a0738256f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the table for the presence of key.  <br /></td></tr>
<tr class="separator:a6df1e711fb8c15b8161b541a0738256f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175e53430218da00b10893523af8ed84"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a175e53430218da00b10893523af8ed84">CCC_flat_hash_map_get_key_value</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map, void const *key)</td></tr>
<tr class="memdesc:a175e53430218da00b10893523af8ed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference into the table at entry key.  <br /></td></tr>
<tr class="separator:a175e53430218da00b10893523af8ed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Destroy the container. </p>
</td></tr>
<tr class="memitem:ae399d874a6bef994e78df9c583ea3a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ae399d874a6bef994e78df9c583ea3a21">CCC_flat_hash_map_clear</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy)</td></tr>
<tr class="memdesc:ae399d874a6bef994e78df9c583ea3a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the table for use without affecting capacity.  <br /></td></tr>
<tr class="separator:ae399d874a6bef994e78df9c583ea3a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55900315034b6a09bf6b254e7e29d6a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a55900315034b6a09bf6b254e7e29d6a8">CCC_flat_hash_map_clear_and_free</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy)</td></tr>
<tr class="memdesc:a55900315034b6a09bf6b254e7e29d6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the table and frees the underlying buffer.  <br /></td></tr>
<tr class="separator:a55900315034b6a09bf6b254e7e29d6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8147a64069ce12361fbd200c1c779db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ab8147a64069ce12361fbd200c1c779db">CCC_flat_hash_map_clear_and_free_reserve</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *map, <a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *destroy, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:ab8147a64069ce12361fbd200c1c779db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the table and frees the underlying Buffer that was previously dynamically reserved with the reserve function.  <br /></td></tr>
<tr class="separator:ab8147a64069ce12361fbd200c1c779db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iterator Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and manage iterators over the container. </p>
</td></tr>
<tr class="memitem:a23bec1d6ce65ab954db8857bf9dd8566"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a23bec1d6ce65ab954db8857bf9dd8566">CCC_flat_hash_map_begin</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map)</td></tr>
<tr class="memdesc:a23bec1d6ce65ab954db8857bf9dd8566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the first element in the table.  <br /></td></tr>
<tr class="separator:a23bec1d6ce65ab954db8857bf9dd8566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e93354bc99ffc6e01a35ef3843fd353"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a3e93354bc99ffc6e01a35ef3843fd353">CCC_flat_hash_map_next</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map, void const *type_iterator)</td></tr>
<tr class="memdesc:a3e93354bc99ffc6e01a35ef3843fd353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator to the next occupied table slot.  <br /></td></tr>
<tr class="separator:a3e93354bc99ffc6e01a35ef3843fd353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266b35d8720080987dc2a425d28f5bd6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a266b35d8720080987dc2a425d28f5bd6">CCC_flat_hash_map_end</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map)</td></tr>
<tr class="memdesc:a266b35d8720080987dc2a425d28f5bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the current iterator against the end for loop termination.  <br /></td></tr>
<tr class="separator:a266b35d8720080987dc2a425d28f5bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain the container state. </p>
</td></tr>
<tr class="memitem:a455d9054ddad4b936f289bef42edf4cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a455d9054ddad4b936f289bef42edf4cf">CCC_flat_hash_map_is_empty</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map)</td></tr>
<tr class="memdesc:a455d9054ddad4b936f289bef42edf4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size status of the table.  <br /></td></tr>
<tr class="separator:a455d9054ddad4b936f289bef42edf4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3166cb826dc03993f39ea9de3e490bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#ae3166cb826dc03993f39ea9de3e490bf">CCC_flat_hash_map_count</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map)</td></tr>
<tr class="memdesc:ae3166cb826dc03993f39ea9de3e490bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of table occupied slots.  <br /></td></tr>
<tr class="separator:ae3166cb826dc03993f39ea9de3e490bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba9c0c19b88bd78edaa1aa00645223c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#adba9c0c19b88bd78edaa1aa00645223c">CCC_flat_hash_map_capacity</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map)</td></tr>
<tr class="memdesc:adba9c0c19b88bd78edaa1aa00645223c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full capacity of the backing storage.  <br /></td></tr>
<tr class="separator:adba9c0c19b88bd78edaa1aa00645223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586d10ff39909b2b1a50f2ce25b63df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flat__hash__map_8h.html#a586d10ff39909b2b1a50f2ce25b63df8">CCC_flat_hash_map_validate</a> (<a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *map)</td></tr>
<tr class="memdesc:a586d10ff39909b2b1a50f2ce25b63df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validation of invariants for the hash table.  <br /></td></tr>
<tr class="separator:a586d10ff39909b2b1a50f2ce25b63df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3e842555142740fbc0f2138359fc9e21" name="a3e842555142740fbc0f2138359fc9e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e842555142740fbc0f2138359fc9e21">&#9670;&#160;</a></span>CCC_flat_hash_map_and_modify_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_and_modify_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">closure_over_T...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="flat__hash__map_8h.html#a11c397e5235fefa94bd3b1f3298a1ae0">CCC_Flat_hash_map_entry</a>)                                                 \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_flat_hash_map_and_modify_with(map_entry_pointer,           \</div>
<div class="line">                                                  type_name, closure_over_T)   \</div>
<div class="line">    }</div>
<div class="ttc" id="aflat__hash__map_8h_html_a11c397e5235fefa94bd3b1f3298a1ae0"><div class="ttname"><a href="flat__hash__map_8h.html#a11c397e5235fefa94bd3b1f3298a1ae0">CCC_Flat_hash_map_entry</a></div><div class="ttdeci">union CCC_Flat_hash_map_entry_wrap CCC_Flat_hash_map_entry</div><div class="ttdoc">A container specific entry used to implement the Entry Interface.</div><div class="ttdef"><b>Definition:</b> flat_hash_map.h:116</div></div>
</div><!-- fragment -->
<p>Modify an Occupied entry with a closure over user type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entry_pointer</td><td>a pointer to the obtained entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the user type stored in the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">closure_over_T</td><td>the code to be run on the reference to user type T, if Occupied. This may be a semicolon separated list of statements to execute on T or a section of code wrapped in braces {code here} which may be preferred for formatting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the modified entry if it was occupied or a vacant entry if it was vacant. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>T is a reference to the user type stored in the entry guaranteed to be non-NULL if the closure executes.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="comment">// Increment the count if found otherwise do nothing.</span></div>
<div class="line">Flat_hash_map_entry *entry =</div>
<div class="line">    flat_hash_map_and_modify_with(</div>
<div class="line">        entry_wrap(&amp;map, &amp;k),</div>
<div class="line">        Word,</div>
<div class="line">        T-&gt;cnt++;</div>
<div class="line">    );</div>
<div class="line"><span class="comment">// Increment the count if found otherwise insert a default value.</span></div>
<div class="line">Word *w =</div>
<div class="line">    flat_hash_map_or_insert_with(</div>
<div class="line">        flat_hash_map_and_modify_with(</div>
<div class="line">            entry_wrap(&amp;flat_hash_map, &amp;k),</div>
<div class="line">            Word,</div>
<div class="line">            { T-&gt;cnt++; }</div>
<div class="line">        ),</div>
<div class="line">        (Word){.key = k, .cnt = 1}</div>
<div class="line">    );</div>
</div><!-- fragment --><p>Note that any code written is only evaluated if the entry is Occupied and the container can deliver the user type T. This means any function calls are lazily evaluated in the closure scope. </p>

</div>
</div>
<a id="ac0d42fc4658620cffb6598b6b2792846" name="ac0d42fc4658620cffb6598b6b2792846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d42fc4658620cffb6598b6b2792846">&#9670;&#160;</a></span>CCC_flat_hash_map_declare_fixed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_declare_fixed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fixed_map_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__flat__hash__map_8h.html#aeed93aa14b4505bf9143afd248826211">CCC_private_flat_hash_map_declare_fixed</a>(fixed_map_type_name, type_name,    \</div>
<div class="line">                                            capacity)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_aeed93aa14b4505bf9143afd248826211"><div class="ttname"><a href="private__flat__hash__map_8h.html#aeed93aa14b4505bf9143afd248826211">CCC_private_flat_hash_map_declare_fixed</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_declare_fixed(fixed_map_type_name, key_val_type_name, capacity)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:229</div></div>
</div><!-- fragment -->
<p>Declare a fixed size map type for use in the stack, heap, or data segment. Does not return a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_map_type_name</td><td>the user chosen name of the fixed sized map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the type the user plans to store in the map. It may have a key and value field as well as any additional fields. For set-like behavior, wrap a field in a struct/union (e.g. <code>union int_node {int e;};</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the power of two capacity for the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>the capacity must be a power of two greater than 8 or 16, depending on the platform (e.g. 16, 32, 64, etc.).</dd></dl>
<p>Once the location for the fixed size map is chosen&ndash;stack, heap, or data segment&ndash;provide a pointer to the map for the initialization macro.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><a class="code hl_define" href="flat__hash__map_8h.html#ac0d42fc4658620cffb6598b6b2792846">CCC_flat_hash_map_declare_fixed</a>(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line"><span class="keyword">static</span> Flat_hash_map static_map = flat_hash_map_initialize(</div>
<div class="line">    &amp;(<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">    <span class="keyword">struct </span>Val,</div>
<div class="line">    key,</div>
<div class="line">    Flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_id_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    flat_hash_map_fixed_capacity(Small_fixed_map)</div>
<div class="line">);</div>
<div class="ttc" id="aflat__hash__map_8h_html_ac0d42fc4658620cffb6598b6b2792846"><div class="ttname"><a href="flat__hash__map_8h.html#ac0d42fc4658620cffb6598b6b2792846">CCC_flat_hash_map_declare_fixed</a></div><div class="ttdeci">#define CCC_flat_hash_map_declare_fixed(fixed_map_type_name, type_name, capacity)</div><div class="ttdoc">Declare a fixed size map type for use in the stack, heap, or data segment. Does not return a value.</div><div class="ttdef"><b>Definition:</b> flat_hash_map.h:190</div></div>
</div><!-- fragment --><p>Similarly, a fixed size map can be used on the stack.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><a class="code hl_define" href="flat__hash__map_8h.html#ac0d42fc4658620cffb6598b6b2792846">CCC_flat_hash_map_declare_fixed</a>(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Flat_hash_map static_map = flat_hash_map_initialize(</div>
<div class="line">        &amp;(Small_fixed_map){},</div>
<div class="line">        <span class="keyword">struct </span>Val,</div>
<div class="line">        key,</div>
<div class="line">        flat_hash_map_int_to_u64,</div>
<div class="line">        flat_hash_map_id_order,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        flat_hash_map_fixed_capacity(Small_fixed_map)</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The CCC_flat_hash_map_fixed_capacity macro can be used to obtain the previously provided capacity when declaring the fixed map type. Finally, one could allocate a fixed size map on the heap; however, it is usually better to initialize a dynamic map and use the CCC_flat_hash_map_reserve function for such a use case.</p>
<p>This macro is not needed when a dynamic resizing flat hash map is needed. For dynamic maps, simply pass NULL and 0 capacity to the initialization macro. </p>

</div>
</div>
<a id="a97ee836f2457c88d6e8cd2bf125adbed" name="a97ee836f2457c88d6e8cd2bf125adbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ee836f2457c88d6e8cd2bf125adbed">&#9670;&#160;</a></span>CCC_flat_hash_map_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="flat__hash__map_8h.html#a11c397e5235fefa94bd3b1f3298a1ae0">CCC_Flat_hash_map_entry</a>)                                                 \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_flat_hash_map_entry(map_pointer, key_pointer).private              \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Obtains an entry for the provided key in the table for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the hash table to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>the key used to search the table matching the stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to a specialized hash entry for use with other functions in the Entry Interface. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the contents of an entry should not be examined or modified. Use the provided functions, only.</dd></dl>
<p>An entry is a search result that provides either an Occupied or Vacant entry in the table. An occupied entry signifies that the search was successful. A Vacant entry means the search was not successful but we now have a handle to where in the table such an element should be inserted.</p>
<p>An entry is most often passed in a functional style to subsequent calls in the Entry Interface. </p>

</div>
</div>
<a id="a3dac035c65b826f4f9ac3b269c395ba2" name="a3dac035c65b826f4f9ac3b269c395ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dac035c65b826f4f9ac3b269c395ba2">&#9670;&#160;</a></span>CCC_flat_hash_map_fixed_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_fixed_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fixed_map_type_name</td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="private__flat__hash__map_8h.html#acb4ac419bacd4c7cf728b5a56b99214a">CCC_private_flat_hash_map_fixed_capacity</a>(fixed_map_type_name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the capacity previously chosen for the fixed size map type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_map_type_name</td><td>the name of a previously declared map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size_t capacity. This is the full capacity without any load factor restrictions. </dd></dl>

</div>
</div>
<a id="ae0c92e607eff75132bc53f47117a0897" name="ae0c92e607eff75132bc53f47117a0897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c92e607eff75132bc53f47117a0897">&#9670;&#160;</a></span>CCC_flat_hash_map_from</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_from</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__flat__hash__map_8h.html#aaaed8a23b1f4548ee47392c0dd3727db">CCC_private_flat_hash_map_from</a>(key_field, hash, compare, allocate,         \</div>
<div class="line">                                   context_data, optional_capacity,            \</div>
<div class="line">                                   array_compound_literal)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_aaaed8a23b1f4548ee47392c0dd3727db"><div class="ttname"><a href="private__flat__hash__map_8h.html#aaaed8a23b1f4548ee47392c0dd3727db">CCC_private_flat_hash_map_from</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_from( private_key_field, private_hash, private_key_compare, private_allocate, private_context_data, private_optional_cap, private_array_compound_literal...)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:297</div></div>
</div><!-- fragment -->
<p>Initialize a dynamic map at runtime from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_field</td><td>the field of the struct used for key storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>the CCC_Key_hasher function provided by the user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the CCC_Key_comparator the user intends to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>context data that is needed for hashing or comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_capacity</td><td>optionally specify the capacity of the map if different from the size of the compound literal array initializer. If the capacity is greater than the size of the compound literal array initializer, it is respected and the capacity is reserved. If the capacity is less than the size of the compound array initializer, the compound literal array initializer size is set as the capacity. Therefore, 0 is valid if one is not concerned with the size of the underlying reservation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_compound_literal</td><td>a list of key value pairs of the type intended to be stored in the map, using array compound literal initialization syntax (e.g <code>(struct My_type[]){{.k = 0, .v 0}, {.k = 1, .v = 1}}</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the flat hash map directly initialized on the right hand side of the equality operator (i.e. <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> map = <a class="el" href="flat__hash__map_8h.html#ae0c92e607eff75132bc53f47117a0897" title="Initialize a dynamic map at runtime from an initializer list.">CCC_flat_hash_map_from(...)</a>;) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>An allocation function is required. This initializer is only available for dynamic maps. </dd>
<dd>
When duplicate keys appear in the initializer list, the last occurrence replaces earlier ones by value (all fields are overwritten). </dd>
<dd>
If initialization fails, the map will be returned empty. All subsequent queries, insertions, or removals will indicate the error: either memory related or lack of an allocation function provided.</dd></dl>
<p>Initialize a dynamic hash table at run time. This example requires no context data for initialization.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Flat_hash_map map = flat_hash_map_from(</div>
<div class="line">        key,</div>
<div class="line">        flat_hash_map_int_to_u64,</div>
<div class="line">        flat_hash_map_key_order,</div>
<div class="line">        std_allocate,</div>
<div class="line">        NULL,</div>
<div class="line">        0,</div>
<div class="line">        (<span class="keyword">struct</span> Val[]) {</div>
<div class="line">            {.key = 1, .val = 1},</div>
<div class="line">            {.key = 2, .val = 2},</div>
<div class="line">            {.key = 3, .val = 3},</div>
<div class="line">        },</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Only dynamic maps may be initialized this way due the inability of the hash map to protect its invariants from user error at compile time. </p>

</div>
</div>
<a id="a2e5bed49083f78e8f594e5c4c866b306" name="a2e5bed49083f78e8f594e5c4c866b306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5bed49083f78e8f594e5c4c866b306">&#9670;&#160;</a></span>CCC_flat_hash_map_initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_initialize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__flat__hash__map_8h.html#aa0ab2a47b824372a9509d90a899f1971">CCC_private_flat_hash_map_initialize</a>(map_pointer, type_name, key_field,    \</div>
<div class="line">                                         hash, compare, allocate,              \</div>
<div class="line">                                         context_data, capacity)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_aa0ab2a47b824372a9509d90a899f1971"><div class="ttname"><a href="private__flat__hash__map_8h.html#aa0ab2a47b824372a9509d90a899f1971">CCC_private_flat_hash_map_initialize</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_initialize( private_fixed_map_pointer, private_type_name, private_key_field, private_hash, private_key_compare, private_allocate, private_context_data, private_capacity)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:276</div></div>
</div><!-- fragment -->
<p>Initialize a map of types at compile time or runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to a fixed map allocation or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the user defined type stored in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_field</td><td>the field of the struct used for key storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>the CCC_Key_hasher function provided by the user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the CCC_Key_comparator the user intends to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function for resizing or NULL if no resizing is allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>context data that is needed for hashing or comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the capacity of a fixed size map or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the flat hash map directly initialized on the right hand side of the equality operator (i.e. <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> map = <a class="el" href="flat__hash__map_8h.html#a2e5bed49083f78e8f594e5c4c866b306" title="Initialize a map of types at compile time or runtime.">CCC_flat_hash_map_initialize(...)</a>;) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if a dynamic resizing map is required provide NULL as the map_pointer.</dd></dl>
<p>Initialize a static fixed size hash map at compile time that has no allocation permission or context data needed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line">flat_hash_map_declare_fixed(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line"><span class="keyword">static</span> Flat_hash_map static_map = flat_hash_map_initialize(</div>
<div class="line">    &amp;(<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">    <span class="keyword">struct </span>Val,</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    flat_hash_map_fixed_capacity(Small_fixed_map)</div>
<div class="line">);</div>
</div><!-- fragment --><p>Initialize a dynamic hash table at compile time with allocation permission and no context data. Use the same type as the previous example.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> Flat_hash_map static_map = flat_hash_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
</div><!-- fragment --><p>Initialization at runtime is also possible. Stack-based or dynamic maps are identical to the provided examples. Omit <code>static</code> in a runtime context. </p>

</div>
</div>
<a id="a07faeea63df39aefff6b141454356474" name="a07faeea63df39aefff6b141454356474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07faeea63df39aefff6b141454356474">&#9670;&#160;</a></span>CCC_flat_hash_map_insert_entry_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_insert_entry_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__flat__hash__map_8h.html#a1436dc74263c3b59ec9ee1d05dd005c2">CCC_private_flat_hash_map_insert_entry_with</a>(map_entry_pointer,             \</div>
<div class="line">                                                type_compound_literal)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_a1436dc74263c3b59ec9ee1d05dd005c2"><div class="ttname"><a href="private__flat__hash__map_8h.html#a1436dc74263c3b59ec9ee1d05dd005c2">CCC_private_flat_hash_map_insert_entry_with</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_insert_entry_with( Flat_hash_map_entry_pointer, type_compound_literal...)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:481</div></div>
</div><!-- fragment -->
<p>write the contents of the compound literal type_compound_literal to a slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entry_pointer</td><td>a pointer to the obtained entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal to write to a new slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly inserted or overwritten user type. NULL is returned if resizing is required but fails or is not allowed. </dd></dl>

</div>
</div>
<a id="a4ef5fea3c4f141ace47ee8bfca4b2dbe" name="a4ef5fea3c4f141ace47ee8bfca4b2dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef5fea3c4f141ace47ee8bfca4b2dbe">&#9670;&#160;</a></span>CCC_flat_hash_map_insert_or_assign_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_insert_or_assign_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_flat_hash_map_insert_or_assign_with(map_pointer, key,      \</div>
<div class="line">                                                        type_compound_literal) \</div>
<div class="line">    }</div>
<div class="ttc" id="astructCCC__Entry_html"><div class="ttname"><a href="structCCC__Entry.html">CCC_Entry</a></div><div class="ttdef"><b>Definition:</b> private_types.h:53</div></div>
</div><!-- fragment -->
<p>Inserts a new key value pair or overwrites the existing entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key to be searched in the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal specifying the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the entry of the existing or newly inserted value. Occupied indicates the key existed, Vacant indicates the key was absent. Unwrapping in any case provides the current value unless an error occurs that prevents insertion. An insertion error will flag such a case.</dd></dl>
<p>Note that for brevity and convenience the user need not write the key to the lazy value compound literal as well. This function ensures the key in the compound literal matches the searched key. </p>

</div>
</div>
<a id="a602827385a448a0d2b794666a192ba03" name="a602827385a448a0d2b794666a192ba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602827385a448a0d2b794666a192ba03">&#9670;&#160;</a></span>CCC_flat_hash_map_insert_or_assign_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_insert_or_assign_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_flat_hash_map_insert_or_assign(map_pointer, type_pointer).private  \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invariantly inserts or overwrites a user struct into the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_pointer</td><td>the complete key and value type to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the entry. If Occupied an entry was overwritten by the new key value. If Vacant no prior table entry existed.</dd></dl>
<p>Note that this function can be used when the old user type is not needed but the information regarding its presence is helpful. </p>

</div>
</div>
<a id="a615f68baccbd1dcf4df5f6e13cdbd511" name="a615f68baccbd1dcf4df5f6e13cdbd511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615f68baccbd1dcf4df5f6e13cdbd511">&#9670;&#160;</a></span>CCC_flat_hash_map_or_insert_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_or_insert_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__flat__hash__map_8h.html#aec8e8dc2f6fd7574ad3f484cadb1664b">CCC_private_flat_hash_map_or_insert_with</a>(map_entry_pointer,                \</div>
<div class="line">                                             type_compound_literal)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_aec8e8dc2f6fd7574ad3f484cadb1664b"><div class="ttname"><a href="private__flat__hash__map_8h.html#aec8e8dc2f6fd7574ad3f484cadb1664b">CCC_private_flat_hash_map_or_insert_with</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_or_insert_with(Flat_hash_map_entry_pointer, type_compound_literal...)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:449</div></div>
</div><!-- fragment -->
<p>lazily insert the desired key value into the entry if it is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entry_pointer</td><td>a pointer to the obtained entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal to construct in place if the entry is Vacant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the unwrapped user type in the entry, either the unmodified reference if the entry was Occupied or the newly inserted element if the entry was Vacant. NULL is returned if resizing is required but fails or is not allowed.</dd></dl>
<p>Note that if the compound literal uses any function calls to generate values or other data, such functions will not be called if the entry is Occupied. </p>

</div>
</div>
<a id="a76f154fc20d4a033856736b7c31794f2" name="a76f154fc20d4a033856736b7c31794f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f154fc20d4a033856736b7c31794f2">&#9670;&#160;</a></span>CCC_flat_hash_map_remove_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_remove_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_entry_pointer</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_flat_hash_map_remove_entry(map_entry_pointer).private              \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the entry from the table if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entry_pointer</td><td>a pointer to the table entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound liter to an entry containing NULL. If Occupied an entry in the table existed and was removed. If Vacant, no prior entry existed to be removed. </dd></dl>

</div>
</div>
<a id="a9c531aa3bf8c6807a4aa6cd856d05167" name="a9c531aa3bf8c6807a4aa6cd856d05167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c531aa3bf8c6807a4aa6cd856d05167">&#9670;&#160;</a></span>CCC_flat_hash_map_remove_key_value_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_remove_key_value_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_output_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_flat_hash_map_remove_key_value(map_pointer, type_output_pointer)   \</div>
<div class="line">            .private                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Removes the key value in the map storing the old value, if present, in the struct containing out_array_pointer provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output_pointer</td><td>the complete key and value type to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the removed entry. If Occupied it may be unwrapped to obtain the old key value pair. If Vacant the key value pair was not stored in the map. If bad input is provided an input error is set. If a previously stored value is returned it is safe to keep and modify this reference because the data has been written to the provided space.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in an entry to provide information about the old value. </p>

</div>
</div>
<a id="a922b69ba09e22ab0e5783b49e0b7c21c" name="a922b69ba09e22ab0e5783b49e0b7c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922b69ba09e22ab0e5783b49e0b7c21c">&#9670;&#160;</a></span>CCC_flat_hash_map_swap_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_swap_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_flat_hash_map_swap_entry(map_pointer, type_pointer).private        \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invariantly inserts the key value wrapping out_handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_pointer</td><td>the complete key and value type to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to an entry. If Vacant, no prior element with key existed and entry may be unwrapped to view the new insertion in the table. If Occupied the old value is written to type_output and may be unwrapped to view. If more space is needed but allocation fails or has been forbidden, an insert error is set.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in an entry to provide information about the old value. </p>

</div>
</div>
<a id="a918d165b1904c7ee4999a6a4981998da" name="a918d165b1904c7ee4999a6a4981998da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918d165b1904c7ee4999a6a4981998da">&#9670;&#160;</a></span>CCC_flat_hash_map_try_insert_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_try_insert_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_private_flat_hash_map_try_insert_with(map_pointer, key,            \</div>
<div class="line">                                                  type_compound_literal)       \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>lazily insert type_compound_literal into the map at key if key is absent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>a pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the direct key r-value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_compound_literal</td><td>the compound literal specifying the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the entry of the existing or newly inserted value. Occupied indicates the key existed, Vacant indicates the key was absent. Unwrapping in any case provides the current value unless an error occurs that prevents insertion. An insertion error will flag such a case. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ensure the key type matches the type stored in table as your key. For example, if your key is of type <code>int</code> and you pass a <code>size_t</code> variable to the key argument, you will overwrite adjacent bytes of your struct.</dd></dl>
<p>Note that for brevity and convenience the user need not write the key to the lazy value compound literal as well. This function ensures the key in the compound literal matches the searched key. </p>

</div>
</div>
<a id="aa6389376b4967a060710c8acfb84932e" name="aa6389376b4967a060710c8acfb84932e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6389376b4967a060710c8acfb84932e">&#9670;&#160;</a></span>CCC_flat_hash_map_try_insert_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_try_insert_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_struct" href="structCCC__Entry.html">CCC_Entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        CCC_flat_hash_map_try_insert(map_pointer, type_pointer).private        \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Attempts to insert the key value wrapping key_val_array_pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_pointer</td><td>the pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_pointer</td><td>the complete key and value type to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the entry. If Occupied, the entry contains a reference to the key value user type in the table and may be unwrapped. If Vacant the entry contains a reference to the newly inserted entry in the table. If more space is needed but allocation fails or has been forbidden, an insert error is set. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>because this function returns a reference to a user type in the table any subsequent insertions or deletions invalidate this reference. </dd></dl>

</div>
</div>
<a id="a00c20255e47fb5ac259edf75b6d0db77" name="a00c20255e47fb5ac259edf75b6d0db77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c20255e47fb5ac259edf75b6d0db77">&#9670;&#160;</a></span>CCC_flat_hash_map_with_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_with_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__flat__hash__map_8h.html#ab3f2de88ddc0d59eae946c6ec3996d54">CCC_private_flat_hash_map_with_capacity</a>(                                   \</div>
<div class="line">        type_name, key_field, hash, compare, allocate, context_data, capacity)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_ab3f2de88ddc0d59eae946c6ec3996d54"><div class="ttname"><a href="private__flat__hash__map_8h.html#ab3f2de88ddc0d59eae946c6ec3996d54">CCC_private_flat_hash_map_with_capacity</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_with_capacity( private_type_name, private_key_field, private_hash, private_key_compare, private_allocate, private_context_data, private_cap)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:342</div></div>
</div><!-- fragment -->
<p>Initialize a dynamic map at runtime with at least the specified capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the type being stored in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_field</td><td>the field of the struct used for key storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>the CCC_Key_hasher function provided by the user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the CCC_Key_comparator the user intends to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_data</td><td>context data that is needed for hashing or comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the desired capacity for the map. A capacity of 0 results in an argument error and is a no-op after the map is initialized empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the flat hash map directly initialized on the right hand side of the equality operator (i.e. <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> map = <a class="el" href="flat__hash__map_8h.html#a00c20255e47fb5ac259edf75b6d0db77" title="Initialize a dynamic map at runtime with at least the specified capacity.">CCC_flat_hash_map_with_capacity(...)</a>;) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>An allocation function is required. This initializer is only available for dynamic maps. </dd>
<dd>
If initialization fails all subsequent queries, insertions, or removals will indicate the error: either memory related or lack of an allocation function provided.</dd></dl>
<p>Initialize a dynamic hash table at run time. This example requires no context data for initialization.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Flat_hash_map map = flat_hash_map_with_capacity(</div>
<div class="line">        <span class="keyword">struct</span> Val,</div>
<div class="line">        key,</div>
<div class="line">        flat_hash_map_int_to_u64,</div>
<div class="line">        flat_hash_map_key_order,</div>
<div class="line">        std_allocate,</div>
<div class="line">        NULL,</div>
<div class="line">        4096</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Only dynamic maps may be initialized this way as it simply combines the steps of initialization and reservation. </p>

</div>
</div>
<a id="ae1b3b5a76a1fabae8d23ff439f21e9ba" name="ae1b3b5a76a1fabae8d23ff439f21e9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b3b5a76a1fabae8d23ff439f21e9ba">&#9670;&#160;</a></span>CCC_flat_hash_map_with_compound_literal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_with_compound_literal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__flat__hash__map_8h.html#a2911ac34e2614797211af5863dc38311">CCC_private_flat_hash_map_with_compound_literal</a>(key_field, hash, compare,  \</div>
<div class="line">                                                    compound_literal)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_a2911ac34e2614797211af5863dc38311"><div class="ttname"><a href="private__flat__hash__map_8h.html#a2911ac34e2614797211af5863dc38311">CCC_private_flat_hash_map_with_compound_literal</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_with_compound_literal( private_key_field, private_hash, private_key_compare, private_compound_literal)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:357</div></div>
</div><!-- fragment -->
<p>Initialize a fixed map at compile time or runtime from its previously declared type using a compound literal with no allocation permissions or context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_field</td><td>the field of the struct used for key storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>the CCC_Key_hasher function provided by the user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the CCC_Key_comparator the user intends to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal</td><td>the fixed map compound literal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the flat hash map directly initialized on the right hand side of the equality operator (e.g. <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> map = flat_hash_map_with_compound_literal(...);) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>See CCC_flat_hash_map_declare_fixed_map() for how to declare a fixed size map and use its compound literal initializer.</dd></dl>
<p>Initialize a static fixed size hash map at compile time that has no allocation permission or context data needed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line">flat_hash_map_declare_fixed(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line"><span class="keyword">static</span> Flat_hash_map static_map = flat_hash_map_with_compound_literal(</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    (<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">);</div>
</div><!-- fragment --><p>This saves on boilerplate compared to the raw initializer. </p>

</div>
</div>
<a id="a0120e418b0f915afadd09ff18c3663d5" name="a0120e418b0f915afadd09ff18c3663d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0120e418b0f915afadd09ff18c3663d5">&#9670;&#160;</a></span>CCC_flat_hash_map_with_context_compound_literal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_flat_hash_map_with_context_compound_literal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="private__flat__hash__map_8h.html#a27ae1415b6402d738c70af9b5a0987fa">CCC_private_flat_hash_map_with_context_compound_literal</a>(                   \</div>
<div class="line">        key_field, hash, compare, context, compound_literal)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_a27ae1415b6402d738c70af9b5a0987fa"><div class="ttname"><a href="private__flat__hash__map_8h.html#a27ae1415b6402d738c70af9b5a0987fa">CCC_private_flat_hash_map_with_context_compound_literal</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_with_context_compound_literal( private_key_field, private_hash, private_key_compare, private_context, private_compound_literal)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:386</div></div>
</div><!-- fragment -->
<p>Initialize a fixed map at compile time or runtime from its previously declared type using a compound literal with no allocation permissions or context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_field</td><td>the field of the struct used for key storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>the CCC_Key_hasher function provided by the user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>the CCC_Key_comparator the user intends to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>a pointer to any context needed for the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal</td><td>the fixed map compound literal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the flat hash map directly initialized on the right hand side of the equality operator (e.g. <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> map = flat_hash_map_with_context_compound_literal(...);) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>See CCC_flat_hash_map_declare_fixed_map() for how to declare a fixed size map and use its compound literal initializer.</dd></dl>
<p>Initialize a static fixed size hash map at compile time that has no allocation permission or context data needed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line">flat_hash_map_declare_fixed(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line"><span class="keyword">static</span> Flat_hash_map static_map = flat_hash_map_with_context_compound_literal(</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    &amp;module_context,</div>
<div class="line">    (<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">);</div>
</div><!-- fragment --><p>This saves on boilerplate compared to the raw initializer. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a398f6327bbe30ab4faaae91bf3a0f236" name="a398f6327bbe30ab4faaae91bf3a0f236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398f6327bbe30ab4faaae91bf3a0f236">&#9670;&#160;</a></span>CCC_Flat_hash_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container for storing key-value structures defined by the user in a contiguous buffer. </p>
<p>A flat hash map can be initialized on the stack, heap, or data segment at runtime or compile time. </p>

</div>
</div>
<a id="a11c397e5235fefa94bd3b1f3298a1ae0" name="a11c397e5235fefa94bd3b1f3298a1ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c397e5235fefa94bd3b1f3298a1ae0">&#9670;&#160;</a></span>CCC_Flat_hash_map_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionCCC__Flat__hash__map__entry__wrap.html">CCC_Flat_hash_map_entry_wrap</a> <a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container specific entry used to implement the Entry Interface. </p>
<p>The Entry Interface offers efficient search and subsequent insertion, deletion, or value update based on the needs of the user. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6d351f90feedb05cf3f34311f2b62f96" name="a6d351f90feedb05cf3f34311f2b62f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d351f90feedb05cf3f34311f2b62f96">&#9670;&#160;</a></span>CCC_flat_hash_map_and_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> * CCC_flat_hash_map_and_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *&#160;</td>
          <td class="paramname"><em>modify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the provided entry if it is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry obtained from an entry function or macro. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify</td><td>an update function in which the context argument is unused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated entry if it was Occupied or the unmodified vacant entry.</dd></dl>
<p>This function is intended to make the function chaining in the Entry Interface more succinct if the entry will be modified in place based on its own value without the need of the context argument a CCC_Type_modifier can provide. </p>

</div>
</div>
<a id="ab6d84c76e497eee6decb00b81b283c8a" name="ab6d84c76e497eee6decb00b81b283c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d84c76e497eee6decb00b81b283c8a">&#9670;&#160;</a></span>CCC_flat_hash_map_and_modify_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> * CCC_flat_hash_map_and_modify_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#af3851f6fdc1c8255c6b1713c8ffc1bdd">CCC_Type_modifier</a> *&#160;</td>
          <td class="paramname"><em>modify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the provided entry if it is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry obtained from an entry function or macro. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify</td><td>an update function that requires context data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>context data required for the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated entry if it was Occupied or the unmodified vacant entry.</dd></dl>
<p>This function makes full use of a CCC_Type_modifier capability, meaning a complete CCC_update object will be passed to the update function callback. </p>

</div>
</div>
<a id="a23bec1d6ce65ab954db8857bf9dd8566" name="a23bec1d6ce65ab954db8857bf9dd8566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bec1d6ce65ab954db8857bf9dd8566">&#9670;&#160;</a></span>CCC_flat_hash_map_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_flat_hash_map_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a pointer to the first element in the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the table to iterate through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer that can be cast directly to the user type that is stored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>erasing or inserting during iteration may invalidate iterators if resizing occurs which would lead to undefined behavior. O(capacity).</dd></dl>
<p>Iteration starts from index 0 by capacity of the table so iteration order is not obvious to the user, nor should any specific order be relied on. </p>

</div>
</div>
<a id="adba9c0c19b88bd78edaa1aa00645223c" name="adba9c0c19b88bd78edaa1aa00645223c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba9c0c19b88bd78edaa1aa00645223c">&#9670;&#160;</a></span>CCC_flat_hash_map_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_flat_hash_map_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the full capacity of the backing storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity of the map or an argument error is set if map is NULL. </dd></dl>

</div>
</div>
<a id="ae399d874a6bef994e78df9c583ea3a21" name="ae399d874a6bef994e78df9c583ea3a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae399d874a6bef994e78df9c583ea3a21">&#9670;&#160;</a></span>CCC_flat_hash_map_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_flat_hash_map_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the table for use without affecting capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the table to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the table before their slots are forfeit.</td></tr>
  </table>
  </dd>
</dl>
<p>If NULL is passed as the destructor function time is O(1), else O(capacity). </p>

</div>
</div>
<a id="a55900315034b6a09bf6b254e7e29d6a8" name="a55900315034b6a09bf6b254e7e29d6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55900315034b6a09bf6b254e7e29d6a8">&#9670;&#160;</a></span>CCC_flat_hash_map_clear_and_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_flat_hash_map_clear_and_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the table and frees the underlying buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the table to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the table before their slots are forfeit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of free operation. If no allocate function is provided it is an error to attempt to free the Buffer and a memory error is returned. Otherwise, an OK result is returned. </dd></dl>

</div>
</div>
<a id="ab8147a64069ce12361fbd200c1c779db" name="ab8147a64069ce12361fbd200c1c779db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8147a64069ce12361fbd200c1c779db">&#9670;&#160;</a></span>CCC_flat_hash_map_clear_and_free_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_flat_hash_map_clear_and_free_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a93e9728dd87d940e8f171efea75ee8d2">CCC_Type_destructor</a> *&#160;</td>
          <td class="paramname"><em>destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the table and frees the underlying Buffer that was previously dynamically reserved with the reserve function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the table to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the table before their slots are forfeit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function to provide to a dynamically reserved map. Any context data provided upon initialization will be passed to the allocation function when called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of free operation. CCC_RESULT_OK if success, or an error status to indicate the error. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is an error to call this function on a map that was not reserved with the provided CCC_Allocator. The map must have existing memory to free.</dd></dl>
<p>This function covers the edge case of reserving a dynamic capacity for a map at runtime but denying the map allocation permission to resize. This can help prevent a map from growing untree due to internal decisions about rehashes and resizing. The user in this case knows the map does not have allocation permission and therefore no further memory will be dedicated to the map.</p>
<p>However, to free the map in such a case this function must be used because the map has no ability to free itself. Just as the allocation function is required to reserve memory so to is it required to free memory.</p>
<p>This function will work normally if called on a map with allocation permission however the normal CCC_flat_hash_map_clear_and_free is sufficient for that use case. </p>

</div>
</div>
<a id="a6df1e711fb8c15b8161b541a0738256f" name="a6df1e711fb8c15b8161b541a0738256f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df1e711fb8c15b8161b541a0738256f">&#9670;&#160;</a></span>CCC_flat_hash_map_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_flat_hash_map_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the table for the presence of key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the flat hash table to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>pointer to the key matching the key type of the user struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the struct containing key is stored, false if not. Error if map or key is NULL. </dd></dl>

</div>
</div>
<a id="ad50ef270ac4a8e36de917e7eb4244474" name="ad50ef270ac4a8e36de917e7eb4244474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50ef270ac4a8e36de917e7eb4244474">&#9670;&#160;</a></span>CCC_flat_hash_map_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_flat_hash_map_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the map at source to destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>the initialized destination for the copy of the source map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the initialized source of the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the optional allocation function if resizing is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the copy operation. If the destination capacity is less than the source capacity and no allocation function is provided an input error is returned. If resizing is required and resizing of destination fails a memory error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>destination must have capacity greater than or equal to source. If destination capacity is less than source, an allocation function must be provided with the allocate argument.</dd></dl>
<p>Note that there are two ways to copy data from source to destination: provide sufficient memory and pass NULL as allocate, or allow the copy function to take care of allocation for the copy.</p>
<p>Manual memory management with no allocation function provided.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line">flat_hash_map_declare_fixed(Small_fixed_map, <span class="keyword">struct</span> Val, 64);</div>
<div class="line">Flat_hash_map source = flat_hash_map_initialize(</div>
<div class="line">    &amp;(<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">    <span class="keyword">struct </span>Val,</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    <a class="code hl_define" href="flat__hash__map_8h.html#a3dac035c65b826f4f9ac3b269c395ba2">CCC_flat_hash_map_fixed_capacity</a>(Small_fixed_map)</div>
<div class="line">);</div>
<div class="line">insert_rand_vals(&amp;source);</div>
<div class="line">Flat_hash_map destination = flat_hash_map_initialize(</div>
<div class="line">    &amp;(<span class="keyword">static</span> Small_fixed_map){},</div>
<div class="line">    <span class="keyword">struct </span>Val,</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    <a class="code hl_define" href="flat__hash__map_8h.html#a3dac035c65b826f4f9ac3b269c395ba2">CCC_flat_hash_map_fixed_capacity</a>(Small_fixed_map)</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = flat_hash_map_copy(&amp;destination, &amp;source, NULL);</div>
<div class="ttc" id="aflat__hash__map_8h_html_a3dac035c65b826f4f9ac3b269c395ba2"><div class="ttname"><a href="flat__hash__map_8h.html#a3dac035c65b826f4f9ac3b269c395ba2">CCC_flat_hash_map_fixed_capacity</a></div><div class="ttdeci">#define CCC_flat_hash_map_fixed_capacity(fixed_map_type_name)</div><div class="ttdoc">Obtain the capacity previously chosen for the fixed size map type.</div><div class="ttdef"><b>Definition:</b> flat_hash_map.h:199</div></div>
<div class="ttc" id="atypes_8h_html_aa1ded61d294b114942f11e711b331dcf"><div class="ttname"><a href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a></div><div class="ttdeci">CCC_Result</div><div class="ttdoc">A result of actions on containers.</div><div class="ttdef"><b>Definition:</b> types.h:148</div></div>
</div><!-- fragment --><p>The above requires destination capacity be greater than or equal to source capacity. Here is memory management handed over to the copy function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line">Flat_hash_map source = flat_hash_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line">insert_rand_vals(&amp;source);</div>
<div class="line">Flat_hash_map destination = flat_hash_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = flat_hash_map_copy(&amp;destination, &amp;source, std_allocate);</div>
</div><!-- fragment --><p>The above allows destination to have a capacity less than that of the source as long as copy has been provided an allocation function to resize destination. Note that this would still work if copying to a destination that the user wants as a fixed size map.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLAT_HASH_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>Val</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line">Flat_hash_map source = flat_hash_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line">insert_rand_vals(&amp;source);</div>
<div class="line">Flat_hash_map destination = flat_hash_map_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    <span class="keyword">struct</span> Val,</div>
<div class="line">    key,</div>
<div class="line">    flat_hash_map_int_to_u64,</div>
<div class="line">    flat_hash_map_key_order,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = flat_hash_map_copy(&amp;destination, &amp;source, std_allocate);</div>
</div><!-- fragment --><p>The above sets up destination with fixed size while source is a dynamic map. Because an allocation function is provided, the destination is resized once for the copy and retains its fixed size after the copy is complete. This would require the user to manually free the underlying Buffer at destination eventually if this method is used. Usually it is better to allocate the memory with the reserve function if maps with one-time allocation requirements are used.</p>
<p>These options allow users to stay consistent across containers with their memory management strategies. </p>

</div>
</div>
<a id="ae3166cb826dc03993f39ea9de3e490bf" name="ae3166cb826dc03993f39ea9de3e490bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3166cb826dc03993f39ea9de3e490bf">&#9670;&#160;</a></span>CCC_flat_hash_map_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_flat_hash_map_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the count of table occupied slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the map or an argument error is set if map is NULL. </dd></dl>

</div>
</div>
<a id="a266b35d8720080987dc2a425d28f5bd6" name="a266b35d8720080987dc2a425d28f5bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266b35d8720080987dc2a425d28f5bd6">&#9670;&#160;</a></span>CCC_flat_hash_map_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_flat_hash_map_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the current iterator against the end for loop termination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the table being iterated upon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end address of the hash table. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is undefined behavior to access or modify the end address. </dd></dl>

</div>
</div>
<a id="ace45b100db6fc706ad198de15f8daa5b" name="ace45b100db6fc706ad198de15f8daa5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace45b100db6fc706ad198de15f8daa5b">&#9670;&#160;</a></span>CCC_flat_hash_map_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> CCC_flat_hash_map_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains an entry for the provided key in the table for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the hash table to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key used to search the table matching the stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a specialized hash entry for use with other functions in the Entry Interface. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the contents of an entry should not be examined or modified. Use the provided functions, only.</dd></dl>
<p>An entry is a search result that provides either an Occupied or Vacant entry in the table. An occupied entry signifies that the search was successful. A Vacant entry means the search was not successful but we now have a handle to where in the table such an element should be inserted.</p>
<p>An entry is rarely useful on its own. It should be passed in a functional style to subsequent calls in the Entry Interface. </p>

</div>
</div>
<a id="a21fd776da1bab29f83e4c3e18d2b70f4" name="a21fd776da1bab29f83e4c3e18d2b70f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fd776da1bab29f83e4c3e18d2b70f4">&#9670;&#160;</a></span>CCC_flat_hash_map_entry_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCC_Entry_status CCC_flat_hash_map_entry_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the entry status from a container entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>a pointer to the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the status stored in the entry after the required action on the container completes. If entry is NULL an entry input error is returned so ensure e is non-NULL to avoid an inaccurate status returned.</dd></dl>
<p>Note that this function can be useful for debugging or if more detailed messages are needed for logging purposes. See <a class="el" href="types_8h.html#ad07b2e77418d28789f9eb6723d2b59b7" title="Obtain a string message with a description of the entry status.">CCC_entry_status_message()</a> in <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">ccc/types.h</a> for more information on detailed entry statuses. </p>

</div>
</div>
<a id="a175e53430218da00b10893523af8ed84" name="a175e53430218da00b10893523af8ed84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175e53430218da00b10893523af8ed84">&#9670;&#160;</a></span>CCC_flat_hash_map_get_key_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_flat_hash_map_get_key_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference into the table at entry key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the flat hash map to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key to search matching stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the table entry if it is present, else NULL. </dd></dl>

</div>
</div>
<a id="a895708750e9e898587ff49ee93c39533" name="a895708750e9e898587ff49ee93c39533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895708750e9e898587ff49ee93c39533">&#9670;&#160;</a></span>CCC_flat_hash_map_insert_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_flat_hash_map_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the provided entry invariantly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry returned from a call obtaining an entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the complete key and value type to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inserted element or NULL upon a memory error in which the load factor would be exceeded when no allocation policy is defined or resizing failed to find more memory.</dd></dl>
<p>This method can be used when the old value in the table does not need to be preserved. See the regular insert method if the old value is of interest. If an error occurs during the insertion process due to memory limitations or a search error NULL is returned. Otherwise insertion should not fail. </p>

</div>
</div>
<a id="aed7f98e257c4b9cfb7d4c673d1b532cd" name="aed7f98e257c4b9cfb7d4c673d1b532cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7f98e257c4b9cfb7d4c673d1b532cd">&#9670;&#160;</a></span>CCC_flat_hash_map_insert_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_flat_hash_map_insert_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the status of the entry should an insertion follow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry from a query to the table via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the next insertion of a new element will cause an error. Error if entry is null.</dd></dl>
<p>Table resizing occurs upon calls to entry functions/macros or when trying to insert a new element directly. This is to provide stable entries from the time they are obtained to the time they are used in functions they are passed to (i.e. the idiomatic or_insert(entry(...)...)).</p>
<p>However, if a Vacant entry is returned and then a subsequent insertion function is used, it will not work if resizing has failed and the return of those functions will indicate such a failure. One can also confirm an insertion error will occur from an entry with this function. For example, leaving this function in an assert for debug builds can be a helpful sanity check. </p>

</div>
</div>
<a id="a198b193f16959066927c9b1094634edc" name="a198b193f16959066927c9b1094634edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198b193f16959066927c9b1094634edc">&#9670;&#160;</a></span>CCC_flat_hash_map_insert_or_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_flat_hash_map_insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts or overwrites a user struct into the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the complete key and value type to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry. If Occupied an entry was overwritten by the new key value. If Vacant no prior table entry existed.</dd></dl>
<p>Note that this function can be used when the old user type is not needed but the information regarding its presence is helpful. </p>

</div>
</div>
<a id="a455d9054ddad4b936f289bef42edf4cf" name="a455d9054ddad4b936f289bef42edf4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455d9054ddad4b936f289bef42edf4cf">&#9670;&#160;</a></span>CCC_flat_hash_map_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_flat_hash_map_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size status of the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty else false. Error if map is NULL. </dd></dl>

</div>
</div>
<a id="a3e93354bc99ffc6e01a35ef3843fd353" name="a3e93354bc99ffc6e01a35ef3843fd353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e93354bc99ffc6e01a35ef3843fd353">&#9670;&#160;</a></span>CCC_flat_hash_map_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_flat_hash_map_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the iterator to the next occupied table slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the table being iterated upon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_iterator</td><td>the previous iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer that can be cast directly to the user type that is stored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>erasing or inserting during iteration may invalidate iterators if resizing occurs which would lead to undefined behavior. O(capacity). </dd></dl>

</div>
</div>
<a id="ada62e76725801241b7b0e19a755bd281" name="ada62e76725801241b7b0e19a755bd281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada62e76725801241b7b0e19a755bd281">&#9670;&#160;</a></span>CCC_flat_hash_map_occupied()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_flat_hash_map_occupied </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Vacant or Occupied status of the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry from a query to the table via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry is occupied, false if not. Error if entry is NULL. </dd></dl>

</div>
</div>
<a id="a42a400f6483457e2b3c311aeb7b04ef1" name="a42a400f6483457e2b3c311aeb7b04ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a400f6483457e2b3c311aeb7b04ef1">&#9670;&#160;</a></span>CCC_flat_hash_map_or_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_flat_hash_map_or_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the struct with handle elem if the entry is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry obtained via function or macro call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the complete key and value type to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to entry in the table invariantly. NULL on error.</dd></dl>
<p>Because this functions takes an entry and inserts if it is Vacant, the only reason NULL shall be returned is when an insertion error will occur, usually due to a resizing memory error. This can happen if the table is not allowed to resize because no allocation function is provided. </p>

</div>
</div>
<a id="a1005ae1299c0d326c8e7f078c42a3d03" name="a1005ae1299c0d326c8e7f078c42a3d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1005ae1299c0d326c8e7f078c42a3d03">&#9670;&#160;</a></span>CCC_flat_hash_map_remove_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_flat_hash_map_remove_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the entry from the table if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>a pointer to the table entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry containing NULL. If Occupied an entry in the table existed and was removed. If Vacant, no prior entry existed to be removed. </dd></dl>

</div>
</div>
<a id="a2413cd3ecd081b5374bfd38210b52e13" name="a2413cd3ecd081b5374bfd38210b52e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2413cd3ecd081b5374bfd38210b52e13">&#9670;&#160;</a></span>CCC_flat_hash_map_remove_key_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_flat_hash_map_remove_key_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>type_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the key value in the map storing the old value, if present, in the struct containing out_handle provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output</td><td>the complete key and value type to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed entry. If Occupied it may be unwrapped to obtain the old key value pair. If Vacant the key value pair was not stored in the map. If bad input is provided an input error is set. If a previously stored value is returned it is safe to keep and modify this reference because the data has been written to the provided space.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in an entry to provide information about the old value. </p>

</div>
</div>
<a id="abde2c0903a9cb74a55ae6e22b58d0c80" name="abde2c0903a9cb74a55ae6e22b58d0c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde2c0903a9cb74a55ae6e22b58d0c80">&#9670;&#160;</a></span>CCC_flat_hash_map_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_flat_hash_map_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve space required to add a specified number of elements to the map. If the current capacity is sufficient, do nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>a pointer to the hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_add</td><td>the number of elements to add to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function that can be used for resizing. Such a function is provided to cover the case where the user wants a fixed size map but cannot know the size needed until runtime. In this case, the function needs to be provided to allow the single resizing to occur. Any context data provided upon initialization will be passed to the allocation function when called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the reserving operation, OK if successful or an error code to indicate the specific failure.</dd></dl>
<p>If the map has already been initialized with allocation permission simply provide the same function that was passed upon initialization. </p>

</div>
</div>
<a id="a4affd82b919c9df2a4da1a6823211c4f" name="a4affd82b919c9df2a4da1a6823211c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4affd82b919c9df2a4da1a6823211c4f">&#9670;&#160;</a></span>CCC_flat_hash_map_swap_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_flat_hash_map_swap_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>type_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts the key value wrapping out_handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_output</td><td>the complete key and value type to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry. If Vacant, no prior element with key existed and entry may be unwrapped to view the new insertion in the table. If Occupied the old value is written to type_output and may be unwrapped to view. If more space is needed but allocation fails or has been forbidden, an insert error is set.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in an entry to provide information about the old value. </p>

</div>
</div>
<a id="aff5322c01375471a6312397f436ce223" name="aff5322c01375471a6312397f436ce223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5322c01375471a6312397f436ce223">&#9670;&#160;</a></span>CCC_flat_hash_map_try_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Entry.html">CCC_Entry</a> CCC_flat_hash_map_try_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert the key value wrapping key_val_handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the pointer to the flat hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the complete key and value type to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry. If Occupied, the entry contains a reference to the key value user type in the table and may be unwrapped. If Vacant the entry contains a reference to the newly inserted entry in the table. If more space is needed but allocation fails or has been forbidden, an insert error is set. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>because this function returns a reference to a user type in the table any subsequent insertions or deletions invalidate this reference. </dd></dl>

</div>
</div>
<a id="a953016c4c7d20e30cd5f5c45a35953f5" name="a953016c4c7d20e30cd5f5c45a35953f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953016c4c7d20e30cd5f5c45a35953f5">&#9670;&#160;</a></span>CCC_flat_hash_map_unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_flat_hash_map_unwrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwraps the provided entry to obtain a view into the table element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry from a query to the table via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an view into the table entry if one is present, or NULL. </dd></dl>

</div>
</div>
<a id="a586d10ff39909b2b1a50f2ce25b63df8" name="a586d10ff39909b2b1a50f2ce25b63df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586d10ff39909b2b1a50f2ce25b63df8">&#9670;&#160;</a></span>CCC_flat_hash_map_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_flat_hash_map_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validation of invariants for the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the table to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all invariants hold, false if corruption occurs. Error if map is NULL. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="flat__hash__map_8h.html">flat_hash_map.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
