<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/private/private_flat_hash_map.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('private__flat__hash__map_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">private_flat_hash_map.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Private Flat Hash Map Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="types_8h_source.html">../types.h</a>&quot;</code><br />
<code>#include &quot;private_types.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for private_flat_hash_map.h:</div>
<div class="dyncontent">
<div class="center"><img src="private__flat__hash__map_8h__incl.png" border="0" usemap="#accc_2private_2private__flat__hash__map_8h" alt=""/></div>
<map name="accc_2private_2private__flat__hash__map_8h" id="accc_2private_2private__flat__hash__map_8h">
<area shape="rect" title="Private Flat Hash Map Interface." alt="" coords="21,5,163,45"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="12,93,95,119"/>
<area shape="rect" href="private__types_8h_source.html" title=" " alt="" coords="5,167,179,192"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="private__flat__hash__map_8h__dep__incl.png" border="0" usemap="#accc_2private_2private__flat__hash__map_8hdep" alt=""/></div>
<map name="accc_2private_2private__flat__hash__map_8hdep" id="accc_2private_2private__flat__hash__map_8hdep">
<area shape="rect" title="Private Flat Hash Map Interface." alt="" coords="11,5,154,45"/>
<area shape="rect" href="flat__hash__map_8h.html" title="The Flat Hash Map Interface." alt="" coords="5,93,160,119"/>
<area shape="rect" href="private__traits_8h_source.html" title=" " alt="" coords="11,167,154,207"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="36,255,129,280"/>
</map>
</div>
</div>
<p><a href="private__flat__hash__map_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private Flat Hash Map Interface. </p>
<p>This flat hash map is a C Container Collection friendly interpretation of the Rust Hashbrown hash table. This in turn is based on the Abseil flat hash table from Google in C++. I simplified and modified the implementation for maximum readability in one header and one file. Tracking how to manage different platform implementations of groups and metadata fingerprint masks should be much easier this way, rather than jumping across countless small implementation files.</p>
<p>One key feature that is rigorously tested via static asserts is the ability to create a static data segment or stack based map. This is a key feature of the implementation but it requires significant set up ahead of time and lazy initialization support. The lazy initialization presents the map with the most complexity in the implementation. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCCC__Flat__hash__map__tag.html">CCC_Flat_hash_map_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionCCC__Flat__hash__map__entry__wrap.html">CCC_Flat_hash_map_entry_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7f215d31f7f1462b94588f9993544d7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#a7f215d31f7f1462b94588f9993544d7d">CCC_private_flat_hash_map_declare_fixed_map</a>( fixed_map_type_name,  key_val_type_name,  capacity)</td></tr>
<tr class="separator:a7f215d31f7f1462b94588f9993544d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4ac419bacd4c7cf728b5a56b99214a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#acb4ac419bacd4c7cf728b5a56b99214a">CCC_private_flat_hash_map_fixed_capacity</a>(fixed_map_type_name)&#160;&#160;&#160;    (sizeof((fixed_map_type_name){}.tag) - <a class="el" href="private__flat__hash__map_8h.html#ad75883004f3959ffc98ae1b4ff009199">CCC_FLAT_HASH_MAP_GROUP_COUNT</a>)</td></tr>
<tr class="separator:acb4ac419bacd4c7cf728b5a56b99214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ab2a47b824372a9509d90a899f1971"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#aa0ab2a47b824372a9509d90a899f1971">CCC_private_flat_hash_map_initialize</a>( private_fixed_map_pointer,  private_type_name,  private_key_field,  private_hash,  private_key_compare,  private_allocate,  private_context_data,  private_capacity)</td></tr>
<tr class="separator:aa0ab2a47b824372a9509d90a899f1971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaed8a23b1f4548ee47392c0dd3727db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#aaaed8a23b1f4548ee47392c0dd3727db">CCC_private_flat_hash_map_from</a>( private_key_field,  private_hash,  private_key_compare,  private_allocate,  private_context_data,  private_optional_cap,  private_array_compound_literal...)</td></tr>
<tr class="separator:aaaed8a23b1f4548ee47392c0dd3727db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f2de88ddc0d59eae946c6ec3996d54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#ab3f2de88ddc0d59eae946c6ec3996d54">CCC_private_flat_hash_map_with_capacity</a>( private_type_name,  private_key_field,  private_hash,  private_key_compare,  private_allocate,  private_context_data,  private_cap)</td></tr>
<tr class="separator:ab3f2de88ddc0d59eae946c6ec3996d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6332ccc161afcb1c5154d1e60f595c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#a4b6332ccc161afcb1c5154d1e60f595c">CCC_private_flat_hash_map_and_modify_with</a>( Flat_hash_map_entry_pointer,  type_name,  closure_over_T...)</td></tr>
<tr class="separator:a4b6332ccc161afcb1c5154d1e60f595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8e8dc2f6fd7574ad3f484cadb1664b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#aec8e8dc2f6fd7574ad3f484cadb1664b">CCC_private_flat_hash_map_or_insert_with</a>(Flat_hash_map_entry_pointer,  type_compound_literal...)</td></tr>
<tr class="separator:aec8e8dc2f6fd7574ad3f484cadb1664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1436dc74263c3b59ec9ee1d05dd005c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#a1436dc74263c3b59ec9ee1d05dd005c2">CCC_private_flat_hash_map_insert_entry_with</a>( Flat_hash_map_entry_pointer,  type_compound_literal...)</td></tr>
<tr class="separator:a1436dc74263c3b59ec9ee1d05dd005c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6192df10948a8c7d1a953bb9129b5a39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#a6192df10948a8c7d1a953bb9129b5a39">CCC_private_flat_hash_map_try_insert_with</a>(flat_hash_map_pointer,  key,  type_compound_literal...)</td></tr>
<tr class="separator:a6192df10948a8c7d1a953bb9129b5a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0bb89a9e79d518c1bbd4529a320451"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#a9b0bb89a9e79d518c1bbd4529a320451">CCC_private_flat_hash_map_insert_or_assign_with</a>( flat_hash_map_pointer,  key,  type_compound_literal...)</td></tr>
<tr class="separator:a9b0bb89a9e79d518c1bbd4529a320451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7896f889fcae9a565fd28b00cc87c5ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: typeof((struct CCC_Flat_hash_map_tag) </td></tr>
<tr class="separator:a7896f889fcae9a565fd28b00cc87c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8cb9715bc1ea20cc3533596f823cbd72"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#a8cb9715bc1ea20cc3533596f823cbd72">CCC_private_flat_hash_map_entry</a> (struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *, void const *)</td></tr>
<tr class="separator:a8cb9715bc1ea20cc3533596f823cbd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8e7824940f5cdcd82e2836c09d5618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#a3c8e7824940f5cdcd82e2836c09d5618">CCC_private_flat_hash_map_insert</a> (struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *, void const *, struct <a class="el" href="structCCC__Flat__hash__map__tag.html">CCC_Flat_hash_map_tag</a>, size_t)</td></tr>
<tr class="separator:a3c8e7824940f5cdcd82e2836c09d5618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb24a95ef43efc69f6262918563cc9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#a1eb24a95ef43efc69f6262918563cc9a">CCC_private_flat_hash_map_erase</a> (struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *, size_t)</td></tr>
<tr class="separator:a1eb24a95ef43efc69f6262918563cc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4a10c1784d6e91e8df547cf0479386"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#aad4a10c1784d6e91e8df547cf0479386">CCC_private_flat_hash_map_data_at</a> (struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *, size_t)</td></tr>
<tr class="separator:aad4a10c1784d6e91e8df547cf0479386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf94387ff07081727cf9455e40fb0348"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#abf94387ff07081727cf9455e40fb0348">CCC_private_flat_hash_map_key_at</a> (struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *, size_t)</td></tr>
<tr class="separator:abf94387ff07081727cf9455e40fb0348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21f0abc14cb14877203b61442311216"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#ad21f0abc14cb14877203b61442311216">CCC_private_flat_hash_map_set_insert</a> (struct <a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *)</td></tr>
<tr class="separator:ad21f0abc14cb14877203b61442311216"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad75883004f3959ffc98ae1b4ff009199"><td class="memItemLeft" align="right" valign="top">enum  { ... } &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="private__flat__hash__map_8h.html#ad75883004f3959ffc98ae1b4ff009199">CCC_FLAT_HASH_MAP_GROUP_COUNT</a> = 8</td></tr>
<tr class="separator:ad75883004f3959ffc98ae1b4ff009199"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a4b6332ccc161afcb1c5154d1e60f595c" name="a4b6332ccc161afcb1c5154d1e60f595c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6332ccc161afcb1c5154d1e60f595c">&#9670;&#160;</a></span>CCC_private_flat_hash_map_and_modify_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_and_modify_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Flat_hash_map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">closure_over_T...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (__extension__({                                                           \</div>
<div class="line">        __auto_type private_flat_hash_map_mod_ent_pointer                      \</div>
<div class="line">            = (Flat_hash_map_entry_pointer);                                   \</div>
<div class="line">        <span class="keyword">struct </span><a class="code hl_struct" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> private_flat_hash_map_mod_with_ent      \</div>
<div class="line">            = {.<a class="code hl_variable" href="structCCC__Flat__hash__map__entry.html#a80396e751aa2f5b4ed6719178fb336b5">status</a> = CCC_ENTRY_ARGUMENT_ERROR};                            \</div>
<div class="line">        if (private_flat_hash_map_mod_ent_pointer)                             \</div>
<div class="line">        {                                                                      \</div>
<div class="line">            private_flat_hash_map_mod_with_ent                                 \</div>
<div class="line">                = private_flat_hash_map_mod_ent_pointer-&gt;private;              \</div>
<div class="line">            if (private_flat_hash_map_mod_with_ent.<a class="code hl_variable" href="structCCC__Flat__hash__map__entry.html#a80396e751aa2f5b4ed6719178fb336b5">status</a>                      \</div>
<div class="line">                &amp; CCC_ENTRY_OCCUPIED)                                          \</div>
<div class="line">            {                                                                  \</div>
<div class="line">                type_name *<span class="keyword">const</span> T = <a class="code hl_function" href="private__flat__hash__map_8h.html#aad4a10c1784d6e91e8df547cf0479386">CCC_private_flat_hash_map_data_at</a>(        \</div>
<div class="line">                    private_flat_hash_map_mod_with_ent.<a class="code hl_variable" href="structCCC__Flat__hash__map__entry.html#af4888e7d3af9ce175621ee87fccb63c7">map</a>,                    \</div>
<div class="line">                    private_flat_hash_map_mod_with_ent.<a class="code hl_variable" href="structCCC__Flat__hash__map__entry.html#a20f3bf7ba3ce45849f403d80fe004ba2">index</a>);                 \</div>
<div class="line">                if (T)                                                         \</div>
<div class="line">                {                                                              \</div>
<div class="line">                    closure_over_T                                             \</div>
<div class="line">                }                                                              \</div>
<div class="line">            }                                                                  \</div>
<div class="line">        }                                                                      \</div>
<div class="line">        private_flat_hash_map_mod_with_ent;                                    \</div>
<div class="line">    }))</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_aad4a10c1784d6e91e8df547cf0479386"><div class="ttname"><a href="private__flat__hash__map_8h.html#aad4a10c1784d6e91e8df547cf0479386">CCC_private_flat_hash_map_data_at</a></div><div class="ttdeci">void * CCC_private_flat_hash_map_data_at(struct CCC_Flat_hash_map const *, size_t)</div></div>
<div class="ttc" id="astructCCC__Flat__hash__map__entry_html"><div class="ttname"><a href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a></div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:170</div></div>
<div class="ttc" id="astructCCC__Flat__hash__map__entry_html_a20f3bf7ba3ce45849f403d80fe004ba2"><div class="ttname"><a href="structCCC__Flat__hash__map__entry.html#a20f3bf7ba3ce45849f403d80fe004ba2">CCC_Flat_hash_map_entry::index</a></div><div class="ttdeci">size_t index</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:174</div></div>
<div class="ttc" id="astructCCC__Flat__hash__map__entry_html_a80396e751aa2f5b4ed6719178fb336b5"><div class="ttname"><a href="structCCC__Flat__hash__map__entry.html#a80396e751aa2f5b4ed6719178fb336b5">CCC_Flat_hash_map_entry::status</a></div><div class="ttdeci">enum CCC_Entry_status status</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:178</div></div>
<div class="ttc" id="astructCCC__Flat__hash__map__entry_html_af4888e7d3af9ce175621ee87fccb63c7"><div class="ttname"><a href="structCCC__Flat__hash__map__entry.html#af4888e7d3af9ce175621ee87fccb63c7">CCC_Flat_hash_map_entry::map</a></div><div class="ttdeci">struct CCC_Flat_hash_map * map</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:172</div></div>
</div><!-- fragment --><p>A fairly good approximation of closures given C23 capabilities. The user facing docs clarify that T is a correctly typed reference to the desired data if occupied. </p>

</div>
</div>
<a id="a7f215d31f7f1462b94588f9993544d7d" name="a7f215d31f7f1462b94588f9993544d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f215d31f7f1462b94588f9993544d7d">&#9670;&#160;</a></span>CCC_private_flat_hash_map_declare_fixed_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_declare_fixed_map</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fixed_map_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_val_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static_assert</span>((capacity) &gt; 0,                                              \</div>
<div class="line">                  <span class="stringliteral">&quot;fixed size map must have capacity greater than 0&quot;</span>);         \</div>
<div class="line">    static_assert(                                                             \</div>
<div class="line">        (capacity) &gt;= <a class="code hl_variable" href="private__flat__hash__map_8h.html#ad75883004f3959ffc98ae1b4ff009199">CCC_FLAT_HASH_MAP_GROUP_COUNT</a>,                           \</div>
<div class="line">        <span class="stringliteral">&quot;fixed size map must have capacity &gt;= CCC_FLAT_HASH_MAP_GROUP_COUNT &quot;</span>  \</div>
<div class="line">        <span class="stringliteral">&quot;(8 or 16 depending on platform)&quot;</span>);                                    \</div>
<div class="line">    static_assert(((capacity) &amp; ((capacity) - 1)) == 0,                        \</div>
<div class="line">                  <span class="stringliteral">&quot;fixed size map must be a power of 2 capacity (32, 64, &quot;</span>     \</div>
<div class="line">                  <span class="stringliteral">&quot;128, 256, etc.)&quot;</span>);                                          \</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                             </span>\</div>
<div class="line">    {                                                                          \</div>
<div class="line">        key_val_type_name data[(capacity) + 1];                                \</div>
<div class="line">        alignas(<a class="code hl_variable" href="private__flat__hash__map_8h.html#ad75883004f3959ffc98ae1b4ff009199">CCC_FLAT_HASH_MAP_GROUP_COUNT</a>) <span class="keyword">struct </span><a class="code hl_struct" href="structCCC__Flat__hash__map__tag.html">CCC_Flat_hash_map_tag</a>    \</div>
<div class="line">            tag[(capacity) + <a class="code hl_variable" href="private__flat__hash__map_8h.html#ad75883004f3959ffc98ae1b4ff009199">CCC_FLAT_HASH_MAP_GROUP_COUNT</a>];                   \</div>
<div class="line">    }(fixed_map_type_name)</div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_ad75883004f3959ffc98ae1b4ff009199"><div class="ttname"><a href="private__flat__hash__map_8h.html#ad75883004f3959ffc98ae1b4ff009199">CCC_FLAT_HASH_MAP_GROUP_COUNT</a></div><div class="ttdeci">enum @6 CCC_FLAT_HASH_MAP_GROUP_COUNT</div></div>
<div class="ttc" id="astructCCC__Flat__hash__map__tag_html"><div class="ttname"><a href="structCCC__Flat__hash__map__tag.html">CCC_Flat_hash_map_tag</a></div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:81</div></div>
</div><!-- fragment --><p>Helps the user declare a type for a fixed size map. They can then use this type when they want a hash map as global, static global, or stack local. They would need to define their fixed size type every time but that should be fine as they are likely to only declare one or two. They would likely only have a one fixed size map per translation unit if they are using these capabilities. They control the name of the type so they can organize types as they wish.</p>
<p>The declaration specifies that we have one extra data slot for swapping during in place rehashing and some interface functions and an extra duplicate group of tags at the end of the tag array for safer group loading.</p>
<p>Finally, we must align the tag array to start on an aligned group size byte boundary to be able to perform aligned loads and stores. </p>

</div>
</div>
<a id="acb4ac419bacd4c7cf728b5a56b99214a" name="acb4ac419bacd4c7cf728b5a56b99214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4ac419bacd4c7cf728b5a56b99214a">&#9670;&#160;</a></span>CCC_private_flat_hash_map_fixed_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_fixed_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fixed_map_type_name</td><td>)</td>
          <td>&#160;&#160;&#160;    (sizeof((fixed_map_type_name){}.tag) - <a class="el" href="private__flat__hash__map_8h.html#ad75883004f3959ffc98ae1b4ff009199">CCC_FLAT_HASH_MAP_GROUP_COUNT</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the user does not want to remember the capacity they chose for their type or make mistakes this macro offers consistent calculation of total capacity (aka buckets) of the map. This is not the capacity that is limited by load factor.</p>
<p>The sizeof operator does not decay to a simple pointer here because the tag array of a fixed type has a length known at compile time. Also the tag array is simple byte sized chunks so no division needed. See earlier static asserts for how we ensure no fixed size type is allowed to be defined in a way to make this call unsafe. </p>

</div>
</div>
<a id="aaaed8a23b1f4548ee47392c0dd3727db" name="aaaed8a23b1f4548ee47392c0dd3727db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaed8a23b1f4548ee47392c0dd3727db">&#9670;&#160;</a></span>CCC_private_flat_hash_map_from</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_from</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_hash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_key_compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_optional_cap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_array_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize dynamic container with a compound literal array. </p>

</div>
</div>
<a id="aa0ab2a47b824372a9509d90a899f1971" name="aa0ab2a47b824372a9509d90a899f1971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ab2a47b824372a9509d90a899f1971">&#9670;&#160;</a></span>CCC_private_flat_hash_map_initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_initialize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_fixed_map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_hash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_key_compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                                                                          \</div>
<div class="line">        .data = (private_fixed_map_pointer),                                   \</div>
<div class="line">        .tag = NULL,                                                           \</div>
<div class="line">        .count = 0,                                                            \</div>
<div class="line">        .remain = (((private_capacity) / (<span class="keywordtype">size_t</span>)8) * (size_t)7),              \</div>
<div class="line">        .mask                                                                  \</div>
<div class="line">        = (((private_capacity) &gt; (<span class="keywordtype">size_t</span>)0) ? ((private_capacity) - (size_t)1) \</div>
<div class="line">                                            : (size_t)0),                      \</div>
<div class="line">        .sizeof_type = <span class="keyword">sizeof</span>(private_type_name),                              \</div>
<div class="line">        .key_offset = offsetof(private_type_name, private_key_field),          \</div>
<div class="line">        .compare = (private_key_compare),                                      \</div>
<div class="line">        .hash = (private_hash),                                                \</div>
<div class="line">        .allocate = (private_allocate),                                        \</div>
<div class="line">        .context = (private_context_data),                                     \</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Initialization is tricky but we simplify by only accepting a pointer to the map this pointer could be any of the following. </p><pre class="fragment">- The address of a user defined fixed size map stored in data segment.
- The address of a user defined fixed size map stored on the stack.
- The address of a user defined fixed size map allocated on the heap.
- NULL if the user intends for a dynamic map.
</pre><p> All of the above cases are covered by accepting the pointer at .data and only evaluating the argument once. This also allows the user to pass a compound literal to the first argument and eliminate any dangling references, such as <code>&amp;(static user_defined_map_type){}</code>. However, to accept a map from all of these sources at compile or runtime, we must implement lazy initialization. This is because we can't initialize the tag array at compile time. By setting the tag field to NULL we will be able to tell if our map is initialized whether it is fixed size and has data or is dynamic and has not yet been given allocation. </p>

</div>
</div>
<a id="a1436dc74263c3b59ec9ee1d05dd005c2" name="a1436dc74263c3b59ec9ee1d05dd005c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1436dc74263c3b59ec9ee1d05dd005c2">&#9670;&#160;</a></span>CCC_private_flat_hash_map_insert_entry_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_insert_entry_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Flat_hash_map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (__extension__({                                                           \</div>
<div class="line">        __auto_type private_flat_hash_map_ins_ent_pointer                      \</div>
<div class="line">            = (Flat_hash_map_entry_pointer);                                   \</div>
<div class="line">        typeof(type_compound_literal) *private_flat_hash_map_ins_ent_res       \</div>
<div class="line">            = NULL;                                                            \</div>
<div class="line">        if (private_flat_hash_map_ins_ent_pointer)                             \</div>
<div class="line">        {                                                                      \</div>
<div class="line">            if (!(private_flat_hash_map_ins_ent_pointer-&gt;private.status        \</div>
<div class="line">                  &amp; CCC_ENTRY_INSERT_ERROR))                                   \</div>
<div class="line">            {                                                                  \</div>
<div class="line">                private_flat_hash_map_ins_ent_res                              \</div>
<div class="line">                    = <a class="code hl_function" href="private__flat__hash__map_8h.html#aad4a10c1784d6e91e8df547cf0479386">CCC_private_flat_hash_map_data_at</a>(                       \</div>
<div class="line">                        private_flat_hash_map_ins_ent_pointer-&gt;private.map,    \</div>
<div class="line">                        private_flat_hash_map_ins_ent_pointer-&gt;private.index); \</div>
<div class="line">                *private_flat_hash_map_ins_ent_res = type_compound_literal;    \</div>
<div class="line">                if (private_flat_hash_map_ins_ent_pointer-&gt;private.status      \</div>
<div class="line">                    == CCC_ENTRY_VACANT)                                       \</div>
<div class="line">                {                                                              \</div>
<div class="line">                    CCC_private_flat_hash_map_set_insert(                      \</div>
<div class="line">                        &amp;private_flat_hash_map_ins_ent_pointer-&gt;private);      \</div>
<div class="line">                }                                                              \</div>
<div class="line">            }                                                                  \</div>
<div class="line">        }                                                                      \</div>
<div class="line">        private_flat_hash_map_ins_ent_res;                                     \</div>
<div class="line">    }))</div>
</div><!-- fragment --><p>Insert entry also should not fail and therefore returns a reference directly. This is similar to insert or assign where overwriting may occur. </p>

</div>
</div>
<a id="a9b0bb89a9e79d518c1bbd4529a320451" name="a9b0bb89a9e79d518c1bbd4529a320451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0bb89a9e79d518c1bbd4529a320451">&#9670;&#160;</a></span>CCC_private_flat_hash_map_insert_or_assign_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_insert_or_assign_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flat_hash_map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Because this function does not start with an entry it has the option to give user more information and therefore returns an entry. Importantly, this function makes sure the key is in sync with key in table. Similar to insert entry this will overwrite. </p>

</div>
</div>
<a id="aec8e8dc2f6fd7574ad3f484cadb1664b" name="aec8e8dc2f6fd7574ad3f484cadb1664b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8e8dc2f6fd7574ad3f484cadb1664b">&#9670;&#160;</a></span>CCC_private_flat_hash_map_or_insert_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_or_insert_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Flat_hash_map_entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (__extension__({                                                           \</div>
<div class="line">        __auto_type private_flat_hash_map_or_ins_ent_pointer                   \</div>
<div class="line">            = (Flat_hash_map_entry_pointer);                                   \</div>
<div class="line">        typeof(type_compound_literal) *private_flat_hash_map_or_ins_res        \</div>
<div class="line">            = NULL;                                                            \</div>
<div class="line">        if (private_flat_hash_map_or_ins_ent_pointer)                          \</div>
<div class="line">        {                                                                      \</div>
<div class="line">            if (!(private_flat_hash_map_or_ins_ent_pointer-&gt;private.status     \</div>
<div class="line">                  &amp; CCC_ENTRY_INSERT_ERROR))                                   \</div>
<div class="line">            {                                                                  \</div>
<div class="line">                private_flat_hash_map_or_ins_res                               \</div>
<div class="line">                    = <a class="code hl_function" href="private__flat__hash__map_8h.html#aad4a10c1784d6e91e8df547cf0479386">CCC_private_flat_hash_map_data_at</a>(                       \</div>
<div class="line">                        private_flat_hash_map_or_ins_ent_pointer-&gt;private.map, \</div>
<div class="line">                        private_flat_hash_map_or_ins_ent_pointer-&gt;private      \</div>
<div class="line">                            .index);                                           \</div>
<div class="line">                if (private_flat_hash_map_or_ins_ent_pointer-&gt;private.status   \</div>
<div class="line">                    == CCC_ENTRY_VACANT)                                       \</div>
<div class="line">                {                                                              \</div>
<div class="line">                    *private_flat_hash_map_or_ins_res = type_compound_literal; \</div>
<div class="line">                    CCC_private_flat_hash_map_set_insert(                      \</div>
<div class="line">                        &amp;private_flat_hash_map_or_ins_ent_pointer-&gt;private);   \</div>
<div class="line">                }                                                              \</div>
<div class="line">            }                                                                  \</div>
<div class="line">        }                                                                      \</div>
<div class="line">        private_flat_hash_map_or_ins_res;                                      \</div>
<div class="line">    }))</div>
</div><!-- fragment --><p>The or insert method is unique in that it directly returns a reference to the inserted data rather than a entry with a status. This is because it should not fail. If NULL is returned the user knows there is a problem. </p>

</div>
</div>
<a id="a6192df10948a8c7d1a953bb9129b5a39" name="a6192df10948a8c7d1a953bb9129b5a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6192df10948a8c7d1a953bb9129b5a39">&#9670;&#160;</a></span>CCC_private_flat_hash_map_try_insert_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_try_insert_with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flat_hash_map_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_compound_literal...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Because this function does not start with an entry it has the option to give user more information and therefore returns an entry. Importantly, this function makes sure the key is in sync with key in table. </p>

</div>
</div>
<a id="ab3f2de88ddc0d59eae946c6ec3996d54" name="ab3f2de88ddc0d59eae946c6ec3996d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f2de88ddc0d59eae946c6ec3996d54">&#9670;&#160;</a></span>CCC_private_flat_hash_map_with_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_private_flat_hash_map_with_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_hash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_key_compare, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_context_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">private_cap&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (__extension__({                                                           \</div>
<div class="line">        <span class="keyword">struct </span><a class="code hl_struct" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> private_map                                   \</div>
<div class="line">            = <a class="code hl_define" href="private__flat__hash__map_8h.html#aa0ab2a47b824372a9509d90a899f1971">CCC_private_flat_hash_map_initialize</a>(                            \</div>
<div class="line">                NULL, private_type_name, private_key_field, private_hash,      \</div>
<div class="line">                private_key_compare, private_allocate, private_context_data,   \</div>
<div class="line">                0);                                                            \</div>
<div class="line">        (void)<a class="code hl_function" href="flat__hash__map_8h.html#abde2c0903a9cb74a55ae6e22b58d0c80">CCC_flat_hash_map_reserve</a>(&amp;private_map, private_cap,             \</div>
<div class="line">                                        private_allocate);                     \</div>
<div class="line">        private_map;                                                           \</div>
<div class="line">    }))</div>
<div class="ttc" id="aflat__hash__map_8h_html_abde2c0903a9cb74a55ae6e22b58d0c80"><div class="ttname"><a href="flat__hash__map_8h.html#abde2c0903a9cb74a55ae6e22b58d0c80">CCC_flat_hash_map_reserve</a></div><div class="ttdeci">CCC_Result CCC_flat_hash_map_reserve(CCC_Flat_hash_map *map, size_t to_add, CCC_Allocator *allocate)</div><div class="ttdoc">Reserve space required to add a specified number of elements to the map. If the current capacity is s...</div></div>
<div class="ttc" id="aprivate__flat__hash__map_8h_html_aa0ab2a47b824372a9509d90a899f1971"><div class="ttname"><a href="private__flat__hash__map_8h.html#aa0ab2a47b824372a9509d90a899f1971">CCC_private_flat_hash_map_initialize</a></div><div class="ttdeci">#define CCC_private_flat_hash_map_initialize( private_fixed_map_pointer, private_type_name, private_key_field, private_hash, private_key_compare, private_allocate, private_context_data, private_capacity)</div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:276</div></div>
<div class="ttc" id="astructCCC__Flat__hash__map_html"><div class="ttname"><a href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a></div><div class="ttdef"><b>Definition:</b> private_flat_hash_map.h:142</div></div>
</div><!-- fragment --><p>Initializes the flat hash map with the specified capacity. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7896f889fcae9a565fd28b00cc87c5ff" name="a7896f889fcae9a565fd28b00cc87c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7896f889fcae9a565fd28b00cc87c5ff">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : typeof((struct <a class="el" href="structCCC__Flat__hash__map__tag.html">CCC_Flat_hash_map_tag</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vectorized group scanning allows more parallel scans but a fallback of 8 is good for a portable implementation that will use the widest word on a platform for group scanning. Right now, this lib targets 64-bit so that means uint64_t is widest default integer widely supported. That width is still valid on 32-bit but probably very slow due to emulation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aad4a10c1784d6e91e8df547cf0479386" name="aad4a10c1784d6e91e8df547cf0479386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4a10c1784d6e91e8df547cf0479386">&#9670;&#160;</a></span>CCC_private_flat_hash_map_data_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_private_flat_hash_map_data_at </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cb9715bc1ea20cc3533596f823cbd72" name="a8cb9715bc1ea20cc3533596f823cbd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb9715bc1ea20cc3533596f823cbd72">&#9670;&#160;</a></span>CCC_private_flat_hash_map_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> CCC_private_flat_hash_map_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb24a95ef43efc69f6262918563cc9a" name="a1eb24a95ef43efc69f6262918563cc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb24a95ef43efc69f6262918563cc9a">&#9670;&#160;</a></span>CCC_private_flat_hash_map_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CCC_private_flat_hash_map_erase </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c8e7824940f5cdcd82e2836c09d5618" name="a3c8e7824940f5cdcd82e2836c09d5618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8e7824940f5cdcd82e2836c09d5618">&#9670;&#160;</a></span>CCC_private_flat_hash_map_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CCC_private_flat_hash_map_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structCCC__Flat__hash__map__tag.html">CCC_Flat_hash_map_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf94387ff07081727cf9455e40fb0348" name="abf94387ff07081727cf9455e40fb0348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf94387ff07081727cf9455e40fb0348">&#9670;&#160;</a></span>CCC_private_flat_hash_map_key_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_private_flat_hash_map_key_at </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCCC__Flat__hash__map.html">CCC_Flat_hash_map</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad21f0abc14cb14877203b61442311216" name="ad21f0abc14cb14877203b61442311216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21f0abc14cb14877203b61442311216">&#9670;&#160;</a></span>CCC_private_flat_hash_map_set_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CCC_private_flat_hash_map_set_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCCC__Flat__hash__map__entry.html">CCC_Flat_hash_map_entry</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad75883004f3959ffc98ae1b4ff009199" name="ad75883004f3959ffc98ae1b4ff009199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75883004f3959ffc98ae1b4ff009199">&#9670;&#160;</a></span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum  { ... }  CCC_FLAT_HASH_MAP_GROUP_COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vectorized group scanning allows more parallel scans but a fallback of 8 is good for a portable implementation that will use the widest word on a platform for group scanning. Right now, this lib targets 64-bit so that means uint64_t is widest default integer widely supported. That width is still valid on 32-bit but probably very slow due to emulation. A group of tags that can be loded into a 64 bit integer. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="dir_2bcc058c73050eb0d621cdee22caae74.html">private</a></li><li class="navelem"><a class="el" href="private__flat__hash__map_8h.html">private_flat_hash_map.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
