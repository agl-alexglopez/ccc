<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/traits.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('traits_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">traits.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The C Container Collection Traits Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;private/private_traits.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for traits.h:</div>
<div class="dyncontent">
<div class="center"><img src="traits_8h__incl.png" border="0" usemap="#accc_2traits_8h" alt=""/></div>
<map name="accc_2traits_8h" id="accc_2traits_8h">
<area shape="rect" title="The C Container Collection Traits Interface." alt="" coords="1287,5,1381,31"/>
<area shape="rect" href="private__traits_8h_source.html" title=" " alt="" coords="1249,79,1419,104"/>
<area shape="rect" href="adaptive__map_8h.html" title="The Adaptive Map Interface." alt="" coords="157,328,295,353"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="1251,489,1334,515"/>
<area shape="rect" href="array__adaptive__map_8h.html" title="The Array Adaptive Map Interface." alt="" coords="591,328,771,353"/>
<area shape="rect" href="array__tree__map_8h.html" title="The Array Tree Map Interface." alt="" coords="795,328,945,353"/>
<area shape="rect" href="bitset_8h.html" title="The Bit Set Interface." alt="" coords="1454,328,1537,353"/>
<area shape="rect" href="buffer_8h.html" title="The Buffer Interface." alt="" coords="1127,328,1210,353"/>
<area shape="rect" href="doubly__linked__list_8h.html" title="The Doubly Linked List Interface." alt="" coords="390,328,553,353"/>
<area shape="rect" href="flat__double__ended__queue_8h.html" title="The Flat Double Ended Queue Interface." alt="" coords="969,152,1123,192"/>
<area shape="rect" href="flat__hash__map_8h.html" title="The Flat Hash Map Interface." alt="" coords="2062,328,2203,353"/>
<area shape="rect" href="flat__priority__queue_8h.html" title="The Flat Priority Queue Interface." alt="" coords="1250,159,1418,185"/>
<area shape="rect" href="priority__queue_8h.html" title="The Priority Queue Interface." alt="" coords="1575,328,1715,353"/>
<area shape="rect" href="singly__linked__list_8h.html" title="The Singly Linked List Interface." alt="" coords="1813,328,1972,353"/>
<area shape="rect" href="tree__map_8h.html" title="The Tree Map Interface." alt="" coords="2392,328,2500,353"/>
<area shape="rect" href="private__adaptive__map_8h.html" title="The Adaptive Map Private Interface." alt="" coords="5,401,188,441"/>
<area shape="rect" href="private__types_8h_source.html" title=" " alt="" coords="1089,563,1262,588"/>
<area shape="rect" href="private__array__adaptive__map_8h_source.html" title=" " alt="" coords="509,401,668,441"/>
<area shape="rect" href="private__array__tree__map_8h_source.html" title=" " alt="" coords="744,401,903,441"/>
<area shape="rect" href="private__bitset_8h_source.html" title=" " alt="" coords="1381,409,1556,434"/>
<area shape="rect" href="private__buffer_8h_source.html" title=" " alt="" coords="1080,409,1255,434"/>
<area shape="rect" href="private__doubly__linked__list_8h_source.html" title=" " alt="" coords="264,401,433,441"/>
<area shape="rect" href="private__flat__double__ended__queue_8h_source.html" title=" " alt="" coords="957,240,1135,280"/>
<area shape="rect" href="private__flat__hash__map_8h.html" title="Private Flat Hash Map Interface." alt="" coords="2170,401,2317,441"/>
<area shape="rect" href="private__flat__priority__queue_8h_source.html" title=" " alt="" coords="1261,240,1407,280"/>
<area shape="rect" href="private__priority__queue_8h_source.html" title=" " alt="" coords="1683,401,1855,441"/>
<area shape="rect" href="private__singly__linked__list_8h_source.html" title=" " alt="" coords="1931,401,2095,441"/>
<area shape="rect" href="private__tree__map_8h_source.html" title=" " alt="" coords="2443,401,2593,441"/>
</map>
</div>
</div>
<p><a href="traits_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The C Container Collection Traits Interface. </p>
<p>Many functionalities across containers are similar. These can be described as traits that each container implements (see Rust Traits for a more pure example of the topic). Only a selection of shared traits across containers are represented here because some containers implement unique functionality that cannot be shared with other containers. These can simplify code greatly at a slightly higher compilation resource cost. There is no runtime cost to using traits.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All traits can then be written without the <code>CCC_</code> prefix. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Entry Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and operate on container entries for efficient queries when non-trivial control flow is needed. </p>
</td></tr>
<tr class="memitem:af73671786e7614393692a679167bc3f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#af73671786e7614393692a679167bc3f1">CCC_swap_entry</a>(container_pointer,  swap_args...)&#160;&#160;&#160;    CCC_private_swap_entry(container_pointer, swap_args)</td></tr>
<tr class="memdesc:af73671786e7614393692a679167bc3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and obtain the old value if Occupied.  <br /></td></tr>
<tr class="separator:af73671786e7614393692a679167bc3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd92ffb32259626bcad0acdccddc08f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#afd92ffb32259626bcad0acdccddc08f8">CCC_swap_entry_wrap</a>(container_pointer,  swap_args...)&#160;&#160;&#160;    CCC_private_swap_entry_wrap(container_pointer, swap_args)</td></tr>
<tr class="memdesc:afd92ffb32259626bcad0acdccddc08f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and obtain the old value if Occupied.  <br /></td></tr>
<tr class="separator:afd92ffb32259626bcad0acdccddc08f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec28b1d6ea9caa46c0da63fdbdcb563"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#aeec28b1d6ea9caa46c0da63fdbdcb563">CCC_swap_handle</a>(container_pointer,  swap_args...)&#160;&#160;&#160;    CCC_private_swap_handle(container_pointer, swap_args)</td></tr>
<tr class="memdesc:aeec28b1d6ea9caa46c0da63fdbdcb563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and obtain the old value if Occupied.  <br /></td></tr>
<tr class="separator:aeec28b1d6ea9caa46c0da63fdbdcb563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3956da2423bcfb44ee90a643375eae9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a3956da2423bcfb44ee90a643375eae9b">CCC_swap_handle_wrap</a>(container_pointer,  swap_args...)&#160;&#160;&#160;    CCC_private_swap_handle_wrap(container_pointer, swap_args)</td></tr>
<tr class="memdesc:a3956da2423bcfb44ee90a643375eae9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and obtain the old value if Occupied.  <br /></td></tr>
<tr class="separator:a3956da2423bcfb44ee90a643375eae9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b4afddcbface91165a008dfc57d1c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a76b4afddcbface91165a008dfc57d1c3">CCC_try_insert</a>(container_pointer,  try_insert_args...)&#160;&#160;&#160;    CCC_private_try_insert(container_pointer, try_insert_args)</td></tr>
<tr class="memdesc:a76b4afddcbface91165a008dfc57d1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element if the entry is Vacant.  <br /></td></tr>
<tr class="separator:a76b4afddcbface91165a008dfc57d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc7cf3c628589c0d1d4cb736ecd8e1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a1fc7cf3c628589c0d1d4cb736ecd8e1d">CCC_try_insert_wrap</a>(container_pointer,  try_insert_args...)&#160;&#160;&#160;    CCC_private_try_insert_wrap(container_pointer, try_insert_args)</td></tr>
<tr class="memdesc:a1fc7cf3c628589c0d1d4cb736ecd8e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element if the entry is Vacant.  <br /></td></tr>
<tr class="separator:a1fc7cf3c628589c0d1d4cb736ecd8e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab222e2a29adc86ec865d5f7ceb6151de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ab222e2a29adc86ec865d5f7ceb6151de">CCC_insert_or_assign</a>(container_pointer,  insert_or_assign_args...)&#160;&#160;&#160;    CCC_private_insert_or_assign(container_pointer, insert_or_assign_args)</td></tr>
<tr class="memdesc:ab222e2a29adc86ec865d5f7ceb6151de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element or overwrite the Occupied entry.  <br /></td></tr>
<tr class="separator:ab222e2a29adc86ec865d5f7ceb6151de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf35b886146ce60b1691dff771475f56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#abf35b886146ce60b1691dff771475f56">CCC_insert_or_assign_wrap</a>(container_pointer,  insert_or_assign_args...)&#160;&#160;&#160;    CCC_private_insert_or_assign_wrap(container_pointer, insert_or_assign_args)</td></tr>
<tr class="memdesc:abf35b886146ce60b1691dff771475f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element or overwrite the Occupied entry.  <br /></td></tr>
<tr class="separator:abf35b886146ce60b1691dff771475f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6fb2903be6f9b91ff9c5e2960ca9ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a0e6fb2903be6f9b91ff9c5e2960ca9ab">CCC_remove_key_value</a>(container_pointer,  remove_key_value_args...)&#160;&#160;&#160;    CCC_private_remove_key_value(container_pointer, remove_key_value_args)</td></tr>
<tr class="memdesc:a0e6fb2903be6f9b91ff9c5e2960ca9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element and retain access to its value.  <br /></td></tr>
<tr class="separator:a0e6fb2903be6f9b91ff9c5e2960ca9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ccd33dfe8d3d8281b0ff03e594eeff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a69ccd33dfe8d3d8281b0ff03e594eeff">CCC_remove_key_value_wrap</a>(container_pointer,  remove_key_value_args...)&#160;&#160;&#160;    CCC_private_remove_key_value_wrap(container_pointer, remove_key_value_args)</td></tr>
<tr class="memdesc:a69ccd33dfe8d3d8281b0ff03e594eeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element and retain access to its value.  <br /></td></tr>
<tr class="separator:a69ccd33dfe8d3d8281b0ff03e594eeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2093b0d81c352dc0eb6e85a77a7ee54b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a2093b0d81c352dc0eb6e85a77a7ee54b">CCC_entry</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_entry(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:a2093b0d81c352dc0eb6e85a77a7ee54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a container specific entry for the Entry Interface.  <br /></td></tr>
<tr class="separator:a2093b0d81c352dc0eb6e85a77a7ee54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eb0d1bbce755e2a7c0358a30ee7890"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ab6eb0d1bbce755e2a7c0358a30ee7890">CCC_handle</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_handle(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:ab6eb0d1bbce755e2a7c0358a30ee7890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a container specific handle for the handle Interface.  <br /></td></tr>
<tr class="separator:ab6eb0d1bbce755e2a7c0358a30ee7890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cb05888afcab07cf9340d20205d2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a14cb05888afcab07cf9340d20205d2e5">CCC_entry_wrap</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_entry_wrap(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:a14cb05888afcab07cf9340d20205d2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a container specific entry for the Entry Interface.  <br /></td></tr>
<tr class="separator:a14cb05888afcab07cf9340d20205d2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe611ce746d1d3c4de10eb3151d8e6c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#abe611ce746d1d3c4de10eb3151d8e6c2">CCC_handle_wrap</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_handle_wrap(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:abe611ce746d1d3c4de10eb3151d8e6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a container specific handle for the handle Interface.  <br /></td></tr>
<tr class="separator:abe611ce746d1d3c4de10eb3151d8e6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c69e9a18e4bbafb9d6e5c7327fd0e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a06c69e9a18e4bbafb9d6e5c7327fd0e8">CCC_and_modify</a>(entry_pointer,  mod_fn)&#160;&#160;&#160;    CCC_private_and_modify(entry_pointer, mod_fn)</td></tr>
<tr class="memdesc:a06c69e9a18e4bbafb9d6e5c7327fd0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an entry if Occupied.  <br /></td></tr>
<tr class="separator:a06c69e9a18e4bbafb9d6e5c7327fd0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc8e8c6894af4531258c83a401b2a6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#adfc8e8c6894af4531258c83a401b2a6c">CCC_and_modify_context</a>(entry_pointer,  modify,  context_args...)&#160;&#160;&#160;    CCC_private_and_modify_context(entry_pointer, modify, context_args)</td></tr>
<tr class="memdesc:adfc8e8c6894af4531258c83a401b2a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an entry if Occupied.  <br /></td></tr>
<tr class="separator:adfc8e8c6894af4531258c83a401b2a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a6ed01f799befd3f56f8f7ad51f8fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a68a6ed01f799befd3f56f8f7ad51f8fa">CCC_insert_entry</a>(entry_pointer,  insert_entry_args...)&#160;&#160;&#160;    CCC_private_insert_entry(entry_pointer, insert_entry_args)</td></tr>
<tr class="memdesc:a68a6ed01f799befd3f56f8f7ad51f8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element or overwrite old element.  <br /></td></tr>
<tr class="separator:a68a6ed01f799befd3f56f8f7ad51f8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914a9dd271bd208b15f3e338ceeda842"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a914a9dd271bd208b15f3e338ceeda842">CCC_insert_handle</a>(array_pointer,  insert_array_args...)&#160;&#160;&#160;    CCC_private_insert_handle(array_pointer, insert_array_args)</td></tr>
<tr class="memdesc:a914a9dd271bd208b15f3e338ceeda842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element or overwrite old element.  <br /></td></tr>
<tr class="separator:a914a9dd271bd208b15f3e338ceeda842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01abb830338b060bf31dbc61841ecec6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a01abb830338b060bf31dbc61841ecec6">CCC_or_insert</a>(entry_pointer,  or_insert_args...)&#160;&#160;&#160;    CCC_private_or_insert(entry_pointer, or_insert_args)</td></tr>
<tr class="memdesc:a01abb830338b060bf31dbc61841ecec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element if the entry is Vacant.  <br /></td></tr>
<tr class="separator:a01abb830338b060bf31dbc61841ecec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac207035aea4cbe0c51d16589c2460db4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ac207035aea4cbe0c51d16589c2460db4">CCC_remove_entry</a>(entry_pointer)&#160;&#160;&#160;CCC_private_remove_entry(entry_pointer)</td></tr>
<tr class="memdesc:ac207035aea4cbe0c51d16589c2460db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element if the entry is Occupied.  <br /></td></tr>
<tr class="separator:ac207035aea4cbe0c51d16589c2460db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e80401338bc7980d63b75bf9c8cc108"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4e80401338bc7980d63b75bf9c8cc108">CCC_remove_entry_wrap</a>(entry_pointer)&#160;&#160;&#160;    CCC_private_remove_entry_wrap(entry_pointer)</td></tr>
<tr class="memdesc:a4e80401338bc7980d63b75bf9c8cc108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element if the entry is Occupied.  <br /></td></tr>
<tr class="separator:a4e80401338bc7980d63b75bf9c8cc108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a9141ace02d75b61a40e78fb070e08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a81a9141ace02d75b61a40e78fb070e08">CCC_remove_handle</a>(array_pointer)&#160;&#160;&#160;    CCC_private_remove_handle(array_pointer)</td></tr>
<tr class="memdesc:a81a9141ace02d75b61a40e78fb070e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element if the handle is Occupied.  <br /></td></tr>
<tr class="separator:a81a9141ace02d75b61a40e78fb070e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe3201d00f81e4ef8b5d060086561da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a8fe3201d00f81e4ef8b5d060086561da">CCC_remove_handle_wrap</a>(array_pointer)&#160;&#160;&#160;    CCC_private_remove_handle_wrap(array_pointer)</td></tr>
<tr class="memdesc:a8fe3201d00f81e4ef8b5d060086561da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element if the handle is Occupied.  <br /></td></tr>
<tr class="separator:a8fe3201d00f81e4ef8b5d060086561da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42510f7ed011f774d3549ef3c91d4a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ab42510f7ed011f774d3549ef3c91d4a2">CCC_unwrap</a>(entry_pointer)&#160;&#160;&#160;CCC_private_unwrap(entry_pointer)</td></tr>
<tr class="memdesc:ab42510f7ed011f774d3549ef3c91d4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwrap user type in entry.  <br /></td></tr>
<tr class="separator:ab42510f7ed011f774d3549ef3c91d4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ffeab920e9fb81fb185004e4e22f60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a98ffeab920e9fb81fb185004e4e22f60">CCC_occupied</a>(entry_pointer)&#160;&#160;&#160;CCC_private_occupied(entry_pointer)</td></tr>
<tr class="memdesc:a98ffeab920e9fb81fb185004e4e22f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check occupancy of entry.  <br /></td></tr>
<tr class="separator:a98ffeab920e9fb81fb185004e4e22f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0478c724a9aa16943c6515b95a4c5c83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a0478c724a9aa16943c6515b95a4c5c83">CCC_insert_error</a>(entry_pointer)&#160;&#160;&#160;CCC_private_insert_error(entry_pointer)</td></tr>
<tr class="memdesc:a0478c724a9aa16943c6515b95a4c5c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check last insert status.  <br /></td></tr>
<tr class="separator:a0478c724a9aa16943c6515b95a4c5c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Membership Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Test membership or obtain references to stored user types directly. </p>
</td></tr>
<tr class="memitem:a4a81daea52cfe16f59ff00d87015b106"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4a81daea52cfe16f59ff00d87015b106">CCC_get_key_value</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_get_key_value(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:a4a81daea52cfe16f59ff00d87015b106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the user type stored at the key.  <br /></td></tr>
<tr class="separator:a4a81daea52cfe16f59ff00d87015b106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a399d979c7e3e284ddb395d6a42487"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ae4a399d979c7e3e284ddb395d6a42487">CCC_contains</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_contains(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:ae4a399d979c7e3e284ddb395d6a42487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for membership of the key.  <br /></td></tr>
<tr class="separator:ae4a399d979c7e3e284ddb395d6a42487"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Push Pop Front Back Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Push, pop, and view elements in sorted or unsorted containers. </p>
</td></tr>
<tr class="memitem:a5b15181bd50f62ae01bf715fd443335b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a5b15181bd50f62ae01bf715fd443335b">CCC_push</a>(container_pointer,  push_args...)&#160;&#160;&#160;    CCC_private_push(container_pointer, push_args)</td></tr>
<tr class="memdesc:a5b15181bd50f62ae01bf715fd443335b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element into a container.  <br /></td></tr>
<tr class="separator:a5b15181bd50f62ae01bf715fd443335b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a97a914557e4d9db0850a729846b41a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4a97a914557e4d9db0850a729846b41a">CCC_push_back</a>(container_pointer,  push_args...)&#160;&#160;&#160;    CCC_private_push_back(container_pointer, push_args)</td></tr>
<tr class="memdesc:a4a97a914557e4d9db0850a729846b41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the back of a container.  <br /></td></tr>
<tr class="separator:a4a97a914557e4d9db0850a729846b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea45ab24bcfbdb0867892f5d794cbf7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a6ea45ab24bcfbdb0867892f5d794cbf7">CCC_push_front</a>(container_pointer,  push_args...)&#160;&#160;&#160;    CCC_private_push_front(container_pointer, push_args)</td></tr>
<tr class="memdesc:a6ea45ab24bcfbdb0867892f5d794cbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the front of a container.  <br /></td></tr>
<tr class="separator:a6ea45ab24bcfbdb0867892f5d794cbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d88484deff770ce7fcfb060c5800bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a17d88484deff770ce7fcfb060c5800bd">CCC_pop</a>(container_pointer,  pop_args...)&#160;&#160;&#160;    CCC_private_pop(container_pointer, pop_args)</td></tr>
<tr class="memdesc:a17d88484deff770ce7fcfb060c5800bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an element from a container.  <br /></td></tr>
<tr class="separator:a17d88484deff770ce7fcfb060c5800bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6ea07e914d9bdd03424c39082299e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#adc6ea07e914d9bdd03424c39082299e5">CCC_pop_front</a>(container_pointer)&#160;&#160;&#160;    CCC_private_pop_front(container_pointer)</td></tr>
<tr class="memdesc:adc6ea07e914d9bdd03424c39082299e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an element from the front of a container.  <br /></td></tr>
<tr class="separator:adc6ea07e914d9bdd03424c39082299e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddf2fb67b4322c8cb48a7ecf09f3115"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a9ddf2fb67b4322c8cb48a7ecf09f3115">CCC_pop_back</a>(container_pointer)&#160;&#160;&#160;CCC_private_pop_back(container_pointer)</td></tr>
<tr class="memdesc:a9ddf2fb67b4322c8cb48a7ecf09f3115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an element from the back of a container.  <br /></td></tr>
<tr class="separator:a9ddf2fb67b4322c8cb48a7ecf09f3115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5072ddc807149d24311ff1729a5c1c60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a5072ddc807149d24311ff1729a5c1c60">CCC_front</a>(container_pointer)&#160;&#160;&#160;CCC_private_front(container_pointer)</td></tr>
<tr class="memdesc:a5072ddc807149d24311ff1729a5c1c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference the front element of a container.  <br /></td></tr>
<tr class="separator:a5072ddc807149d24311ff1729a5c1c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55359b1a71f993ab27c2f267012a62c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a55359b1a71f993ab27c2f267012a62c2">CCC_back</a>(container_pointer)&#160;&#160;&#160;CCC_private_back(container_pointer)</td></tr>
<tr class="memdesc:a55359b1a71f993ab27c2f267012a62c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference the back element of a container.  <br /></td></tr>
<tr class="separator:a55359b1a71f993ab27c2f267012a62c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3953bc97751fd7c344b1de5abfbf1ef0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a3953bc97751fd7c344b1de5abfbf1ef0">CCC_splice</a>(container_pointer,  splice_args...)&#160;&#160;&#160;    CCC_private_splice(container_pointer, splice_args)</td></tr>
<tr class="memdesc:a3953bc97751fd7c344b1de5abfbf1ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splice an element from one position to another in the same or a different container.  <br /></td></tr>
<tr class="separator:a3953bc97751fd7c344b1de5abfbf1ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c929a44614a438a3cb5017473cf7df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a77c929a44614a438a3cb5017473cf7df">CCC_splice_range</a>(container_pointer,  splice_args...)&#160;&#160;&#160;    CCC_private_splice_range(container_pointer, splice_args)</td></tr>
<tr class="memdesc:a77c929a44614a438a3cb5017473cf7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splice a range of elements from one position to another in the same or a different container.  <br /></td></tr>
<tr class="separator:a77c929a44614a438a3cb5017473cf7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Priority Queue Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Interface to support generic priority queue operations. </p>
</td></tr>
<tr class="memitem:a45fcf69f6f0e8084efc272a2e25e5a55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a45fcf69f6f0e8084efc272a2e25e5a55">CCC_update</a>(container_pointer,  update_args...)&#160;&#160;&#160;    CCC_private_update(container_pointer, update_args)</td></tr>
<tr class="memdesc:a45fcf69f6f0e8084efc272a2e25e5a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of an element known to be in a container.  <br /></td></tr>
<tr class="separator:a45fcf69f6f0e8084efc272a2e25e5a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540db48ad3c7ad9e4f43f353c932f57f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a540db48ad3c7ad9e4f43f353c932f57f">CCC_increase</a>(container_pointer,  increase_args...)&#160;&#160;&#160;    CCC_private_increase(container_pointer, increase_args)</td></tr>
<tr class="memdesc:a540db48ad3c7ad9e4f43f353c932f57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the value of an element known to be in a container.  <br /></td></tr>
<tr class="separator:a540db48ad3c7ad9e4f43f353c932f57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7faf73b8c2d6297f49780e3ba83c28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a1e7faf73b8c2d6297f49780e3ba83c28">CCC_decrease</a>(container_pointer,  decrease_args...)&#160;&#160;&#160;    CCC_private_decrease(container_pointer, decrease_args)</td></tr>
<tr class="memdesc:a1e7faf73b8c2d6297f49780e3ba83c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the value of an element known to be in a container.  <br /></td></tr>
<tr class="separator:a1e7faf73b8c2d6297f49780e3ba83c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c596ca5ba4bb73797dd45acbe1e9e7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a3c596ca5ba4bb73797dd45acbe1e9e7c">CCC_erase</a>(container_pointer,  erase_args...)&#160;&#160;&#160;    CCC_private_erase(container_pointer, erase_args)</td></tr>
<tr class="memdesc:a3c596ca5ba4bb73797dd45acbe1e9e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element known to be in a container.  <br /></td></tr>
<tr class="separator:a3c596ca5ba4bb73797dd45acbe1e9e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150014bccd5f183ac0e7ce92c265265c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a150014bccd5f183ac0e7ce92c265265c">CCC_extract</a>(container_pointer,  extract_args...)&#160;&#160;&#160;    CCC_private_extract(container_pointer, extract_args)</td></tr>
<tr class="memdesc:a150014bccd5f183ac0e7ce92c265265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element known to be in a container (does not free).  <br /></td></tr>
<tr class="separator:a150014bccd5f183ac0e7ce92c265265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abb10512cb2c434e67177ba71c664d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a2abb10512cb2c434e67177ba71c664d3">CCC_extract_range</a>(container_pointer,  extract_args...)&#160;&#160;&#160;    CCC_private_extract_range(container_pointer, extract_args)</td></tr>
<tr class="memdesc:a2abb10512cb2c434e67177ba71c664d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract elements known to be in a container (does not free).  <br /></td></tr>
<tr class="separator:a2abb10512cb2c434e67177ba71c664d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iterator Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and manage iterators over the container. </p>
</td></tr>
<tr class="memitem:a7cafec411ee3f60bc10033bb8abf7ac4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a7cafec411ee3f60bc10033bb8abf7ac4">CCC_begin</a>(container_pointer)&#160;&#160;&#160;CCC_private_begin(container_pointer)</td></tr>
<tr class="memdesc:a7cafec411ee3f60bc10033bb8abf7ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the start of a container.  <br /></td></tr>
<tr class="separator:a7cafec411ee3f60bc10033bb8abf7ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6237dcd969f191f580d65d7fd63be4c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a6237dcd969f191f580d65d7fd63be4c5">CCC_reverse_begin</a>(container_pointer)&#160;&#160;&#160;    CCC_private_reverse_begin(container_pointer)</td></tr>
<tr class="memdesc:a6237dcd969f191f580d65d7fd63be4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the reversed start of a container.  <br /></td></tr>
<tr class="separator:a6237dcd969f191f580d65d7fd63be4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2e1d8eb494bca89d88a171b4a3ab5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a1a2e1d8eb494bca89d88a171b4a3ab5d">CCC_next</a>(container_pointer,  void_iterator_pointer)&#160;&#160;&#160;    CCC_private_next(container_pointer, void_iterator_pointer)</td></tr>
<tr class="memdesc:a1a2e1d8eb494bca89d88a171b4a3ab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the next element in the container.  <br /></td></tr>
<tr class="separator:a1a2e1d8eb494bca89d88a171b4a3ab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fab7d4aca5df5547f4474095f18b40a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a1fab7d4aca5df5547f4474095f18b40a">CCC_reverse_next</a>(container_pointer,  void_iterator_pointer)&#160;&#160;&#160;    CCC_private_reverse_next(container_pointer, void_iterator_pointer)</td></tr>
<tr class="memdesc:a1fab7d4aca5df5547f4474095f18b40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the reverse_next element in the container.  <br /></td></tr>
<tr class="separator:a1fab7d4aca5df5547f4474095f18b40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f69c818b648fb9d44f3807d72f9653a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4f69c818b648fb9d44f3807d72f9653a">CCC_end</a>(container_pointer)&#160;&#160;&#160;CCC_private_end(container_pointer)</td></tr>
<tr class="memdesc:a4f69c818b648fb9d44f3807d72f9653a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the end sentinel of a container.  <br /></td></tr>
<tr class="separator:a4f69c818b648fb9d44f3807d72f9653a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e882e40fee89407d607872f31814381"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4e882e40fee89407d607872f31814381">CCC_reverse_end</a>(container_pointer)&#160;&#160;&#160;    CCC_private_reverse_end(container_pointer)</td></tr>
<tr class="memdesc:a4e882e40fee89407d607872f31814381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the reverse_end sentinel of a container.  <br /></td></tr>
<tr class="separator:a4e882e40fee89407d607872f31814381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248d85f3ebeda74c0ffc4f4e9963f834"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a248d85f3ebeda74c0ffc4f4e9963f834">CCC_equal_range</a>(container_pointer,  range_args...)&#160;&#160;&#160;    CCC_private_equal_range(container_pointer, range_args)</td></tr>
<tr class="memdesc:a248d85f3ebeda74c0ffc4f4e9963f834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a range of values from a container.  <br /></td></tr>
<tr class="separator:a248d85f3ebeda74c0ffc4f4e9963f834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d90a64d3237a68c91d2bcfe238f4ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a89d90a64d3237a68c91d2bcfe238f4ea">CCC_equal_range_wrap</a>(container_pointer,  range_args...)&#160;&#160;&#160;    CCC_private_equal_range_wrap(container_pointer, range_args)</td></tr>
<tr class="memdesc:a89d90a64d3237a68c91d2bcfe238f4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a range of values from a container.  <br /></td></tr>
<tr class="separator:a89d90a64d3237a68c91d2bcfe238f4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccb83ad25525b5fca2019c342dc884e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a7ccb83ad25525b5fca2019c342dc884e">CCC_equal_range_reverse</a>(container_pointer,  range_reverse_args...)&#160;&#160;&#160;    CCC_private_equal_range_reverse(container_pointer, range_reverse_args)</td></tr>
<tr class="memdesc:a7ccb83ad25525b5fca2019c342dc884e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a range_reverse of values from a container.  <br /></td></tr>
<tr class="separator:a7ccb83ad25525b5fca2019c342dc884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c2982956cb64bf403ab774cef7f84e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ac1c2982956cb64bf403ab774cef7f84e">CCC_equal_range_reverse_wrap</a>(container_pointer,  range_reverse_args...)&#160;&#160;&#160;    CCC_private_equal_range_reverse_wrap(container_pointer, range_reverse_args)</td></tr>
<tr class="memdesc:ac1c2982956cb64bf403ab774cef7f84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a range_reverse of values from a container.  <br /></td></tr>
<tr class="separator:ac1c2982956cb64bf403ab774cef7f84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e153edc4d813aeb8fcba9640c53d1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#af1e153edc4d813aeb8fcba9640c53d1a">CCC_range_begin</a>(range_pointer)&#160;&#160;&#160;CCC_private_range_begin(range_pointer)</td></tr>
<tr class="memdesc:af1e153edc4d813aeb8fcba9640c53d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the beginning of the range iterator.  <br /></td></tr>
<tr class="separator:af1e153edc4d813aeb8fcba9640c53d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645dbec6c02190de14248d44ed642412"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a645dbec6c02190de14248d44ed642412">CCC_range_end</a>(range_pointer)&#160;&#160;&#160;CCC_private_range_end(range_pointer)</td></tr>
<tr class="memdesc:a645dbec6c02190de14248d44ed642412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the end of the range iterator.  <br /></td></tr>
<tr class="separator:a645dbec6c02190de14248d44ed642412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad055a9c9c00366a2fb4f4a5941a47adc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ad055a9c9c00366a2fb4f4a5941a47adc">CCC_range_reverse_begin</a>(range_reverse_pointer)&#160;&#160;&#160;    CCC_private_range_reverse_begin(range_reverse_pointer)</td></tr>
<tr class="memdesc:ad055a9c9c00366a2fb4f4a5941a47adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the beginning of the reverse range iterator.  <br /></td></tr>
<tr class="separator:ad055a9c9c00366a2fb4f4a5941a47adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb020bf9603590a7175222e57871291"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a9cb020bf9603590a7175222e57871291">CCC_range_reverse_end</a>(range_reverse_pointer)&#160;&#160;&#160;    CCC_private_range_reverse_end(range_reverse_pointer)</td></tr>
<tr class="memdesc:a9cb020bf9603590a7175222e57871291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the end of the reverse range iterator.  <br /></td></tr>
<tr class="separator:a9cb020bf9603590a7175222e57871291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Memory Management Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Manage underlying buffers for containers. </p>
</td></tr>
<tr class="memitem:aeeb8fd6d1430bdf51d395413fc00f893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#aeeb8fd6d1430bdf51d395413fc00f893">CCC_copy</a>(destination_container_pointer,  source_container_pointer,  allocate_pointer)</td></tr>
<tr class="memdesc:aeeb8fd6d1430bdf51d395413fc00f893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source containers memory to destination container.  <br /></td></tr>
<tr class="separator:aeeb8fd6d1430bdf51d395413fc00f893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716f00ed6954d4ba8ef0e122f7f20e65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a716f00ed6954d4ba8ef0e122f7f20e65">CCC_reserve</a>(container_pointer,  n_to_add,  allocate_pointer)&#160;&#160;&#160;    CCC_private_reserve(container_pointer, n_to_add, allocate_pointer)</td></tr>
<tr class="memdesc:a716f00ed6954d4ba8ef0e122f7f20e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve capacity for n_to_add new elements to be inserted.  <br /></td></tr>
<tr class="separator:a716f00ed6954d4ba8ef0e122f7f20e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a0123a86214e7715e0753ce7c848c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a36a0123a86214e7715e0753ce7c848c3">CCC_clear</a>(container_pointer,  destructor_args...)&#160;&#160;&#160;    CCC_private_clear(container_pointer, destructor_args)</td></tr>
<tr class="memdesc:a36a0123a86214e7715e0753ce7c848c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container without freeing the underlying buffer.  <br /></td></tr>
<tr class="separator:a36a0123a86214e7715e0753ce7c848c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c06b389361550adecf3e12833e2bfe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#aa4c06b389361550adecf3e12833e2bfe">CCC_clear_and_free</a>(container_pointer,  destructor_and_free_args...)&#160;&#160;&#160;    CCC_private_clear_and_free(container_pointer, destructor_and_free_args)</td></tr>
<tr class="memdesc:aa4c06b389361550adecf3e12833e2bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container and frees the underlying buffer.  <br /></td></tr>
<tr class="separator:aa4c06b389361550adecf3e12833e2bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5019dde8ed83cc1cdba4f9d65b12210"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ae5019dde8ed83cc1cdba4f9d65b12210">CCC_clear_and_free_reserve</a>(container_pointer,  destructor_and_free_args...)</td></tr>
<tr class="memdesc:ae5019dde8ed83cc1cdba4f9d65b12210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container previously reserved and frees its underlying buffer. Covers the case of a one-time memory reserved container that does not otherwise have permissions over its own memory to resize or free.  <br /></td></tr>
<tr class="separator:ae5019dde8ed83cc1cdba4f9d65b12210"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain the container state. </p>
</td></tr>
<tr class="memitem:a677dc640ef165bb424bd911d7fc32aa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a677dc640ef165bb424bd911d7fc32aa3">CCC_count</a>(container_pointer)&#160;&#160;&#160;CCC_private_count(container_pointer)</td></tr>
<tr class="memdesc:a677dc640ef165bb424bd911d7fc32aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the count of elements in the container.  <br /></td></tr>
<tr class="separator:a677dc640ef165bb424bd911d7fc32aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b2442930285cb2343ec96593776759"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ae6b2442930285cb2343ec96593776759">CCC_capacity</a>(container_pointer)&#160;&#160;&#160;CCC_private_capacity(container_pointer)</td></tr>
<tr class="memdesc:ae6b2442930285cb2343ec96593776759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capacity of the container.  <br /></td></tr>
<tr class="separator:ae6b2442930285cb2343ec96593776759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3926a950b876a4ab6a2ca3d5e157a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a0c3926a950b876a4ab6a2ca3d5e157a2">CCC_is_empty</a>(container_pointer)&#160;&#160;&#160;CCC_private_is_empty(container_pointer)</td></tr>
<tr class="memdesc:a0c3926a950b876a4ab6a2ca3d5e157a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size status of a container.  <br /></td></tr>
<tr class="separator:a0c3926a950b876a4ab6a2ca3d5e157a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e45c5f2d2e0a1221ce6310dfee7bce5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a8e45c5f2d2e0a1221ce6310dfee7bce5">CCC_validate</a>(container_pointer)&#160;&#160;&#160;CCC_private_validate(container_pointer)</td></tr>
<tr class="memdesc:a8e45c5f2d2e0a1221ce6310dfee7bce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the invariant statuses of the container.  <br /></td></tr>
<tr class="separator:a8e45c5f2d2e0a1221ce6310dfee7bce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a06c69e9a18e4bbafb9d6e5c7327fd0e8" name="a06c69e9a18e4bbafb9d6e5c7327fd0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c69e9a18e4bbafb9d6e5c7327fd0e8">&#9670;&#160;</a></span>CCC_and_modify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_and_modify</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mod_fn&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_and_modify(entry_pointer, mod_fn)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify an entry if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_fn</td><td>a modification function that does not need context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified entry if Occupied or original if Vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="adfc8e8c6894af4531258c83a401b2a6c" name="adfc8e8c6894af4531258c83a401b2a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc8e8c6894af4531258c83a401b2a6c">&#9670;&#160;</a></span>CCC_and_modify_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_and_modify_context</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">modify, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_and_modify_context(entry_pointer, modify, context_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify an entry if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify</td><td>a modification function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_args</td><td>context data for mod_fn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified entry if Occupied or original if Vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a55359b1a71f993ab27c2f267012a62c2" name="a55359b1a71f993ab27c2f267012a62c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55359b1a71f993ab27c2f267012a62c2">&#9670;&#160;</a></span>CCC_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_back(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference the back element of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a user type.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a7cafec411ee3f60bc10033bb8abf7ac4" name="a7cafec411ee3f60bc10033bb8abf7ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cafec411ee3f60bc10033bb8abf7ac4">&#9670;&#160;</a></span>CCC_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_begin(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the start of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored at the start.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ae6b2442930285cb2343ec96593776759" name="ae6b2442930285cb2343ec96593776759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b2442930285cb2343ec96593776759">&#9670;&#160;</a></span>CCC_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_capacity(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the capacity of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity or an argument error is set if container_pointer is NULL.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a36a0123a86214e7715e0753ce7c848c3" name="a36a0123a86214e7715e0753ce7c848c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a0123a86214e7715e0753ce7c848c3">&#9670;&#160;</a></span>CCC_clear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_clear</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destructor_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_clear(container_pointer, destructor_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the container without freeing the underlying buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor_args</td><td>optional function to be called on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="aa4c06b389361550adecf3e12833e2bfe" name="aa4c06b389361550adecf3e12833e2bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c06b389361550adecf3e12833e2bfe">&#9670;&#160;</a></span>CCC_clear_and_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_clear_and_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destructor_and_free_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_clear_and_free(container_pointer, destructor_and_free_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the container and frees the underlying buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor_and_free_args</td><td>optional function to be called on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ae5019dde8ed83cc1cdba4f9d65b12210" name="ae5019dde8ed83cc1cdba4f9d65b12210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5019dde8ed83cc1cdba4f9d65b12210">&#9670;&#160;</a></span>CCC_clear_and_free_reserve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_clear_and_free_reserve</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destructor_and_free_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_clear_and_free_reserve(container_pointer,                      \</div>
<div class="line">                                       destructor_and_free_args)</div>
</div><!-- fragment -->
<p>Clears the container previously reserved and frees its underlying buffer. Covers the case of a one-time memory reserved container that does not otherwise have permissions over its own memory to resize or free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor_and_free_args</td><td>optional destructor function to be called on each element and the required allocation function to free memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ae4a399d979c7e3e284ddb395d6a42487" name="ae4a399d979c7e3e284ddb395d6a42487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a399d979c7e3e284ddb395d6a42487">&#9670;&#160;</a></span>CCC_contains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_contains</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_contains(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for membership of the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if present false if absent.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="aeeb8fd6d1430bdf51d395413fc00f893" name="aeeb8fd6d1430bdf51d395413fc00f893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb8fd6d1430bdf51d395413fc00f893">&#9670;&#160;</a></span>CCC_copy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_copy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destination_container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">source_container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_copy(destination_container_pointer, source_container_pointer,  \</div>
<div class="line">                     allocate_pointer)</div>
</div><!-- fragment -->
<p>Copy source containers memory to destination container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination_container_pointer</td><td>a pointer to the destination container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_container_pointer</td><td>a pointer to the source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate_pointer</td><td>the allocation function to use for resizing if needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a677dc640ef165bb424bd911d7fc32aa3" name="a677dc640ef165bb424bd911d7fc32aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677dc640ef165bb424bd911d7fc32aa3">&#9670;&#160;</a></span>CCC_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_count</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_count(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the count of elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size or an argument error is set if container_pointer is NULL.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a1e7faf73b8c2d6297f49780e3ba83c28" name="a1e7faf73b8c2d6297f49780e3ba83c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7faf73b8c2d6297f49780e3ba83c28">&#9670;&#160;</a></span>CCC_decrease</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_decrease</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">decrease_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_decrease(container_pointer, decrease_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the value of an element known to be in a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">decrease_args</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4f69c818b648fb9d44f3807d72f9653a" name="a4f69c818b648fb9d44f3807d72f9653a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f69c818b648fb9d44f3807d72f9653a">&#9670;&#160;</a></span>CCC_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_end(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the end sentinel of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the end sentinel.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a2093b0d81c352dc0eb6e85a77a7ee54b" name="a2093b0d81c352dc0eb6e85a77a7ee54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2093b0d81c352dc0eb6e85a77a7ee54b">&#9670;&#160;</a></span>CCC_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_entry(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a container specific entry for the Entry Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a14cb05888afcab07cf9340d20205d2e5" name="a14cb05888afcab07cf9340d20205d2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14cb05888afcab07cf9340d20205d2e5">&#9670;&#160;</a></span>CCC_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_entry_wrap(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a container specific entry for the Entry Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific entry reference depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a248d85f3ebeda74c0ffc4f4e9963f834" name="a248d85f3ebeda74c0ffc4f4e9963f834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248d85f3ebeda74c0ffc4f4e9963f834">&#9670;&#160;</a></span>CCC_equal_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_equal_range</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_equal_range(container_pointer, range_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a range of values from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_args</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a7ccb83ad25525b5fca2019c342dc884e" name="a7ccb83ad25525b5fca2019c342dc884e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccb83ad25525b5fca2019c342dc884e">&#9670;&#160;</a></span>CCC_equal_range_reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_equal_range_reverse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_reverse_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_equal_range_reverse(container_pointer, range_reverse_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a range_reverse of values from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_reverse_args</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range_reverse.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ac1c2982956cb64bf403ab774cef7f84e" name="ac1c2982956cb64bf403ab774cef7f84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c2982956cb64bf403ab774cef7f84e">&#9670;&#160;</a></span>CCC_equal_range_reverse_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_equal_range_reverse_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_reverse_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_equal_range_reverse_wrap(container_pointer, range_reverse_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a range_reverse of values from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_reverse_args</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the range_reverse.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a89d90a64d3237a68c91d2bcfe238f4ea" name="a89d90a64d3237a68c91d2bcfe238f4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d90a64d3237a68c91d2bcfe238f4ea">&#9670;&#160;</a></span>CCC_equal_range_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_equal_range_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_equal_range_wrap(container_pointer, range_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a range of values from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_args</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the range.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a3c596ca5ba4bb73797dd45acbe1e9e7c" name="a3c596ca5ba4bb73797dd45acbe1e9e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c596ca5ba4bb73797dd45acbe1e9e7c">&#9670;&#160;</a></span>CCC_erase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_erase</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">erase_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_erase(container_pointer, erase_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an element known to be in a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">erase_args</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a150014bccd5f183ac0e7ce92c265265c" name="a150014bccd5f183ac0e7ce92c265265c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150014bccd5f183ac0e7ce92c265265c">&#9670;&#160;</a></span>CCC_extract</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_extract</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">extract_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_extract(container_pointer, extract_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract an element known to be in a container (does not free). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">extract_args</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a2abb10512cb2c434e67177ba71c664d3" name="a2abb10512cb2c434e67177ba71c664d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abb10512cb2c434e67177ba71c664d3">&#9670;&#160;</a></span>CCC_extract_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_extract_range</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">extract_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_extract_range(container_pointer, extract_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract elements known to be in a container (does not free). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">extract_args</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a5072ddc807149d24311ff1729a5c1c60" name="a5072ddc807149d24311ff1729a5c1c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5072ddc807149d24311ff1729a5c1c60">&#9670;&#160;</a></span>CCC_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_front(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference the front element of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a user type.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4a81daea52cfe16f59ff00d87015b106" name="a4a81daea52cfe16f59ff00d87015b106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a81daea52cfe16f59ff00d87015b106">&#9670;&#160;</a></span>CCC_get_key_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_get_key_value</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_get_key_value(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the user type stored at the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stored user type or NULL of absent.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ab6eb0d1bbce755e2a7c0358a30ee7890" name="ab6eb0d1bbce755e2a7c0358a30ee7890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6eb0d1bbce755e2a7c0358a30ee7890">&#9670;&#160;</a></span>CCC_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_handle(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a container specific handle for the handle Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="abe611ce746d1d3c4de10eb3151d8e6c2" name="abe611ce746d1d3c4de10eb3151d8e6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe611ce746d1d3c4de10eb3151d8e6c2">&#9670;&#160;</a></span>CCC_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_handle_wrap(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a container specific handle for the handle Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific handle reference depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a540db48ad3c7ad9e4f43f353c932f57f" name="a540db48ad3c7ad9e4f43f353c932f57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540db48ad3c7ad9e4f43f353c932f57f">&#9670;&#160;</a></span>CCC_increase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_increase</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">increase_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_increase(container_pointer, increase_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the value of an element known to be in a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">increase_args</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a68a6ed01f799befd3f56f8f7ad51f8fa" name="a68a6ed01f799befd3f56f8f7ad51f8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a6ed01f799befd3f56f8f7ad51f8fa">&#9670;&#160;</a></span>CCC_insert_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">insert_entry_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_insert_entry(entry_pointer, insert_entry_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert new element or overwrite old element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">insert_entry_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an reference to the inserted element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a0478c724a9aa16943c6515b95a4c5c83" name="a0478c724a9aa16943c6515b95a4c5c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0478c724a9aa16943c6515b95a4c5c83">&#9670;&#160;</a></span>CCC_insert_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_insert_error(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check last insert status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an insert error occurred false if not.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a914a9dd271bd208b15f3e338ceeda842" name="a914a9dd271bd208b15f3e338ceeda842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914a9dd271bd208b15f3e338ceeda842">&#9670;&#160;</a></span>CCC_insert_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">insert_array_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_insert_handle(array_pointer, insert_array_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert new element or overwrite old element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">insert_array_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an reference to the inserted element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ab222e2a29adc86ec865d5f7ceb6151de" name="ab222e2a29adc86ec865d5f7ceb6151de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab222e2a29adc86ec865d5f7ceb6151de">&#9670;&#160;</a></span>CCC_insert_or_assign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_or_assign</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">insert_or_assign_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_insert_or_assign(container_pointer, insert_or_assign_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element or overwrite the Occupied entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">insert_or_assign_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="abf35b886146ce60b1691dff771475f56" name="abf35b886146ce60b1691dff771475f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf35b886146ce60b1691dff771475f56">&#9670;&#160;</a></span>CCC_insert_or_assign_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_or_assign_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">insert_or_assign_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_insert_or_assign_wrap(container_pointer, insert_or_assign_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element or overwrite the Occupied entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">insert_or_assign_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a0c3926a950b876a4ab6a2ca3d5e157a2" name="a0c3926a950b876a4ab6a2ca3d5e157a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3926a950b876a4ab6a2ca3d5e157a2">&#9670;&#160;</a></span>CCC_is_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_is_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_is_empty(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size status of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty or NULL false if not.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a1a2e1d8eb494bca89d88a171b4a3ab5d" name="a1a2e1d8eb494bca89d88a171b4a3ab5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2e1d8eb494bca89d88a171b4a3ab5d">&#9670;&#160;</a></span>CCC_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">void_iterator_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_next(container_pointer, void_iterator_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the next element in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void_iterator_pointer</td><td>the user type returned from the last iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored next.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a98ffeab920e9fb81fb185004e4e22f60" name="a98ffeab920e9fb81fb185004e4e22f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ffeab920e9fb81fb185004e4e22f60">&#9670;&#160;</a></span>CCC_occupied</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_occupied</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_occupied(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check occupancy of entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if Occupied, false if Vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a01abb830338b060bf31dbc61841ecec6" name="a01abb830338b060bf31dbc61841ecec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01abb830338b060bf31dbc61841ecec6">&#9670;&#160;</a></span>CCC_or_insert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_or_insert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">or_insert_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_or_insert(entry_pointer, or_insert_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert new element if the entry is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">or_insert_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an reference to the old element or new element if entry was Vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a17d88484deff770ce7fcfb060c5800bd" name="a17d88484deff770ce7fcfb060c5800bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d88484deff770ce7fcfb060c5800bd">&#9670;&#160;</a></span>CCC_pop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_pop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pop_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_pop(container_pointer, pop_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an element from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_args</td><td>any supplementary args a container may have for the pop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result of the pop operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a9ddf2fb67b4322c8cb48a7ecf09f3115" name="a9ddf2fb67b4322c8cb48a7ecf09f3115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddf2fb67b4322c8cb48a7ecf09f3115">&#9670;&#160;</a></span>CCC_pop_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_pop_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_pop_back(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an element from the back of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result of the pop operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="adc6ea07e914d9bdd03424c39082299e5" name="adc6ea07e914d9bdd03424c39082299e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6ea07e914d9bdd03424c39082299e5">&#9670;&#160;</a></span>CCC_pop_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_pop_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_pop_front(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an element from the front of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result of the pop operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a5b15181bd50f62ae01bf715fd443335b" name="a5b15181bd50f62ae01bf715fd443335b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b15181bd50f62ae01bf715fd443335b">&#9670;&#160;</a></span>CCC_push</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_push</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">push_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_push(container_pointer, push_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an element into a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">push_args</td><td>depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the pushed element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4a97a914557e4d9db0850a729846b41a" name="a4a97a914557e4d9db0850a729846b41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a97a914557e4d9db0850a729846b41a">&#9670;&#160;</a></span>CCC_push_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_push_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">push_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_push_back(container_pointer, push_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an element to the back of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">push_args</td><td>depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the pushed element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a6ea45ab24bcfbdb0867892f5d794cbf7" name="a6ea45ab24bcfbdb0867892f5d794cbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea45ab24bcfbdb0867892f5d794cbf7">&#9670;&#160;</a></span>CCC_push_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_push_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">push_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_push_front(container_pointer, push_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an element to the front of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">push_args</td><td>depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the pushed element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="af1e153edc4d813aeb8fcba9640c53d1a" name="af1e153edc4d813aeb8fcba9640c53d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e153edc4d813aeb8fcba9640c53d1a">&#9670;&#160;</a></span>CCC_range_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_range_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_range_begin(range_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the beginning of the range iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_pointer</td><td>a pointer to the type of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing the beginning. May be equal to end. </dd></dl>

</div>
</div>
<a id="a645dbec6c02190de14248d44ed642412" name="a645dbec6c02190de14248d44ed642412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645dbec6c02190de14248d44ed642412">&#9670;&#160;</a></span>CCC_range_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_range_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_range_end(range_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the end of the range iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_pointer</td><td>a pointer to the type of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing the end. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not access the end. It is an exclusive end. </dd></dl>

</div>
</div>
<a id="ad055a9c9c00366a2fb4f4a5941a47adc" name="ad055a9c9c00366a2fb4f4a5941a47adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad055a9c9c00366a2fb4f4a5941a47adc">&#9670;&#160;</a></span>CCC_range_reverse_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_range_reverse_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_reverse_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_range_reverse_begin(range_reverse_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the beginning of the reverse range iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_reverse_pointer</td><td>a pointer to the type of reverse range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing the reverse beginning. May be equal to reverse end. </dd></dl>

</div>
</div>
<a id="a9cb020bf9603590a7175222e57871291" name="a9cb020bf9603590a7175222e57871291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb020bf9603590a7175222e57871291">&#9670;&#160;</a></span>CCC_range_reverse_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_range_reverse_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_reverse_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_range_reverse_end(range_reverse_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the end of the reverse range iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_reverse_pointer</td><td>a pointer to the type of reverse range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing the reverse end. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not access the end. It is an exclusive reverse end. </dd></dl>

</div>
</div>
<a id="ac207035aea4cbe0c51d16589c2460db4" name="ac207035aea4cbe0c51d16589c2460db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac207035aea4cbe0c51d16589c2460db4">&#9670;&#160;</a></span>CCC_remove_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_remove_entry(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element if the entry is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4e80401338bc7980d63b75bf9c8cc108" name="a4e80401338bc7980d63b75bf9c8cc108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e80401338bc7980d63b75bf9c8cc108">&#9670;&#160;</a></span>CCC_remove_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_remove_entry_wrap(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element if the entry is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a81a9141ace02d75b61a40e78fb070e08" name="a81a9141ace02d75b61a40e78fb070e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a9141ace02d75b61a40e78fb070e08">&#9670;&#160;</a></span>CCC_remove_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_remove_handle(array_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element if the handle is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a8fe3201d00f81e4ef8b5d060086561da" name="a8fe3201d00f81e4ef8b5d060086561da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe3201d00f81e4ef8b5d060086561da">&#9670;&#160;</a></span>CCC_remove_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_remove_handle_wrap(array_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element if the handle is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a0e6fb2903be6f9b91ff9c5e2960ca9ab" name="a0e6fb2903be6f9b91ff9c5e2960ca9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6fb2903be6f9b91ff9c5e2960ca9ab">&#9670;&#160;</a></span>CCC_remove_key_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_key_value</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remove_key_value_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_remove_key_value(container_pointer, remove_key_value_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element and retain access to its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a69ccd33dfe8d3d8281b0ff03e594eeff" name="a69ccd33dfe8d3d8281b0ff03e594eeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ccd33dfe8d3d8281b0ff03e594eeff">&#9670;&#160;</a></span>CCC_remove_key_value_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_key_value_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remove_key_value_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_remove_key_value_wrap(container_pointer, remove_key_value_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element and retain access to its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a716f00ed6954d4ba8ef0e122f7f20e65" name="a716f00ed6954d4ba8ef0e122f7f20e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716f00ed6954d4ba8ef0e122f7f20e65">&#9670;&#160;</a></span>CCC_reserve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_reserve</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_to_add, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_reserve(container_pointer, n_to_add, allocate_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve capacity for n_to_add new elements to be inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_to_add</td><td>the number of elements to add to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate_pointer</td><td>the allocation function to use for resizing if needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a6237dcd969f191f580d65d7fd63be4c5" name="a6237dcd969f191f580d65d7fd63be4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6237dcd969f191f580d65d7fd63be4c5">&#9670;&#160;</a></span>CCC_reverse_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_reverse_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_reverse_begin(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the reversed start of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored at the reversed start.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4e882e40fee89407d607872f31814381" name="a4e882e40fee89407d607872f31814381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e882e40fee89407d607872f31814381">&#9670;&#160;</a></span>CCC_reverse_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_reverse_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_reverse_end(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the reverse_end sentinel of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the reverse_end sentinel.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a1fab7d4aca5df5547f4474095f18b40a" name="a1fab7d4aca5df5547f4474095f18b40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fab7d4aca5df5547f4474095f18b40a">&#9670;&#160;</a></span>CCC_reverse_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_reverse_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">void_iterator_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_reverse_next(container_pointer, void_iterator_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the reverse_next element in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void_iterator_pointer</td><td>the user type returned from the last iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored reverse_next.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a3953bc97751fd7c344b1de5abfbf1ef0" name="a3953bc97751fd7c344b1de5abfbf1ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3953bc97751fd7c344b1de5abfbf1ef0">&#9670;&#160;</a></span>CCC_splice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_splice</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">splice_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_splice(container_pointer, splice_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splice an element from one position to another in the same or a different container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splice_args</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the splice.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a77c929a44614a438a3cb5017473cf7df" name="a77c929a44614a438a3cb5017473cf7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c929a44614a438a3cb5017473cf7df">&#9670;&#160;</a></span>CCC_splice_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_splice_range</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">splice_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_splice_range(container_pointer, splice_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splice a range of elements from one position to another in the same or a different container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splice_args</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the splice.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="af73671786e7614393692a679167bc3f1" name="af73671786e7614393692a679167bc3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73671786e7614393692a679167bc3f1">&#9670;&#160;</a></span>CCC_swap_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_swap_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_swap_entry(container_pointer, swap_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element and obtain the old value if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swap_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="afd92ffb32259626bcad0acdccddc08f8" name="afd92ffb32259626bcad0acdccddc08f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd92ffb32259626bcad0acdccddc08f8">&#9670;&#160;</a></span>CCC_swap_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_swap_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_swap_entry_wrap(container_pointer, swap_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element and obtain the old value if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swap_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="aeec28b1d6ea9caa46c0da63fdbdcb563" name="aeec28b1d6ea9caa46c0da63fdbdcb563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec28b1d6ea9caa46c0da63fdbdcb563">&#9670;&#160;</a></span>CCC_swap_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_swap_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_swap_handle(container_pointer, swap_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element and obtain the old value if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swap_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a3956da2423bcfb44ee90a643375eae9b" name="a3956da2423bcfb44ee90a643375eae9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3956da2423bcfb44ee90a643375eae9b">&#9670;&#160;</a></span>CCC_swap_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_swap_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_swap_handle_wrap(container_pointer, swap_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element and obtain the old value if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swap_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a76b4afddcbface91165a008dfc57d1c3" name="a76b4afddcbface91165a008dfc57d1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b4afddcbface91165a008dfc57d1c3">&#9670;&#160;</a></span>CCC_try_insert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_try_insert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">try_insert_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_try_insert(container_pointer, try_insert_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element if the entry is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">try_insert_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a1fc7cf3c628589c0d1d4cb736ecd8e1d" name="a1fc7cf3c628589c0d1d4cb736ecd8e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc7cf3c628589c0d1d4cb736ecd8e1d">&#9670;&#160;</a></span>CCC_try_insert_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_try_insert_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">try_insert_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_try_insert_wrap(container_pointer, try_insert_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element if the entry is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">try_insert_args</td><td>args depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ab42510f7ed011f774d3549ef3c91d4a2" name="ab42510f7ed011f774d3549ef3c91d4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42510f7ed011f774d3549ef3c91d4a2">&#9670;&#160;</a></span>CCC_unwrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_unwrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_unwrap(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwrap user type in entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid reference if Occupied or NULL if vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a45fcf69f6f0e8084efc272a2e25e5a55" name="a45fcf69f6f0e8084efc272a2e25e5a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fcf69f6f0e8084efc272a2e25e5a55">&#9670;&#160;</a></span>CCC_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_update</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">update_args...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_update(container_pointer, update_args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of an element known to be in a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">update_args</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a8e45c5f2d2e0a1221ce6310dfee7bce5" name="a8e45c5f2d2e0a1221ce6310dfee7bce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e45c5f2d2e0a1221ce6310dfee7bce5">&#9670;&#160;</a></span>CCC_validate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_validate</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_validate(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the invariant statuses of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all invariants hold, false if not.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="traits_8h.html">traits.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
