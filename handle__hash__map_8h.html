<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/handle_hash_map.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('handle__hash__map_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">handle_hash_map.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Handle Hash Map Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;impl/impl_handle_hash_map.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for handle_hash_map.h:</div>
<div class="dyncontent">
<div class="center"><img src="handle__hash__map_8h__incl.png" border="0" usemap="#accc_2handle__hash__map_8h" alt=""/></div>
<map name="accc_2handle__hash__map_8h" id="accc_2handle__hash__map_8h">
<area shape="rect" title="The Handle Hash Map Interface." alt="" coords="145,5,322,31"/>
<area shape="rect" href="impl__handle__hash__map_8h_source.html" title=" " alt="" coords="85,79,259,119"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="113,313,196,339"/>
<area shape="rect" href="buffer_8h.html" title="The Buffer Interface." alt="" coords="113,167,196,192"/>
<area shape="rect" href="impl__types_8h_source.html" title=" " alt="" coords="5,387,144,412"/>
<area shape="rect" href="impl__buffer_8h_source.html" title=" " alt="" coords="85,240,225,265"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="handle__hash__map_8h__dep__incl.png" border="0" usemap="#accc_2handle__hash__map_8hdep" alt=""/></div>
<map name="accc_2handle__hash__map_8hdep" id="accc_2handle__hash__map_8hdep">
<area shape="rect" title="The Handle Hash Map Interface." alt="" coords="5,5,183,31"/>
<area shape="rect" href="impl__traits_8h_source.html" title=" " alt="" coords="13,79,175,104"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="47,152,141,177"/>
</map>
</div>
</div>
<p><a href="handle__hash__map_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Initialize the container with memory, callbacks, and permissions. </p>
</td></tr>
<tr class="memitem:abb335cd1387ba74f9dcaeec52ac2d524"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#abb335cd1387ba74f9dcaeec52ac2d524">ccc_hhm_init</a>(memory_ptr,  hhash_elem_field,  key_field,  hash_fn,  key_eq_fn,  alloc_fn,  aux_data,  capacity)</td></tr>
<tr class="memdesc:abb335cd1387ba74f9dcaeec52ac2d524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a map with a buffer of types at compile time or runtime.  <br /></td></tr>
<tr class="separator:abb335cd1387ba74f9dcaeec52ac2d524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae767eadaaff3130e9ec063088a208a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#ae767eadaaff3130e9ec063088a208a72">ccc_hhm_copy</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *dst, <a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *src, <a class="el" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a> *fn)</td></tr>
<tr class="memdesc:ae767eadaaff3130e9ec063088a208a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the map at source to destination.  <br /></td></tr>
<tr class="separator:ae767eadaaff3130e9ec063088a208a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Membership Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Test membership or obtain references to stored user types directly. </p>
</td></tr>
<tr class="memitem:a0cf2374e80d0919551b45d172f9f6a6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a0cf2374e80d0919551b45d172f9f6a6f">ccc_hhm_as</a>(handle_hash_map_ptr,  type_name,  handle_i...)&#160;&#160;&#160;    ccc_impl_hhm_as(handle_hash_map_ptr, type_name, handle_i)</td></tr>
<tr class="memdesc:a0cf2374e80d0919551b45d172f9f6a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the user type in the table at the handle.  <br /></td></tr>
<tr class="separator:a0cf2374e80d0919551b45d172f9f6a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74181cb95af43a91a511890f984b6015"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a74181cb95af43a91a511890f984b6015">ccc_hhm_at</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *h, <a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a> i)</td></tr>
<tr class="memdesc:a74181cb95af43a91a511890f984b6015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the user data at the provided handle.  <br /></td></tr>
<tr class="separator:a74181cb95af43a91a511890f984b6015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693f710b83bad05005598e99fb15beae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a693f710b83bad05005598e99fb15beae">ccc_hhm_contains</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, void const *key)</td></tr>
<tr class="memdesc:a693f710b83bad05005598e99fb15beae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the table for the presence of key.  <br /></td></tr>
<tr class="separator:a693f710b83bad05005598e99fb15beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad07602c4f4b851c481898f7aad8ab42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#aad07602c4f4b851c481898f7aad8ab42">ccc_hhm_get_key_val</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, void const *key)</td></tr>
<tr class="memdesc:aad07602c4f4b851c481898f7aad8ab42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the element stored at key if present.  <br /></td></tr>
<tr class="separator:aad07602c4f4b851c481898f7aad8ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Handle Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and operate on container entries for efficient queries when non-trivial control flow is needed. A handle is a stable index to data in the table. For the handle hash map a valid handle will always be non-zero. This allows for the user to rely on truthy/falsey logic if needed: this is similar to valid pointers vs the NULL pointer. </p>
</td></tr>
<tr class="memitem:a1ff375316013314c930a36be79cfa944"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a1ff375316013314c930a36be79cfa944">ccc_hhm_swap_handle_r</a>(handle_hash_map_ptr,  out_handle_ptr)</td></tr>
<tr class="memdesc:a1ff375316013314c930a36be79cfa944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value wrapping out_handle_ptr.  <br /></td></tr>
<tr class="separator:a1ff375316013314c930a36be79cfa944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123d46aa6ff5890a21ba4ba26df50f1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a123d46aa6ff5890a21ba4ba26df50f1d">ccc_hhm_remove_r</a>(handle_hash_map_ptr,  out_handle_ptr)</td></tr>
<tr class="memdesc:a123d46aa6ff5890a21ba4ba26df50f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key value in the map storing the old value, if present, in the struct containing out_handle_ptr provided by the user.  <br /></td></tr>
<tr class="separator:a123d46aa6ff5890a21ba4ba26df50f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bab6d51b29c79d3111c73fb2bcd4b32"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a1bab6d51b29c79d3111c73fb2bcd4b32">ccc_hhm_try_insert_r</a>(handle_hash_map_ptr,  key_val_handle_ptr)</td></tr>
<tr class="memdesc:a1bab6d51b29c79d3111c73fb2bcd4b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the key value wrapping key_val_handle_ptr.  <br /></td></tr>
<tr class="separator:a1bab6d51b29c79d3111c73fb2bcd4b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bf02cc8c0b829594b27b7330f97c6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a22bf02cc8c0b829594b27b7330f97c6b">ccc_hhm_try_insert_w</a>(handle_hash_map_ptr,  key,  lazy_value...)</td></tr>
<tr class="memdesc:a22bf02cc8c0b829594b27b7330f97c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">lazily insert lazy_value into the map at key if key is absent.  <br /></td></tr>
<tr class="separator:a22bf02cc8c0b829594b27b7330f97c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bb8759d32ffc1074f6b18f01dcb1cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a96bb8759d32ffc1074f6b18f01dcb1cb">ccc_hhm_insert_or_assign_r</a>(handle_hash_map_ptr,  key_val_handle_ptr)</td></tr>
<tr class="memdesc:a96bb8759d32ffc1074f6b18f01dcb1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts or overwrites a user struct into the table.  <br /></td></tr>
<tr class="separator:a96bb8759d32ffc1074f6b18f01dcb1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7999fd5b09a212593b97ceee5d3e40d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#af7999fd5b09a212593b97ceee5d3e40d">ccc_hhm_insert_or_assign_w</a>(handle_hash_map_ptr,  key,  lazy_value...)</td></tr>
<tr class="memdesc:af7999fd5b09a212593b97ceee5d3e40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new key value pair or overwrites the existing handle.  <br /></td></tr>
<tr class="separator:af7999fd5b09a212593b97ceee5d3e40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873b0cce8cba4b257558cb0c1a9e6403"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a873b0cce8cba4b257558cb0c1a9e6403">ccc_hhm_handle_r</a>(handle_hash_map_ptr,  key_ptr)</td></tr>
<tr class="memdesc:a873b0cce8cba4b257558cb0c1a9e6403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a handle for the provided key in the table for future use.  <br /></td></tr>
<tr class="separator:a873b0cce8cba4b257558cb0c1a9e6403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6f10e3f241a9194a688ad6c4e5bc89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a0a6f10e3f241a9194a688ad6c4e5bc89">ccc_hhm_and_modify_w</a>(handle_hash_map_handle_ptr,  type_name,  closure_over_T...)</td></tr>
<tr class="memdesc:a0a6f10e3f241a9194a688ad6c4e5bc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an Occupied handle with a closure over user type T.  <br /></td></tr>
<tr class="separator:a0a6f10e3f241a9194a688ad6c4e5bc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1896d471a1348491536b9a2e9c1802"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#afa1896d471a1348491536b9a2e9c1802">ccc_hhm_or_insert_w</a>(handle_hash_map_handle_ptr,  lazy_key_value...)&#160;&#160;&#160;    ccc_impl_hhm_or_insert_w(handle_hash_map_handle_ptr, lazy_key_value)</td></tr>
<tr class="memdesc:afa1896d471a1348491536b9a2e9c1802"><td class="mdescLeft">&#160;</td><td class="mdescRight">lazily insert the desired key value into the handle if it is Vacant.  <br /></td></tr>
<tr class="separator:afa1896d471a1348491536b9a2e9c1802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b37fa085ccc5d4ba7ffa87ff03422f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a31b37fa085ccc5d4ba7ffa87ff03422f">ccc_hhm_insert_handle_w</a>(handle_hash_map_handle_ptr,  lazy_key_value...)&#160;&#160;&#160;    ccc_impl_hhm_insert_handle_w(handle_hash_map_handle_ptr, lazy_key_value)</td></tr>
<tr class="memdesc:a31b37fa085ccc5d4ba7ffa87ff03422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the contents of the compound literal lazy_key_value to a slot.  <br /></td></tr>
<tr class="separator:a31b37fa085ccc5d4ba7ffa87ff03422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e21604219d3d5a9f735c712b26de97c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a5e21604219d3d5a9f735c712b26de97c">ccc_hhm_remove_handle_r</a>(handle_hash_map_handle_ptr)</td></tr>
<tr class="memdesc:a5e21604219d3d5a9f735c712b26de97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the handle from the table if Occupied.  <br /></td></tr>
<tr class="separator:a5e21604219d3d5a9f735c712b26de97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ca65d28a878aefbcdec6ef0bb8542a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a45ca65d28a878aefbcdec6ef0bb8542a">ccc_hhm_swap_handle</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, <a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *out_handle)</td></tr>
<tr class="memdesc:a45ca65d28a878aefbcdec6ef0bb8542a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value wrapping out_handle.  <br /></td></tr>
<tr class="separator:a45ca65d28a878aefbcdec6ef0bb8542a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24904ef98014c83cb63e20ed5c6ca435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a24904ef98014c83cb63e20ed5c6ca435">ccc_hhm_remove</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, <a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *out_handle)</td></tr>
<tr class="memdesc:a24904ef98014c83cb63e20ed5c6ca435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key value in the map storing the old value, if present, in the struct containing out_handle provided by the user.  <br /></td></tr>
<tr class="separator:a24904ef98014c83cb63e20ed5c6ca435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e70af2b96548b877c42f1f5151e2757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a0e70af2b96548b877c42f1f5151e2757">ccc_hhm_try_insert</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, <a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *key_val_handle)</td></tr>
<tr class="memdesc:a0e70af2b96548b877c42f1f5151e2757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the key value wrapping key_val_handle.  <br /></td></tr>
<tr class="separator:a0e70af2b96548b877c42f1f5151e2757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4991835a59211de8789d7d80cebf16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#ab4991835a59211de8789d7d80cebf16c">ccc_hhm_insert_or_assign</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, <a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *key_val_handle)</td></tr>
<tr class="memdesc:ab4991835a59211de8789d7d80cebf16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts or overwrites a user struct into the table.  <br /></td></tr>
<tr class="separator:ab4991835a59211de8789d7d80cebf16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1afbc46e29148242823c839ef4d57c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#ae1afbc46e29148242823c839ef4d57c0">ccc_hhm_handle</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, void const *key)</td></tr>
<tr class="memdesc:ae1afbc46e29148242823c839ef4d57c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a handle for the provided key in the table for future use.  <br /></td></tr>
<tr class="separator:ae1afbc46e29148242823c839ef4d57c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41628dc82bbd17d6a8c6e94aad8e0be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a41628dc82bbd17d6a8c6e94aad8e0be4">ccc_hhm_and_modify</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> *e, <a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *fn)</td></tr>
<tr class="memdesc:a41628dc82bbd17d6a8c6e94aad8e0be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the provided handle if it is Occupied.  <br /></td></tr>
<tr class="separator:a41628dc82bbd17d6a8c6e94aad8e0be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc5398c178215af243ae7c861c59bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#acdc5398c178215af243ae7c861c59bd1">ccc_hhm_and_modify_aux</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> *e, <a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *fn, void *aux)</td></tr>
<tr class="memdesc:acdc5398c178215af243ae7c861c59bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the provided handle if it is Occupied.  <br /></td></tr>
<tr class="separator:acdc5398c178215af243ae7c861c59bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333ab1765e9a21313707f19197bd6e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a333ab1765e9a21313707f19197bd6e88">ccc_hhm_or_insert</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *e, <a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *elem)</td></tr>
<tr class="memdesc:a333ab1765e9a21313707f19197bd6e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the struct with handle elem if the handle is Vacant.  <br /></td></tr>
<tr class="separator:a333ab1765e9a21313707f19197bd6e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d64becb61483c4385f443330a8f9e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a03d64becb61483c4385f443330a8f9e4">ccc_hhm_insert_handle</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *e, <a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *elem)</td></tr>
<tr class="memdesc:a03d64becb61483c4385f443330a8f9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the provided handle invariantly.  <br /></td></tr>
<tr class="separator:a03d64becb61483c4385f443330a8f9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23730aa5dd43c7435a3d294b1962aa17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a23730aa5dd43c7435a3d294b1962aa17">ccc_hhm_remove_handle</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *e)</td></tr>
<tr class="memdesc:a23730aa5dd43c7435a3d294b1962aa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the handle from the table if Occupied.  <br /></td></tr>
<tr class="separator:a23730aa5dd43c7435a3d294b1962aa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8972f9155488aceb79f123369c6d8a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a8972f9155488aceb79f123369c6d8a3b">ccc_hhm_unwrap</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *e)</td></tr>
<tr class="memdesc:a8972f9155488aceb79f123369c6d8a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps the provided handle to obtain a handle index.  <br /></td></tr>
<tr class="separator:a8972f9155488aceb79f123369c6d8a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5786c9956b4cbe445be02175a725ba03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a5786c9956b4cbe445be02175a725ba03">ccc_hhm_occupied</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *e)</td></tr>
<tr class="memdesc:a5786c9956b4cbe445be02175a725ba03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vacant or Occupied status of the handle.  <br /></td></tr>
<tr class="separator:a5786c9956b4cbe445be02175a725ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8595750d470db2db828249f1db42f7ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a8595750d470db2db828249f1db42f7ca">ccc_hhm_insert_error</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *e)</td></tr>
<tr class="memdesc:a8595750d470db2db828249f1db42f7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the status of the handle should an insertion follow.  <br /></td></tr>
<tr class="separator:a8595750d470db2db828249f1db42f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44585be1a06764cf2575e06e6e043d5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a546d4339d75e7b144c85d3e54a841c1b">ccc_handle_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a44585be1a06764cf2575e06e6e043d5d">ccc_hhm_handle_status</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *e)</td></tr>
<tr class="memdesc:a44585be1a06764cf2575e06e6e043d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the handle status from a container handle.  <br /></td></tr>
<tr class="separator:a44585be1a06764cf2575e06e6e043d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Types available in the container interface. </p>
</td></tr>
<tr class="memitem:a324f061240f66cf5dc986a70d1450d6a"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_hhmap_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a></td></tr>
<tr class="memdesc:a324f061240f66cf5dc986a70d1450d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for storing key-value structures defined by the user in a contiguous buffer.  <br /></td></tr>
<tr class="separator:a324f061240f66cf5dc986a70d1450d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c4d64e3bc464cbffa19bff2570bc5e"><td class="memItemLeft" align="right" valign="top">typedef struct ccc_hhmap_elem_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a></td></tr>
<tr class="memdesc:a42c4d64e3bc464cbffa19bff2570bc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive element for a user provided type.  <br /></td></tr>
<tr class="separator:a42c4d64e3bc464cbffa19bff2570bc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa704eacdada6f1862c6e8ffd3e5d4b4"><td class="memItemLeft" align="right" valign="top">typedef union ccc_hhmap_handle_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a></td></tr>
<tr class="memdesc:afa704eacdada6f1862c6e8ffd3e5d4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container specific handle used to implement the Handle Interface.  <br /></td></tr>
<tr class="separator:afa704eacdada6f1862c6e8ffd3e5d4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Destroy the container. </p>
</td></tr>
<tr class="memitem:a4d99b3117dd723d3666340c024a858d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a4d99b3117dd723d3666340c024a858d4">ccc_hhm_clear</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, <a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *fn)</td></tr>
<tr class="memdesc:a4d99b3117dd723d3666340c024a858d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the table for use without affecting capacity.  <br /></td></tr>
<tr class="separator:a4d99b3117dd723d3666340c024a858d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cf00089c4ff2886246eca9c00108a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a81cf00089c4ff2886246eca9c00108a6">ccc_hhm_clear_and_free</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *h, <a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *fn)</td></tr>
<tr class="memdesc:a81cf00089c4ff2886246eca9c00108a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all slots in the table and frees the underlying buffer.  <br /></td></tr>
<tr class="separator:a81cf00089c4ff2886246eca9c00108a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iterator Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and manage iterators over the container. </p>
</td></tr>
<tr class="memitem:ac42b4434ccfffa6028d69f8db783f485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#ac42b4434ccfffa6028d69f8db783f485">ccc_hhm_begin</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *h)</td></tr>
<tr class="memdesc:ac42b4434ccfffa6028d69f8db783f485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a handle to the first element in the table.  <br /></td></tr>
<tr class="separator:ac42b4434ccfffa6028d69f8db783f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18daddb4fb75651d276d3d3067214a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a18daddb4fb75651d276d3d3067214a66">ccc_hhm_next</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> *iter)</td></tr>
<tr class="memdesc:a18daddb4fb75651d276d3d3067214a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator to the next occupied table handle.  <br /></td></tr>
<tr class="separator:a18daddb4fb75651d276d3d3067214a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d86d87aa8f109cdf6117e46f454ee9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#af6d86d87aa8f109cdf6117e46f454ee9">ccc_hhm_end</a> (<a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *iter)</td></tr>
<tr class="memdesc:af6d86d87aa8f109cdf6117e46f454ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current handle iterator has reached the end.  <br /></td></tr>
<tr class="separator:af6d86d87aa8f109cdf6117e46f454ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain the container state. </p>
</td></tr>
<tr class="memitem:a0a8b935f196f9e252c9c92044f46156d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a0a8b935f196f9e252c9c92044f46156d">ccc_hhm_is_empty</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *h)</td></tr>
<tr class="memdesc:a0a8b935f196f9e252c9c92044f46156d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size status of the table.  <br /></td></tr>
<tr class="separator:a0a8b935f196f9e252c9c92044f46156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d8065345ebaee760c1243e974509b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#ac30d8065345ebaee760c1243e974509b">ccc_hhm_size</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *h)</td></tr>
<tr class="memdesc:ac30d8065345ebaee760c1243e974509b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the table.  <br /></td></tr>
<tr class="separator:ac30d8065345ebaee760c1243e974509b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d20e1fe5d14fbed0a3899d1a1ab8d3b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a1d20e1fe5d14fbed0a3899d1a1ab8d3b">ccc_hhm_next_prime</a> (size_t n)</td></tr>
<tr class="memdesc:a1d20e1fe5d14fbed0a3899d1a1ab8d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to find a prime number if needed.  <br /></td></tr>
<tr class="separator:a1d20e1fe5d14fbed0a3899d1a1ab8d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e5ec3344c99e9d12ec660208ee5bec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#ac1e5ec3344c99e9d12ec660208ee5bec">ccc_hhm_capacity</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *h)</td></tr>
<tr class="memdesc:ac1e5ec3344c99e9d12ec660208ee5bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full capacity of the backing storage.  <br /></td></tr>
<tr class="separator:ac1e5ec3344c99e9d12ec660208ee5bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52402c5061058f672136740d71c30ab9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#a52402c5061058f672136740d71c30ab9">ccc_hhm_data</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *h)</td></tr>
<tr class="memdesc:a52402c5061058f672136740d71c30ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the base of backing array. O(1).  <br /></td></tr>
<tr class="separator:a52402c5061058f672136740d71c30ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5885da292b6f1129ce96762bc65560"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="handle__hash__map_8h.html#acb5885da292b6f1129ce96762bc65560">ccc_hhm_validate</a> (<a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *h)</td></tr>
<tr class="memdesc:acb5885da292b6f1129ce96762bc65560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validation of invariants for the hash table.  <br /></td></tr>
<tr class="separator:acb5885da292b6f1129ce96762bc65560"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Handle Hash Map Interface. </p>
<p>A Handle Hash Map stores elements by hash value and allows the user to retrieve them by key in amortized O(1) while offering handle stability. A handle is an index into a slot of the table where the user data is originally placed upon insertion. It is guaranteed to remain in the same slot until deletion, even if the table is resized by subsequent insertions or deletions of other elements occur. This comes at a slight space and implementation complexity cost when compared to the standard flat hash map offered in the collection, especially during resizing operations. However, it is more beneficial for large structs and fixed table sizes to use this version. The benefits are that when the handles exposed in the interface are saved by the user they offer the similar guarantees as pointer stability except with the benefits of tightly grouped data in one array accessed via index.</p>
<p>For containers in this collection the user may have a variety of memory sources backing the containers. This container aims to be an equivalent stand in for std::unordered_map, absl::node_hash_map, or manually managing pointers in a flat hash map under the constraints of the C Container Collection. Instead of forcing the user to manage separate allocations for nodes that need to remain in the same location, this container will ensure any inserted element remains at the same index in the table allowing complex container compositions and any underlying source of memory specified at compile time or runtime. This container therefore exposes an interface that mainly returns stable handle indices and these should be what the user stores and accesses when needed. Only expose the underlying pointer to data with the provided access function when needed and store the handle for all other purposes.</p>
<p>A handle hash map requires the user to provide a struct with known key and handle hash element fields as well as a hash function and key comparator function. The hash function should be well tailored to the key being stored in the table to prevent collisions. Currently, the handle hash map does not offer any default hash functions or hash strengthening algorithms so strong hash functions should be obtained by the user for the data set.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define HANDLE_HASH_MAP_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>ccc_</code> prefix. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a0a6f10e3f241a9194a688ad6c4e5bc89" name="a0a6f10e3f241a9194a688ad6c4e5bc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6f10e3f241a9194a688ad6c4e5bc89">&#9670;&#160;</a></span>ccc_hhm_and_modify_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_and_modify_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_handle_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">closure_over_T...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a>)                                                        \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_impl_hhm_and_modify_w(handle_hash_map_handle_ptr, type_name,       \</div>
<div class="line">                                  closure_over_T)                              \</div>
<div class="line">    }</div>
<div class="ttc" id="ahandle__hash__map_8h_html_afa704eacdada6f1862c6e8ffd3e5d4b4"><div class="ttname"><a href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a></div><div class="ttdeci">union ccc_hhmap_handle_ ccc_hhmap_handle</div><div class="ttdoc">A container specific handle used to implement the Handle Interface.</div><div class="ttdef"><b>Definition:</b> handle_hash_map.h:77</div></div>
</div><!-- fragment -->
<p>Modify an Occupied handle with a closure over user type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_handle_ptr</td><td>a pointer to the obtained handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the name of the user type stored in the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">closure_over_T</td><td>the code to be run on the handle to user type T, if Occupied. This may be a semicolon separated list of statements to execute on T or a section of code wrapped in braces {code here} which may be preferred for formatting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal handle to the modified handle if it was occupied or a vacant handle if it was vacant. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>T is a handle to the user type stored in the handle guaranteed to be non-NULL if the closure executes.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#define handle_hash_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="comment">// Increment the key k if found otherwise do nothing.</span></div>
<div class="line">hhmap_handle *e = hhm_and_modify_w(handle_r(&amp;hhm, &amp;k), word, T-&gt;cnt++;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Increment the key k if found otherwise insert a default value.</span></div>
<div class="line">handle_i w = hhm_or_insert_w(hhm_and_modify_w(handle_r(&amp;hhm, &amp;k), word,</div>
<div class="line">                                              { T-&gt;cnt++; }),</div>
<div class="line">                             (word){.key = k, .cnt = 1});</div>
</div><!-- fragment --><p>Note that any code written is only evaluated if the handle is Occupied and the container can deliver the user type T. This means any function calls are lazily evaluated in the closure scope. </p>

</div>
</div>
<a id="a0cf2374e80d0919551b45d172f9f6a6f" name="a0cf2374e80d0919551b45d172f9f6a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf2374e80d0919551b45d172f9f6a6f">&#9670;&#160;</a></span>ccc_hhm_as</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_as</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_i...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_hhm_as(handle_hash_map_ptr, type_name, handle_i)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the user type in the table at the handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_ptr</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>name of the user type stored in each slot of the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_i</td><td>the index handle obtained from previous map operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the handle at handle in the map as the type the user has stored in the map. </dd></dl>

</div>
</div>
<a id="a873b0cce8cba4b257558cb0c1a9e6403" name="a873b0cce8cba4b257558cb0c1a9e6403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873b0cce8cba4b257558cb0c1a9e6403">&#9670;&#160;</a></span>ccc_hhm_handle_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_handle_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a>)                                                        \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_hhm_handle((handle_hash_map_ptr), (key_ptr)).impl_                 \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Obtains a handle for the provided key in the table for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_ptr</td><td>the hash table to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_ptr</td><td>the key used to search the table matching the stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal handle to a specialized hash handle for use with other functions in the Handle Interface. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the contents of a handle should not be examined or modified. Use the provided functions, only.</dd></dl>
<p>A handle is a search result that provides either an Occupied or Vacant handle in the table. An occupied handle signifies that the search was successful. A Vacant handle means the search was not successful but we now have a handle to where in the table such an element should be inserted.</p>
<p>A handle is most often passed in a functional style to subsequent calls in the Handle Interface. </p>

</div>
</div>
<a id="abb335cd1387ba74f9dcaeec52ac2d524" name="abb335cd1387ba74f9dcaeec52ac2d524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb335cd1387ba74f9dcaeec52ac2d524">&#9670;&#160;</a></span>ccc_hhm_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memory_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hhash_elem_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_eq_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alloc_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">aux_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ccc_impl_hhm_init(memory_ptr, hhash_elem_field, key_field, hash_fn,        \</div>
<div class="line">                      key_eq_fn, alloc_fn, aux_data, capacity)</div>
</div><!-- fragment -->
<p>Initialize a map with a buffer of types at compile time or runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memory_ptr</td><td>the pointer to the backing buffer array of user types. May be NULL if the user provides a allocation function. The buffer will be interpreted in units of type size that the user intends to store. buffer is provided and an allocation function is given. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hhash_elem_field</td><td>the name of the hhmap_elem field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_field</td><td>the field of the struct used for key storage. resizing is allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_fn</td><td>the ccc_hash_fn function the user desires for the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_eq_fn</td><td>the ccc_key_eq_fn the user intends to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_fn</td><td>the allocation function for resizing or NULL if no </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux_data</td><td>auxiliary data that is needed for hashing or comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the starting capacity of the provided buffer or 0 if no </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle hash map directly initialized on the right hand side of the equality operator (i.e. ccc_handle_hash_map fh = <a class="el" href="handle__hash__map_8h.html#abb335cd1387ba74f9dcaeec52ac2d524" title="Initialize a map with a buffer of types at compile time or runtime.">ccc_hhm_init(...)</a>;) </dd></dl>

</div>
</div>
<a id="a31b37fa085ccc5d4ba7ffa87ff03422f" name="a31b37fa085ccc5d4ba7ffa87ff03422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b37fa085ccc5d4ba7ffa87ff03422f">&#9670;&#160;</a></span>ccc_hhm_insert_handle_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_insert_handle_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_handle_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_key_value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_hhm_insert_handle_w(handle_hash_map_handle_ptr, lazy_key_value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the contents of the compound literal lazy_key_value to a slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_handle_ptr</td><td>a pointer to the obtained handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_key_value</td><td>the compound literal to write to a new slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-zero handle to the newly inserted or overwritten user type. 0 is returned if resizing is required but fails or is not allowed. </dd></dl>

</div>
</div>
<a id="a96bb8759d32ffc1074f6b18f01dcb1cb" name="a96bb8759d32ffc1074f6b18f01dcb1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bb8759d32ffc1074f6b18f01dcb1cb">&#9670;&#160;</a></span>ccc_hhm_insert_or_assign_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_insert_or_assign_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_val_handle_ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#ac028e04a12f65503490708cd1f5d69ba">ccc_handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_hhm_insert_or_assign((handle_hash_map_ptr), (key_val_handle))      \</div>
<div class="line">            .impl_                                                             \</div>
<div class="line">    }</div>
<div class="ttc" id="atraits_8h_html_ac028e04a12f65503490708cd1f5d69ba"><div class="ttname"><a href="traits_8h.html#ac028e04a12f65503490708cd1f5d69ba">ccc_handle</a></div><div class="ttdeci">#define ccc_handle(container_ptr, key_ptr...)</div><div class="ttdoc">Obtain a container specific handle for the handle Interface.</div><div class="ttdef"><b>Definition:</b> traits.h:135</div></div>
</div><!-- fragment -->
<p>Invariantly inserts or overwrites a user struct into the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_ptr</td><td>a pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle_ptr</td><td>the handle to the wrapping user struct key value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal handle to the current table element. If Occupied a handle was overwritten by the new key value. If Vacant no prior table handle existed.</dd></dl>
<p>Note that this function can be used when the old user type is not needed but the information regarding its presence is helpful. </p>

</div>
</div>
<a id="af7999fd5b09a212593b97ceee5d3e40d" name="af7999fd5b09a212593b97ceee5d3e40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7999fd5b09a212593b97ceee5d3e40d">&#9670;&#160;</a></span>ccc_hhm_insert_or_assign_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_insert_or_assign_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#ac028e04a12f65503490708cd1f5d69ba">ccc_handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_impl_hhm_insert_or_assign_w(handle_hash_map_ptr, key, lazy_value)  \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a new key value pair or overwrites the existing handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_ptr</td><td>the pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key to be searched in the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_value</td><td>the compound literal to insert or use for overwrite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal handle to the handle of the existing or newly inserted value. Occupied indicates the key existed, Vacant indicates the key was absent. Unwrapping in any case provides the current value unless an error occurs that prevents insertion. An insertion error will flag such a case.</dd></dl>
<p>Note that for brevity and convenience the user need not write the key to the lazy value compound literal as well. This function ensures the key in the compound literal matches the searched key. </p>

</div>
</div>
<a id="afa1896d471a1348491536b9a2e9c1802" name="afa1896d471a1348491536b9a2e9c1802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1896d471a1348491536b9a2e9c1802">&#9670;&#160;</a></span>ccc_hhm_or_insert_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_or_insert_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_handle_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_key_value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_hhm_or_insert_w(handle_hash_map_handle_ptr, lazy_key_value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lazily insert the desired key value into the handle if it is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_handle_ptr</td><td>a pointer to the obtained handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_key_value</td><td>the compound literal to construct in place if the handle is Vacant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-zero handle index to the unwrapped user type in the handle, either the unmodified handle if the handle was Occupied or the newly inserted element if the handle was Vacant. 0 is returned if resizing is required but fails or is not allowed.</dd></dl>
<p>Note that if the compound literal uses any function calls to generate values or other data, such functions will not be called if the handle is Occupied. </p>

</div>
</div>
<a id="a5e21604219d3d5a9f735c712b26de97c" name="a5e21604219d3d5a9f735c712b26de97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e21604219d3d5a9f735c712b26de97c">&#9670;&#160;</a></span>ccc_hhm_remove_handle_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_remove_handle_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_handle_ptr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#ac028e04a12f65503490708cd1f5d69ba">ccc_handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_hhm_remove_handle((handle_hash_map_handle_ptr)).impl_              \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the handle from the table if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_handle_ptr</td><td>a pointer to the table handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle containing 0. If Occupied a handle in the table existed and was removed. If Vacant, no prior handle existed to be removed.</dd></dl>
<p>If the old table element is needed see the remove method. </p>

</div>
</div>
<a id="a123d46aa6ff5890a21ba4ba26df50f1d" name="a123d46aa6ff5890a21ba4ba26df50f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123d46aa6ff5890a21ba4ba26df50f1d">&#9670;&#160;</a></span>ccc_hhm_remove_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_remove_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_handle_ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#ac028e04a12f65503490708cd1f5d69ba">ccc_handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_hhm_remove((handle_hash_map_ptr), (out_handle_ptr)).impl_          \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Removes the key value in the map storing the old value, if present, in the struct containing out_handle_ptr provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_ptr</td><td>the pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_handle_ptr</td><td>the handle to the user type wrapping hhash elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal handle handle with a status indicating if the element searched existed and has been removed from the table. Unwrapping will result in NULL. If an old element existed it is copied to the struct wrapping out_handle_ptr.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in a handle to provide information about the old value. </p>

</div>
</div>
<a id="a1ff375316013314c930a36be79cfa944" name="a1ff375316013314c930a36be79cfa944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff375316013314c930a36be79cfa944">&#9670;&#160;</a></span>ccc_hhm_swap_handle_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_swap_handle_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_handle_ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#ac028e04a12f65503490708cd1f5d69ba">ccc_handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_hhm_swap_handle((handle_hash_map_ptr), (out_handle_ptr)).impl_     \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invariantly inserts the key value wrapping out_handle_ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_ptr</td><td>the pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_handle_ptr</td><td>the handle to the user type wrapping hhash elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal handle to the handle. If Vacant, no prior element with key existed and the type wrapping out_handle_ptr remains unchanged. If Occupied the old value is written to the type wrapping out_handle_ptr. If more space is needed but allocation fails or has been forbidden, an insert error is set.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function may write to the struct containing the second parameter. </dd></dl>

</div>
</div>
<a id="a1bab6d51b29c79d3111c73fb2bcd4b32" name="a1bab6d51b29c79d3111c73fb2bcd4b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bab6d51b29c79d3111c73fb2bcd4b32">&#9670;&#160;</a></span>ccc_hhm_try_insert_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_try_insert_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_val_handle_ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#ac028e04a12f65503490708cd1f5d69ba">ccc_handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_hhm_try_insert((handle_hash_map_ptr), (key_val_handle_ptr)).impl_  \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Attempts to insert the key value wrapping key_val_handle_ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_ptr</td><td>the pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle_ptr</td><td>the handle to the user type wrapping hhash elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal handle to the handle. If Occupied, the handle contains a handle to the key value user type in the table and may be unwrapped. If Vacant the handle contains a handle to the newly inserted element in the table. If more space is needed but allocation fails or has been forbidden, an insert error is set. </dd></dl>

</div>
</div>
<a id="a22bf02cc8c0b829594b27b7330f97c6b" name="a22bf02cc8c0b829594b27b7330f97c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bf02cc8c0b829594b27b7330f97c6b">&#9670;&#160;</a></span>ccc_hhm_try_insert_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_hhm_try_insert_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle_hash_map_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#ac028e04a12f65503490708cd1f5d69ba">ccc_handle</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_impl_hhm_try_insert_w(handle_hash_map_ptr, key, lazy_value)        \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>lazily insert lazy_value into the map at key if key is absent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_hash_map_ptr</td><td>a pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the direct key r-value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_value</td><td>the compound literal specifying the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal handle to the handle of the existing or newly inserted value. Occupied indicates the key existed, Vacant indicates the key was absent. Unwrapping in any case provides the current value unless an error occurs that prevents insertion. An insertion error will flag such a case. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ensure the key type matches the type stored in table as the key. For example, if the key is of type <code>int</code> and a <code>size_t</code> is passed as the variable to the key argument, adjacent bytes of the struct will be overwritten.</dd></dl>
<p>Note that for brevity and convenience the user need not write the key to the lazy value compound literal as well. This function ensures the key in the compound literal matches the searched key. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a324f061240f66cf5dc986a70d1450d6a" name="a324f061240f66cf5dc986a70d1450d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324f061240f66cf5dc986a70d1450d6a">&#9670;&#160;</a></span>ccc_handle_hash_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_hhmap_ <a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container for storing key-value structures defined by the user in a contiguous buffer. </p>
<p>A handle hash map can be initialized on the stack, heap, or data segment at runtime or compile time. </p>

</div>
</div>
<a id="a42c4d64e3bc464cbffa19bff2570bc5e" name="a42c4d64e3bc464cbffa19bff2570bc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c4d64e3bc464cbffa19bff2570bc5e">&#9670;&#160;</a></span>ccc_hhmap_elem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ccc_hhmap_elem_ <a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An intrusive element for a user provided type. </p>
<p>Because the hash map is flat, data is always copied from the provided type into the table. </p>

</div>
</div>
<a id="afa704eacdada6f1862c6e8ffd3e5d4b4" name="afa704eacdada6f1862c6e8ffd3e5d4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa704eacdada6f1862c6e8ffd3e5d4b4">&#9670;&#160;</a></span>ccc_hhmap_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union ccc_hhmap_handle_ <a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container specific handle used to implement the Handle Interface. </p>
<p>The Handle Interface offers efficient search and subsequent insertion, deletion, or value update based on the needs of the user. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a41628dc82bbd17d6a8c6e94aad8e0be4" name="a41628dc82bbd17d6a8c6e94aad8e0be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41628dc82bbd17d6a8c6e94aad8e0be4">&#9670;&#160;</a></span>ccc_hhm_and_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> * ccc_hhm_and_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the provided handle if it is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the handle obtained from a handle function or macro. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>an update function in which the auxiliary argument is unused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated handle if it was Occupied or the unmodified vacant handle.</dd></dl>
<p>This function is intended to make the function chaining in the Handle Interface more succinct if the handle will be modified in place based on its own value without the need of the auxiliary argument a ccc_update_fn can provide. </p>

</div>
</div>
<a id="acdc5398c178215af243ae7c861c59bd1" name="acdc5398c178215af243ae7c861c59bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc5398c178215af243ae7c861c59bd1">&#9670;&#160;</a></span>ccc_hhm_and_modify_aux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> * ccc_hhm_and_modify_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the provided handle if it is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the handle obtained from a handle function or macro. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>an update function that requires auxiliary data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>auxiliary data required for the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated handle if it was Occupied or the unmodified vacant handle.</dd></dl>
<p>This function makes full use of a ccc_update_fn capability, meaning a complete ccc_update object will be passed to the update function callback. </p>

</div>
</div>
<a id="a74181cb95af43a91a511890f984b6015" name="a74181cb95af43a91a511890f984b6015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74181cb95af43a91a511890f984b6015">&#9670;&#160;</a></span>ccc_hhm_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_hhm_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the user data at the provided handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>a pointer to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the stable handle obtained by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type stored at the specified handle or NULL if an out of range handle or handle representing no data is provided. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this function can only check if the handle value is in range. If a handle represents a slot that has been taken by a new element because the old one has been removed that new element data will be returned. </dd>
<dd>
do not try to access data in the table manually with a handle. Always use this provided interface function when a reference to data is needed. </dd></dl>

</div>
</div>
<a id="ac42b4434ccfffa6028d69f8db783f485" name="ac42b4434ccfffa6028d69f8db783f485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42b4434ccfffa6028d69f8db783f485">&#9670;&#160;</a></span>ccc_hhm_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> ccc_hhm_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a handle to the first element in the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the table to iterate through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific handle that interface functions will accept. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>erasing or inserting during iteration may result in repeating or unexpected iteration orders.</dd></dl>
<p>Iteration starts from index 0 by capacity of the table so iteration order is not obvious to the user, nor should any specific order be relied on. </p>

</div>
</div>
<a id="ac1e5ec3344c99e9d12ec660208ee5bec" name="ac1e5ec3344c99e9d12ec660208ee5bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e5ec3344c99e9d12ec660208ee5bec">&#9670;&#160;</a></span>ccc_hhm_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_hhm_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the full capacity of the backing storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity. </dd></dl>

</div>
</div>
<a id="a4d99b3117dd723d3666340c024a858d4" name="a4d99b3117dd723d3666340c024a858d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d99b3117dd723d3666340c024a858d4">&#9670;&#160;</a></span>ccc_hhm_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_hhm_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the table for use without affecting capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the table to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the table before their slots are forfeit.</td></tr>
  </table>
  </dd>
</dl>
<p>If NULL is passed as the destructor function time is O(1), else O(capacity). </p>

</div>
</div>
<a id="a81cf00089c4ff2886246eca9c00108a6" name="a81cf00089c4ff2886246eca9c00108a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cf00089c4ff2886246eca9c00108a6">&#9670;&#160;</a></span>ccc_hhm_clear_and_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_hhm_clear_and_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all slots in the table and frees the underlying buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the table to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the destructor for each element. NULL can be passed if no maintenance is required on the elements in the table before their slots are forfeit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of free operation. If no alloc function is provided it is an error to attempt to free the buffer and a memory error is returned. Otherwise, an OK result is returned. </dd></dl>

</div>
</div>
<a id="a693f710b83bad05005598e99fb15beae" name="a693f710b83bad05005598e99fb15beae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693f710b83bad05005598e99fb15beae">&#9670;&#160;</a></span>ccc_hhm_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_hhm_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the table for the presence of key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the handle hash table to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>pointer to the key matching the key type of the user struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the struct containing key is stored, false if not. </dd></dl>

</div>
</div>
<a id="ae767eadaaff3130e9ec063088a208a72" name="ae767eadaaff3130e9ec063088a208a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae767eadaaff3130e9ec063088a208a72">&#9670;&#160;</a></span>ccc_hhm_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_hhm_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8be6e2d1b150a5b77b2eba5ae85764f2">ccc_alloc_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the map at source to destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>the initialized destination for the copy of the src map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the initialized source of the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the optional allocation function if resizing is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the copy operation. If the destination capacity is less than the source capacity and no allocation function is provided an input error is returned. If resizing is required and resizing of dst fails a memory error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>dst must have capacity greater than or equal to src. If dst capacity is less than src, an allocation function must be provided with the fn argument. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the stable handles to user data in src will not remain the same as those in dst if dst has a capacity greater than src. However, after the initial copy to dst the handles in dst are now stable at their current positions.</dd></dl>
<p>Note that there are two ways to copy data from source to destination: provide sufficient memory and pass NULL as fn, or allow the copy function to take care of allocation for the copy.</p>
<p>Manual memory management with no allocation function provided.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define handle_hash_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>val</div>
<div class="line">{</div>
<div class="line">    hhmap_elem e;</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> handle_hash_map src</div>
<div class="line">    = hhm_init((<span class="keyword">static</span> <span class="keyword">struct</span> val[11]){}, e, key, hhmap_int_to_u64,</div>
<div class="line">               hhmap_id_eq, NULL, NULL, 11);</div>
<div class="line">insert_rand_vals(&amp;src);</div>
<div class="line"><span class="keyword">static</span> handle_hash_map dst</div>
<div class="line">    = hhm_init((<span class="keyword">static</span> <span class="keyword">struct</span> val[13]){}, e, key, hhmap_int_to_u64,</div>
<div class="line">               hhmap_id_eq, NULL, NULL, 13);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> res = hhm_copy(&amp;dst, &amp;src, NULL);</div>
<div class="ttc" id="atypes_8h_html_a1493dc76581f8c71eb96202fb1671ae1"><div class="ttname"><a href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a></div><div class="ttdeci">ccc_result</div><div class="ttdoc">A result of actions on containers.</div><div class="ttdef"><b>Definition:</b> types.h:115</div></div>
</div><!-- fragment --><p>The above requires dst capacity be greater than or equal to src capacity. Here is memory management handed over to the copy function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define handle_hash_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>val</div>
<div class="line">{</div>
<div class="line">    hhmap_elem e;</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> handle_hash_map src</div>
<div class="line">    = hhm_init((<span class="keyword">struct</span> val*)NULL, e, key, hhmap_int_to_u64, hhmap_id_eq,</div>
<div class="line">               NULL, 0);</div>
<div class="line">insert_rand_vals(&amp;src);</div>
<div class="line"><span class="keyword">static</span> handle_hash_map dst</div>
<div class="line">    = hhm_init((<span class="keyword">struct</span> val*)NULL, e, key, hhmap_int_to_u64, hhmap_id_eq,</div>
<div class="line">               NULL, NULL, 0);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> res = hhm_copy(&amp;dst, &amp;src, std_alloc);</div>
</div><!-- fragment --><p>The above allows dst to have a capacity less than that of the src as long as copy has been provided an allocation function to resize dst. Note that this would still work if copying to a destination that the user wants as a fixed size map.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define handle_hash_MAP_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">struct </span>val</div>
<div class="line">{</div>
<div class="line">    hhmap_elem e;</div>
<div class="line">    <span class="keywordtype">int</span> key;</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> handle_hash_map src</div>
<div class="line">    = hhm_init((<span class="keyword">struct</span> val*)NULL, e, key, hhmap_int_to_u64, hhmap_id_eq,</div>
<div class="line">               NULL, NULL, 0);</div>
<div class="line">insert_rand_vals(&amp;src);</div>
<div class="line"><span class="keyword">static</span> handle_hash_map dst</div>
<div class="line">    = hhm_init((<span class="keyword">struct</span> val*)NULL, e, key, hhmap_int_to_u64, hhmap_id_eq,</div>
<div class="line">               NULL, NULL, 0);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> res = hhm_copy(&amp;dst, &amp;src, std_alloc);</div>
</div><!-- fragment --><p>The above sets up dst with fixed size while src is a dynamic map. Because an allocation function is provided, the dst is resized once for the copy and retains its fixed size after the copy is complete. This would require the user to manually free the underlying buffer at dst eventually if this method is used. Usually it is better to allocate the memory explicitly before the copy if copying between maps without allocation permission.</p>
<p>These options allow users to stay consistent across containers with their memory management strategies. </p>

</div>
</div>
<a id="a52402c5061058f672136740d71c30ab9" name="a52402c5061058f672136740d71c30ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52402c5061058f672136740d71c30ab9">&#9670;&#160;</a></span>ccc_hhm_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_hhm_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the base of backing array. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>a pointer to the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the base of the backing array. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the reference is to the base of the backing array at index 0 with no consideration for the organization of map. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it is the users responsibility to ensure that access to any data is within the capacity of the backing buffer. </dd></dl>

</div>
</div>
<a id="af6d86d87aa8f109cdf6117e46f454ee9" name="af6d86d87aa8f109cdf6117e46f454ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d86d87aa8f109cdf6117e46f454ee9">&#9670;&#160;</a></span>ccc_hhm_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_hhm_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current handle iterator has reached the end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>a pointer to the current handle iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the handle iterator has reached the end of the table and iteration should stop, false if the iterator is valid and iteration should continue. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if iter has reached the end unwrapping it will result in 0 or invalid handles and NULL references. </dd></dl>

</div>
</div>
<a id="aad07602c4f4b851c481898f7aad8ab42" name="aad07602c4f4b851c481898f7aad8ab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad07602c4f4b851c481898f7aad8ab42">&#9670;&#160;</a></span>ccc_hhm_get_key_val()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a> ccc_hhm_get_key_val </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a handle to the element stored at key if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the handle hash map to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key to search matching stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-zero handle if present, otherwise 0 (falsey). </dd></dl>

</div>
</div>
<a id="ae1afbc46e29148242823c839ef4d57c0" name="ae1afbc46e29148242823c839ef4d57c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1afbc46e29148242823c839ef4d57c0">&#9670;&#160;</a></span>ccc_hhm_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> ccc_hhm_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a handle for the provided key in the table for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the hash table to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key used to search the table matching the stored key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a specialized hash handle for use with other functions in the Handle Interface. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the contents of a handle should not be examined or modified. Use the provided functions, only.</dd></dl>
<p>A handle is a search result that provides either an Occupied or Vacant element in the table. An occupied handle signifies that the search was successful. A Vacant handle means the search was not successful but we now have a handle to where in the table such an element should be inserted.</p>
<p>A handle is rarely useful on its own. It should be passed in a functional style to subsequent calls in the Handle Interface. </p>

</div>
</div>
<a id="a44585be1a06764cf2575e06e6e043d5d" name="a44585be1a06764cf2575e06e6e043d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44585be1a06764cf2575e06e6e043d5d">&#9670;&#160;</a></span>ccc_hhm_handle_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a546d4339d75e7b144c85d3e54a841c1b">ccc_handle_status</a> ccc_hhm_handle_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the handle status from a container handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the status stored in the handle after the required action on the container completes. If e is NULL a handle input error is returned so ensure e is non-NULL to avoid an inaccurate status returned.</dd></dl>
<p>Note that this function can be useful for debugging or if more detailed messages are needed for logging purposes. See <a class="el" href="types_8h.html#abc4f535e3a5cf5430bcea909c81af8f0" title="Obtain a string message with a description of the handle status.">ccc_handle_status_msg()</a> in <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">ccc/types.h</a> for more information on detailed handle statuses. </p>

</div>
</div>
<a id="a8595750d470db2db828249f1db42f7ca" name="a8595750d470db2db828249f1db42f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8595750d470db2db828249f1db42f7ca">&#9670;&#160;</a></span>ccc_hhm_insert_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_hhm_insert_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the status of the handle should an insertion follow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the handle from a query to the table via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the next insertion of a new element will cause an error.</dd></dl>
<p>Table resizing occurs upon calls to handle functions/macros or when trying to insert a new element directly. This is to provide stable entries from the time they are obtained to the time they are used in functions they are passed to (i.e. the idiomatic or_insert(handle(...)...)).</p>
<p>However, if a Vacant handle is returned and then a subsequent insertion function is used, it will not work if resizing has failed and the return of those functions will indicate such a failure. One can also confirm an insertion error will occur from a handle with this function. For example, leaving this function in an assert for debug builds can be a helpful sanity check if the heap should correctly resize by default and errors are not usually expected. </p>

</div>
</div>
<a id="a03d64becb61483c4385f443330a8f9e4" name="a03d64becb61483c4385f443330a8f9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d64becb61483c4385f443330a8f9e4">&#9670;&#160;</a></span>ccc_hhm_insert_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a> ccc_hhm_insert_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the provided handle invariantly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the handle returned from a call obtaining a handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>a handle to the struct the user intends to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-zero handle index to the inserted element or 0 upon a memory error in which the load factor would be exceeded when no allocation policy is defined or resizing failed to find more memory.</dd></dl>
<p>This method can be used when the old value in the table does not need to be preserved. See the regular insert method if the old value is of interest. If an error occurs during the insertion process due to memory limitations or a search error 0 is returned. Otherwise insertion should not fail. </p>

</div>
</div>
<a id="ab4991835a59211de8789d7d80cebf16c" name="ab4991835a59211de8789d7d80cebf16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4991835a59211de8789d7d80cebf16c">&#9670;&#160;</a></span>ccc_hhm_insert_or_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a> ccc_hhm_insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts or overwrites a user struct into the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>a pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>the handle to the wrapping user struct key value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the current table element. If Occupied a handle was overwritten by the new key value. If Vacant no prior table handle existed.</dd></dl>
<p>Note that this function can be used when the old user type is not needed but the information regarding its presence is helpful. </p>

</div>
</div>
<a id="a0a8b935f196f9e252c9c92044f46156d" name="a0a8b935f196f9e252c9c92044f46156d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8b935f196f9e252c9c92044f46156d">&#9670;&#160;</a></span>ccc_hhm_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_hhm_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size status of the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty else false. </dd></dl>

</div>
</div>
<a id="a18daddb4fb75651d276d3d3067214a66" name="a18daddb4fb75651d276d3d3067214a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18daddb4fb75651d276d3d3067214a66">&#9670;&#160;</a></span>ccc_hhm_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_hhm_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the iterator to the next occupied table handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">iter</td><td>the previous handle that acts as an iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ok if the handle is successfully updated to represent the next element or an error if iter is NULL. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>erasing or inserting during iteration may result in repeating or unexpected iteration orders, but the index remains valid for the table. </dd></dl>

</div>
</div>
<a id="a1d20e1fe5d14fbed0a3899d1a1ab8d3b" name="a1d20e1fe5d14fbed0a3899d1a1ab8d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d20e1fe5d14fbed0a3899d1a1ab8d3b">&#9670;&#160;</a></span>ccc_hhm_next_prime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_hhm_next_prime </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to find a prime number if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the input that may or may not be prime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next larger prime number.</dd></dl>
<p>It is possible to use this hash table without an allocator by providing the buffer to be used for the underlying storage and preventing allocation. If such a backing store is used it would be best to ensure it is a prime number size to mitigate hash collisions. </p>

</div>
</div>
<a id="a5786c9956b4cbe445be02175a725ba03" name="a5786c9956b4cbe445be02175a725ba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5786c9956b4cbe445be02175a725ba03">&#9670;&#160;</a></span>ccc_hhm_occupied()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_hhm_occupied </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Vacant or Occupied status of the handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the handle from a query to the table via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the handle is occupied, false if not. </dd></dl>

</div>
</div>
<a id="a333ab1765e9a21313707f19197bd6e88" name="a333ab1765e9a21313707f19197bd6e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333ab1765e9a21313707f19197bd6e88">&#9670;&#160;</a></span>ccc_hhm_or_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a> ccc_hhm_or_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the struct with handle elem if the handle is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the handle obtained via function or macro call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>the handle to the struct to be inserted to a Vacant handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-zero handle index to handle in the table invariantly. 0 (falsey) on error.</dd></dl>
<p>Because this functions takes a handle and inserts if it is Vacant, the only reason 0 shall be returned is when an insertion error will occur, usually due to a resizing memory error. This can happen if the table is not allowed to resize because no allocation function is provided. </p>

</div>
</div>
<a id="a24904ef98014c83cb63e20ed5c6ca435" name="a24904ef98014c83cb63e20ed5c6ca435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24904ef98014c83cb63e20ed5c6ca435">&#9670;&#160;</a></span>ccc_hhm_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a> ccc_hhm_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *&#160;</td>
          <td class="paramname"><em>out_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the key value in the map storing the old value, if present, in the struct containing out_handle provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_handle</td><td>the handle to the user type wrapping hhash elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle with a status indicating if the element searched existed and has been removed from the table. Unwrapping will result in NULL. If an old element existed it is copied to the struct wrapping out_handle.</dd></dl>
<p>Note that this function may write to the struct containing the second parameter and wraps it in a handle to provide information about the old value. </p>

</div>
</div>
<a id="a23730aa5dd43c7435a3d294b1962aa17" name="a23730aa5dd43c7435a3d294b1962aa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23730aa5dd43c7435a3d294b1962aa17">&#9670;&#160;</a></span>ccc_hhm_remove_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a> ccc_hhm_remove_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the handle from the table if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the table handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle containing 0. If Occupied a handle in the table existed and was removed. If Vacant, no prior handle existed to be removed.</dd></dl>
<p>If the old table element is needed see the remove method. </p>

</div>
</div>
<a id="ac30d8065345ebaee760c1243e974509b" name="ac30d8065345ebaee760c1243e974509b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d8065345ebaee760c1243e974509b">&#9670;&#160;</a></span>ccc_hhm_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_hhm_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size_t size. </dd></dl>

</div>
</div>
<a id="a45ca65d28a878aefbcdec6ef0bb8542a" name="a45ca65d28a878aefbcdec6ef0bb8542a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ca65d28a878aefbcdec6ef0bb8542a">&#9670;&#160;</a></span>ccc_hhm_swap_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a> ccc_hhm_swap_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *&#160;</td>
          <td class="paramname"><em>out_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts the key value wrapping out_handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_handle</td><td>the handle to the user type wrapping hhash elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle. If Vacant, no prior element with key existed and the type wrapping out_handle remains unchanged. If Occupied the old value is written to the type wrapping out_handle. If more space is needed but allocation fails or has been forbidden, an insert error is set. Unwrap to view the current table element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function may write to the struct containing the second parameter. </dd></dl>

</div>
</div>
<a id="a0e70af2b96548b877c42f1f5151e2757" name="a0e70af2b96548b877c42f1f5151e2757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e70af2b96548b877c42f1f5151e2757">&#9670;&#160;</a></span>ccc_hhm_try_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a3802af9257ee4d2f9df5409bae63f0a7">ccc_handle</a> ccc_hhm_try_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a42c4d64e3bc464cbffa19bff2570bc5e">ccc_hhmap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert the key value wrapping key_val_handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the pointer to the handle hash map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>the handle to the user type wrapping hhash elem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle. If Occupied, the handle contains a handle to the key value user type in the table and may be unwrapped. If Vacant the handle contains a handle to the newly inserted element in the table. If more space is needed but allocation fails or has been forbidden, an insert error is set. </dd></dl>

</div>
</div>
<a id="a8972f9155488aceb79f123369c6d8a3b" name="a8972f9155488aceb79f123369c6d8a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8972f9155488aceb79f123369c6d8a3b">&#9670;&#160;</a></span>ccc_hhm_unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a39d707127c6bb25cb76587203582743c">ccc_handle_i</a> ccc_hhm_unwrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#afa704eacdada6f1862c6e8ffd3e5d4b4">ccc_hhmap_handle</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwraps the provided handle to obtain a handle index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the handle from a query to the table via function or macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-zero handle index if the table element is Occupied, otherwise 0 (falsey). </dd></dl>

</div>
</div>
<a id="acb5885da292b6f1129ce96762bc65560" name="acb5885da292b6f1129ce96762bc65560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5885da292b6f1129ce96762bc65560">&#9670;&#160;</a></span>ccc_hhm_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_hhm_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handle__hash__map_8h.html#a324f061240f66cf5dc986a70d1450d6a">ccc_handle_hash_map</a> const *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validation of invariants for the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>the table to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all invariants hold, false if corruption occurs. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="handle__hash__map_8h.html">handle_hash_map.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
