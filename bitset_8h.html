<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/bitset.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('bitset_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">bitset.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Bit Set Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;private/private_bitset.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bitset.h:</div>
<div class="dyncontent">
<div class="center"><img src="bitset_8h__incl.png" border="0" usemap="#accc_2bitset_8h" alt=""/></div>
<map name="accc_2bitset_8h" id="accc_2bitset_8h">
<area shape="rect" title="The Bit Set Interface." alt="" coords="107,5,203,31"/>
<area shape="rect" href="private__bitset_8h_source.html" title=" " alt="" coords="5,79,180,104"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="114,152,197,177"/>
<area shape="rect" href="private__types_8h_source.html" title=" " alt="" coords="69,225,242,251"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="bitset_8h__dep__incl.png" border="0" usemap="#accc_2bitset_8hdep" alt=""/></div>
<map name="accc_2bitset_8hdep" id="accc_2bitset_8hdep">
<area shape="rect" title="The Bit Set Interface." alt="" coords="29,5,125,31"/>
<area shape="rect" href="private__traits_8h_source.html" title=" " alt="" coords="5,79,148,119"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="30,167,123,192"/>
</map>
</div>
</div>
<p><a href="bitset_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Bit Set Interface. </p>
<p>A bit set offers efficient set membership operations when the range of values can be tracked via an index. Both a fixed size and dynamic variant are possible depending on initialization options.</p>
<p>Conceptually, the bit set can be thought of as an arbitrary length integer with index <code>0</code> being the Least Significant Bit and index <code>N - 1</code> being the Most Significant Bit of the integer. Internally, this is implemented by populating each block of the bit set from Least Significant Bit to Most Significant Bit. Therefore, "trailing" means starting from the Least Significant Bit and "leading" means starting from the Most Significant Bit; this is done to stay consistent with upcoming bit operations introduced to the C23 standard.</p>
<p>A bit set can be used for modeling integer operations on integers that exceed the widths available on one's platform. The provided bitwise operation functions are helpful for these types of manipulations.</p>
<p>A bit set can also be used for modeling data that can be abstracted to a position and binary value. For example, disk blocks in a file system, free blocks in a memory allocator, and many other resource abstractions can benefit from a bit set. For these use cases the bit set offers efficient functions to find the first bits set to zero or one from either the trailing or leading direction. A bit set can also efficiently report if contiguous ranges of zeros or ones are available.</p>
<p>All <code>*_range</code> functions interpret their range input argument parameters as <code>[index, index + count)</code>, a starting index and a positive forward length. This convention is consistent for all operations. The implementation automatically chooses the optimal scan direction, Least Significant Bit to Most Significant Bit for trailing scans, Most Significant Bit to Least Significant Bit for leading scans. However, the user always specifies the range in the same way for consistency.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>CCC_</code> prefix. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Initialization</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Initialize and create containers with memory and permissions. </p>
</td></tr>
<tr class="memitem:a8d2f30efc17a3bf86e36bee6adf94f5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a8d2f30efc17a3bf86e36bee6adf94f5b">CCC_bitset_block_count</a>(bit_cap)&#160;&#160;&#160;CCC_private_bitset_block_count(bit_cap)</td></tr>
<tr class="memdesc:a8d2f30efc17a3bf86e36bee6adf94f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bit blocks needed for the desired bit set capacity.  <br /></td></tr>
<tr class="separator:a8d2f30efc17a3bf86e36bee6adf94f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644c7dd50e5c82d05b8fd0558a759f7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a644c7dd50e5c82d05b8fd0558a759f7f">CCC_bitset_block_bytes</a>(bit_cap)&#160;&#160;&#160;CCC_private_bitset_block_bytes(bit_cap)</td></tr>
<tr class="memdesc:a644c7dd50e5c82d05b8fd0558a759f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes needed for the desired bit set capacity.  <br /></td></tr>
<tr class="separator:a644c7dd50e5c82d05b8fd0558a759f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872da66828891cfed4872081d7f3a83f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a872da66828891cfed4872081d7f3a83f">CCC_bitset_blocks</a>(bit_cap,  optional_storage_duration...)&#160;&#160;&#160;    CCC_private_bitset_blocks(bit_cap, optional_storage_duration)</td></tr>
<tr class="memdesc:a872da66828891cfed4872081d7f3a83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the necessary number of blocks at compile or runtime on the stack or data segment.  <br /></td></tr>
<tr class="separator:a872da66828891cfed4872081d7f3a83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb5907bb970fe865b8cba478308a95c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a9fb5907bb970fe865b8cba478308a95c">CCC_bitset_initialize</a>(bitblock_pointer,  allocate,  context,  cap,  optional_count...)</td></tr>
<tr class="memdesc:a9fb5907bb970fe865b8cba478308a95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the bit set with memory and allocation permissions.  <br /></td></tr>
<tr class="separator:a9fb5907bb970fe865b8cba478308a95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492bd828d24d634c201c573ff373d732"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a492bd828d24d634c201c573ff373d732">CCC_bitset_from</a>(allocate,  context,  start_string_index,  count,  bit_on_char,  input_string,  optional_capacity...)</td></tr>
<tr class="memdesc:a492bd828d24d634c201c573ff373d732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the bit set with a custom input string.  <br /></td></tr>
<tr class="separator:a492bd828d24d634c201c573ff373d732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabf8c741a270d166c51a5eaa31d45b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#aeabf8c741a270d166c51a5eaa31d45b1">CCC_bitset_with_capacity</a>(allocate,  context,  capacity,  optional_count...)</td></tr>
<tr class="memdesc:aeabf8c741a270d166c51a5eaa31d45b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the bit set with a starting capacity and size at runtime.  <br /></td></tr>
<tr class="separator:aeabf8c741a270d166c51a5eaa31d45b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1aaa3bf1fa56eb68eb6ed821c8f1e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#abc1aaa3bf1fa56eb68eb6ed821c8f1e6">CCC_bitset_with_compound_literal</a>(count,  compound_literal_array)&#160;&#160;&#160;    CCC_private_bitset_with_compound_literal(count, compound_literal_array)</td></tr>
<tr class="memdesc:abc1aaa3bf1fa56eb68eb6ed821c8f1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the bit set with a starting capacity and size at runtime or compile time with no allocation permissions or context from a compound literal of bitset blocks.  <br /></td></tr>
<tr class="separator:abc1aaa3bf1fa56eb68eb6ed821c8f1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4597e5558b2c24d7f95847e5b5eb7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#abb4597e5558b2c24d7f95847e5b5eb7b">CCC_bitset_with_context_compound_literal</a>(count,  compound_literal_array)</td></tr>
<tr class="memdesc:abb4597e5558b2c24d7f95847e5b5eb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the bit set with a starting capacity and size at runtime or compile time with no allocation permissions from a compound literal of bitset blocks.  <br /></td></tr>
<tr class="separator:abb4597e5558b2c24d7f95847e5b5eb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c429148b439f77564a95b3edc3b452"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: size_t { <a class="el" href="bitset_8h.html#a52c429148b439f77564a95b3edc3b452a1caf09195736db544353b8098c3f5346">CCC_BITSET_BLOCK_BITS</a> = CCC_PRIVATE_BITSET_BLOCK_BITS
 }</td></tr>
<tr class="separator:a52c429148b439f77564a95b3edc3b452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e536b16b4fdcbfccc6bb1bef30fd620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a1e536b16b4fdcbfccc6bb1bef30fd620">CCC_bitset_copy</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *destination, <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *source, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:a1e536b16b4fdcbfccc6bb1bef30fd620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the bit set at source to destination.  <br /></td></tr>
<tr class="separator:a1e536b16b4fdcbfccc6bb1bef30fd620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9bf7eb0b390fc4066e9b2c45f239e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a4e9bf7eb0b390fc4066e9b2c45f239e6">CCC_bitset_reserve</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t to_add, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:a4e9bf7eb0b390fc4066e9b2c45f239e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for at least to_add more bits.  <br /></td></tr>
<tr class="separator:a4e9bf7eb0b390fc4066e9b2c45f239e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Container Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Types available in the container interface. </p>
</td></tr>
<tr class="memitem:aa7609a9830b1b4af9389ad76a55f438f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#aa7609a9830b1b4af9389ad76a55f438f">CCC_Bitset</a></td></tr>
<tr class="memdesc:aa7609a9830b1b4af9389ad76a55f438f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit set type that may be stored and initialized on the stack, heap, or data segment at compile or run time.  <br /></td></tr>
<tr class="separator:aa7609a9830b1b4af9389ad76a55f438f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Bit Membership Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Test for the presence of bits. </p>
</td></tr>
<tr class="memitem:a0e64a6ca5e9ca50345a25a8de4059813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a0e64a6ca5e9ca50345a25a8de4059813">CCC_bitset_test</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t index)</td></tr>
<tr class="memdesc:a0e64a6ca5e9ca50345a25a8de4059813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the bit at index index for boolean status (CCC_TRUE or CCC_FALSE).  <br /></td></tr>
<tr class="separator:a0e64a6ca5e9ca50345a25a8de4059813"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Bit Modification Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Set and flip bits in the set. </p>
</td></tr>
<tr class="memitem:a90a1d625bc0744805ccac9e4184f90ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a90a1d625bc0744805ccac9e4184f90ae">CCC_bitset_set</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t index, <a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> bit)</td></tr>
<tr class="memdesc:a90a1d625bc0744805ccac9e4184f90ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bit at valid index index to value bit (true or false).  <br /></td></tr>
<tr class="separator:a90a1d625bc0744805ccac9e4184f90ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9045164b4f6d585973945f3003c30b68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a9045164b4f6d585973945f3003c30b68">CCC_bitset_set_all</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, <a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> bit)</td></tr>
<tr class="memdesc:a9045164b4f6d585973945f3003c30b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the bits to the provided value (CCC_TRUE or CCC_FALSE).  <br /></td></tr>
<tr class="separator:a9045164b4f6d585973945f3003c30b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb57e8abbbdbacb6813779c0730371e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#abb57e8abbbdbacb6813779c0730371e3">CCC_bitset_set_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t range_start_index, size_t range_bit_count, <a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> bit)</td></tr>
<tr class="memdesc:abb57e8abbbdbacb6813779c0730371e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the bits in the specified range starting at the Least Significant Bit of the range and ending at the Most Significant Bit of the range (CCC_TRUE or CCC_FALSE).  <br /></td></tr>
<tr class="separator:abb57e8abbbdbacb6813779c0730371e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047e880bfd157c60b37a34f6434e16d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a047e880bfd157c60b37a34f6434e16d7">CCC_bitset_reset</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t index)</td></tr>
<tr class="memdesc:a047e880bfd157c60b37a34f6434e16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bit at valid index index to boolean value b (true or false).  <br /></td></tr>
<tr class="separator:a047e880bfd157c60b37a34f6434e16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b3c66d273ef72f387041452f6a243a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a10b3c66d273ef72f387041452f6a243a">CCC_bitset_reset_all</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset)</td></tr>
<tr class="memdesc:a10b3c66d273ef72f387041452f6a243a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the bits to CCC_FALSE.  <br /></td></tr>
<tr class="separator:a10b3c66d273ef72f387041452f6a243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c9b7c36eeab27ad7615215c9e61467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#aa8c9b7c36eeab27ad7615215c9e61467">CCC_bitset_reset_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:aa8c9b7c36eeab27ad7615215c9e61467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the bits in the specified range starting at the Least Significant Bit of the range and ending at the Most Significant Bit of the range to CCC_FALSE.  <br /></td></tr>
<tr class="separator:aa8c9b7c36eeab27ad7615215c9e61467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d90c10c9bc2372cf441ed73a2b7c8cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a5d90c10c9bc2372cf441ed73a2b7c8cd">CCC_bitset_flip</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t index)</td></tr>
<tr class="memdesc:a5d90c10c9bc2372cf441ed73a2b7c8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the bit at index i.  <br /></td></tr>
<tr class="separator:a5d90c10c9bc2372cf441ed73a2b7c8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281f20c700dd16a3436ab8cdcae3174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a2281f20c700dd16a3436ab8cdcae3174">CCC_bitset_flip_all</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset)</td></tr>
<tr class="memdesc:a2281f20c700dd16a3436ab8cdcae3174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle all of the bits to their opposing boolean value.  <br /></td></tr>
<tr class="separator:a2281f20c700dd16a3436ab8cdcae3174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72290ab5aa5ba19f73375143b93269f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a72290ab5aa5ba19f73375143b93269f9">CCC_bitset_flip_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:a72290ab5aa5ba19f73375143b93269f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip all the bits in the range, starting at the Least Significant Bit in range and ending at the Most Significant Bit, to their opposite value.  <br /></td></tr>
<tr class="separator:a72290ab5aa5ba19f73375143b93269f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Bit Scan Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Find bits with a specific status. </p>
</td></tr>
<tr class="memitem:a54014b7bc57c24948ac11bf59425e727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a54014b7bc57c24948ac11bf59425e727">CCC_bitset_any</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a54014b7bc57c24948ac11bf59425e727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any bits in set are 1.  <br /></td></tr>
<tr class="separator:a54014b7bc57c24948ac11bf59425e727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a74673967ca72009ee04f15f38f7304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a8a74673967ca72009ee04f15f38f7304">CCC_bitset_any_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:a8a74673967ca72009ee04f15f38f7304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any bits are 1 in the range <code>[index, index + count)</code>.  <br /></td></tr>
<tr class="separator:a8a74673967ca72009ee04f15f38f7304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4909d4df97f0d94e238d89c489a2ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ad4909d4df97f0d94e238d89c489a2ea3">CCC_bitset_none</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:ad4909d4df97f0d94e238d89c489a2ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all bits are set to 0.  <br /></td></tr>
<tr class="separator:ad4909d4df97f0d94e238d89c489a2ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad998717cb0e8f09b643f409251c81953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ad998717cb0e8f09b643f409251c81953">CCC_bitset_none_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:ad998717cb0e8f09b643f409251c81953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all bits are 0 in the range <code>[index, index + count)</code>.  <br /></td></tr>
<tr class="separator:ad998717cb0e8f09b643f409251c81953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a01edefe6dee85fdb545a69274b9b98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a5a01edefe6dee85fdb545a69274b9b98">CCC_bitset_all</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a5a01edefe6dee85fdb545a69274b9b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all bits in set are 1.  <br /></td></tr>
<tr class="separator:a5a01edefe6dee85fdb545a69274b9b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d51c7b5e8e8e8c27679780f9112dd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a57d51c7b5e8e8e8c27679780f9112dd4">CCC_bitset_all_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:a57d51c7b5e8e8e8c27679780f9112dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all bits are set to 1 in the range <code>[index, index + count)</code>.  <br /></td></tr>
<tr class="separator:a57d51c7b5e8e8e8c27679780f9112dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e104831cf9b2779d2dfe14f24ba3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a66e104831cf9b2779d2dfe14f24ba3ec">CCC_bitset_first_trailing_one</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a66e104831cf9b2779d2dfe14f24ba3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first trailing bit set to 1 in the set.  <br /></td></tr>
<tr class="separator:a66e104831cf9b2779d2dfe14f24ba3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac534fdc0ea82be1e9a61f8f92f11a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#aac534fdc0ea82be1e9a61f8f92f11a64">CCC_bitset_first_trailing_one_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:aac534fdc0ea82be1e9a61f8f92f11a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first trailing bit set to 1 in the range <code>[i, index + count)</code>.  <br /></td></tr>
<tr class="separator:aac534fdc0ea82be1e9a61f8f92f11a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe8947f8009685d53b12a53e1e7258e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a8fe8947f8009685d53b12a53e1e7258e">CCC_bitset_first_trailing_ones</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t ones_count)</td></tr>
<tr class="memdesc:a8fe8947f8009685d53b12a53e1e7258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the start of the first trailing number of contiguous 1 bits.  <br /></td></tr>
<tr class="separator:a8fe8947f8009685d53b12a53e1e7258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd72500d8ca93b17d2eee31e1f028980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#afd72500d8ca93b17d2eee31e1f028980">CCC_bitset_first_trailing_ones_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count, size_t ones_count)</td></tr>
<tr class="memdesc:afd72500d8ca93b17d2eee31e1f028980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the start of the first trailing number of contiguous 1 bits in the range <code>[index, index + count)</code>.  <br /></td></tr>
<tr class="separator:afd72500d8ca93b17d2eee31e1f028980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1ea7dbef6cc3b55619c3e650807129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a4c1ea7dbef6cc3b55619c3e650807129">CCC_bitset_first_trailing_zero</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a4c1ea7dbef6cc3b55619c3e650807129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first bit set to 0 in the set.  <br /></td></tr>
<tr class="separator:a4c1ea7dbef6cc3b55619c3e650807129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc517388b3d8f24ca135186288854c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#aafc517388b3d8f24ca135186288854c4">CCC_bitset_first_trailing_zero_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:aafc517388b3d8f24ca135186288854c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first bit set to 0 in the range <code>[i, index + count)</code>.  <br /></td></tr>
<tr class="separator:aafc517388b3d8f24ca135186288854c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b56e4b2a9285eb0ee05efd3f2be00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ac42b56e4b2a9285eb0ee05efd3f2be00">CCC_bitset_first_trailing_zeros</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t zeros_count)</td></tr>
<tr class="memdesc:ac42b56e4b2a9285eb0ee05efd3f2be00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the start of the first trailing number of contiguous 0 bits in the set.  <br /></td></tr>
<tr class="separator:ac42b56e4b2a9285eb0ee05efd3f2be00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7da0671d0b1697bb4883b26088c249d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ad7da0671d0b1697bb4883b26088c249d">CCC_bitset_first_trailing_zeros_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count, size_t zeros_count)</td></tr>
<tr class="memdesc:ad7da0671d0b1697bb4883b26088c249d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the start of the first trailing zeros_count contiguous 0 bits in the range <code>[i, index + count)</code>.  <br /></td></tr>
<tr class="separator:ad7da0671d0b1697bb4883b26088c249d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63436cf0e5be9db6a0197578ec9dd9db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a63436cf0e5be9db6a0197578ec9dd9db">CCC_bitset_first_leading_one</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a63436cf0e5be9db6a0197578ec9dd9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first leading bit set to 1 in the set, starting from the Most Significant Bit at index size - 1.  <br /></td></tr>
<tr class="separator:a63436cf0e5be9db6a0197578ec9dd9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457922476cd74a0c9819c3c8061714e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a457922476cd74a0c9819c3c8061714e0">CCC_bitset_first_leading_one_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t index, size_t count)</td></tr>
<tr class="memdesc:a457922476cd74a0c9819c3c8061714e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first leading bit set to 1 in the range <code>[i, index + count)</code>.  <br /></td></tr>
<tr class="separator:a457922476cd74a0c9819c3c8061714e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc87cb3e78836e42650a75f1bfcdad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a97fc87cb3e78836e42650a75f1bfcdad">CCC_bitset_first_leading_ones</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t ones_count)</td></tr>
<tr class="memdesc:a97fc87cb3e78836e42650a75f1bfcdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the start of the first leading bit_count contiguous 1 bits.  <br /></td></tr>
<tr class="separator:a97fc87cb3e78836e42650a75f1bfcdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34ac4e33541358bb5f8a146cdf74cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#af34ac4e33541358bb5f8a146cdf74cc3">CCC_bitset_first_leading_ones_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count, size_t ones_count)</td></tr>
<tr class="memdesc:af34ac4e33541358bb5f8a146cdf74cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the start of the first leading bit_count contiguous 1 bits in the range <code>[i, index + count)</code>.  <br /></td></tr>
<tr class="separator:af34ac4e33541358bb5f8a146cdf74cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101936145c300579b382114d3ed16e61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a101936145c300579b382114d3ed16e61">CCC_bitset_first_leading_zero</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a101936145c300579b382114d3ed16e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first leading bit set to 0 in the set, starting from the Most Significant Bit at index size - 1.  <br /></td></tr>
<tr class="separator:a101936145c300579b382114d3ed16e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b357b7bf63e0d1591578646fd799710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a9b357b7bf63e0d1591578646fd799710">CCC_bitset_first_leading_zero_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:a9b357b7bf63e0d1591578646fd799710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first leading bit set to 0 in the range <code>[i, index + count)</code>.  <br /></td></tr>
<tr class="separator:a9b357b7bf63e0d1591578646fd799710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef46f59affeb6f9ab07aea7e1336e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a3ef46f59affeb6f9ab07aea7e1336e44">CCC_bitset_first_leading_zeros</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t zeros_count)</td></tr>
<tr class="memdesc:a3ef46f59affeb6f9ab07aea7e1336e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the start of the first leading number of contiguous 0 bits.  <br /></td></tr>
<tr class="separator:a3ef46f59affeb6f9ab07aea7e1336e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b9a38adf50ddb4d6c2a0666b5ecf66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ae3b9a38adf50ddb4d6c2a0666b5ecf66">CCC_bitset_first_leading_zeros_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count, size_t zeros_count)</td></tr>
<tr class="memdesc:ae3b9a38adf50ddb4d6c2a0666b5ecf66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the start of the first leading number of contiguous 0 bits in the range <code>[i, index + count)</code>.  <br /></td></tr>
<tr class="separator:ae3b9a38adf50ddb4d6c2a0666b5ecf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Bit Operations Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Use standard integer width bit operations on the entire set. </p>
</td></tr>
<tr class="memitem:ac86132b20d327de28c5747c804cb9675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ac86132b20d327de28c5747c804cb9675">CCC_bitset_or</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *destination, <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *source)</td></tr>
<tr class="memdesc:ac86132b20d327de28c5747c804cb9675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR destination set with source set.  <br /></td></tr>
<tr class="separator:ac86132b20d327de28c5747c804cb9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480043e5486200fa84b5f4eb8f96fab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a480043e5486200fa84b5f4eb8f96fab2">CCC_bitset_and</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *destination, <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *source)</td></tr>
<tr class="memdesc:a480043e5486200fa84b5f4eb8f96fab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND destination set with source set.  <br /></td></tr>
<tr class="separator:a480043e5486200fa84b5f4eb8f96fab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1657bb8880562c5ed4e3e99d798ecb9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a1657bb8880562c5ed4e3e99d798ecb9b">CCC_bitset_xor</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *destination, <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *source)</td></tr>
<tr class="memdesc:a1657bb8880562c5ed4e3e99d798ecb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR destination set with source set.  <br /></td></tr>
<tr class="separator:a1657bb8880562c5ed4e3e99d798ecb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad567c0204d2ce3195b00f4f99525a1b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ad567c0204d2ce3195b00f4f99525a1b3">CCC_bitset_shift_left</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t left_shifts)</td></tr>
<tr class="memdesc:ad567c0204d2ce3195b00f4f99525a1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bit set left by left_shifts amount.  <br /></td></tr>
<tr class="separator:ad567c0204d2ce3195b00f4f99525a1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8a489b9547073f07827808ad8437c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a8f8a489b9547073f07827808ad8437c2">CCC_bitset_shift_right</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, size_t right_shifts)</td></tr>
<tr class="memdesc:a8f8a489b9547073f07827808ad8437c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bit set right by right_shifts amount.  <br /></td></tr>
<tr class="separator:a8f8a489b9547073f07827808ad8437c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077ab1f869509d48c4dc2da2be8071fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a077ab1f869509d48c4dc2da2be8071fe">CCC_bitset_is_equal</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *left, <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *right)</td></tr>
<tr class="memdesc:a077ab1f869509d48c4dc2da2be8071fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks two bit sets of the same size (not capacity) for equality.  <br /></td></tr>
<tr class="separator:a077ab1f869509d48c4dc2da2be8071fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Set Operations Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Perform basic mathematical set operations on the bit set. </p>
</td></tr>
<tr class="memitem:a3de23d6bc1c42f00570427616dea864e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a3de23d6bc1c42f00570427616dea864e">CCC_bitset_is_proper_subset</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *subset, <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *set)</td></tr>
<tr class="memdesc:a3de23d6bc1c42f00570427616dea864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CCC_TRUE if subset is a proper subset of set (subset ⊂ set).  <br /></td></tr>
<tr class="separator:a3de23d6bc1c42f00570427616dea864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad827812efab1e5a9dcd9932ebf495854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ad827812efab1e5a9dcd9932ebf495854">CCC_bitset_is_subset</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *subset, <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *set)</td></tr>
<tr class="memdesc:ad827812efab1e5a9dcd9932ebf495854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CCC_TRUE if subset is a subset of set (subset ⊆ set).  <br /></td></tr>
<tr class="separator:ad827812efab1e5a9dcd9932ebf495854"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain state from the container. </p>
</td></tr>
<tr class="memitem:ae4b72853b6626dee7393da3f6a0482c2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ae4b72853b6626dee7393da3f6a0482c2">CCC_bitset_data</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:ae4b72853b6626dee7393da3f6a0482c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the base of the underlying block array.  <br /></td></tr>
<tr class="separator:ae4b72853b6626dee7393da3f6a0482c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba9fddb65eda291de0f105e3fb82ecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#aeba9fddb65eda291de0f105e3fb82ecc">CCC_bitset_capacity</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:aeba9fddb65eda291de0f105e3fb82ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return total number of bits the capacity of the set can hold.  <br /></td></tr>
<tr class="separator:aeba9fddb65eda291de0f105e3fb82ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28da7dd2afe24ee3313454fdc74254ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a28da7dd2afe24ee3313454fdc74254ab">CCC_bitset_count</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a28da7dd2afe24ee3313454fdc74254ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return total number of bits actively tracked by the user and set.  <br /></td></tr>
<tr class="separator:a28da7dd2afe24ee3313454fdc74254ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b8365bd55738bc0685e1847dfe8a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ab0b8365bd55738bc0685e1847dfe8a84">CCC_bitset_blocks_capacity</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:ab0b8365bd55738bc0685e1847dfe8a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of CCC_bitblocks used by bit set for capacity bits.  <br /></td></tr>
<tr class="separator:ab0b8365bd55738bc0685e1847dfe8a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e02c49979ab7107acdd4f118634fbb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a3e02c49979ab7107acdd4f118634fbb1">CCC_bitset_blocks_count</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a3e02c49979ab7107acdd4f118634fbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of CCC_bitblocks used by the bit set for size bits.  <br /></td></tr>
<tr class="separator:a3e02c49979ab7107acdd4f118634fbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae841c1c5aa6bbef00139d676bf7ba283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ae841c1c5aa6bbef00139d676bf7ba283">CCC_bitset_is_empty</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:ae841c1c5aa6bbef00139d676bf7ba283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if no bits are actively tracked by the user and set.  <br /></td></tr>
<tr class="separator:ae841c1c5aa6bbef00139d676bf7ba283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dececa4fb2154379a9ce98ac61f03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a43dececa4fb2154379a9ce98ac61f03a">CCC_bitset_popcount</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset)</td></tr>
<tr class="memdesc:a43dececa4fb2154379a9ce98ac61f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bits set to CCC_TRUE. O(n).  <br /></td></tr>
<tr class="separator:a43dececa4fb2154379a9ce98ac61f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf3a9e7db10e051718c3311dc364154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCCC__Count.html">CCC_Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#aedf3a9e7db10e051718c3311dc364154">CCC_bitset_popcount_range</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *bitset, size_t range_start_index, size_t range_bit_count)</td></tr>
<tr class="memdesc:aedf3a9e7db10e051718c3311dc364154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bits set to CCC_TRUE in the range. O(n).  <br /></td></tr>
<tr class="separator:aedf3a9e7db10e051718c3311dc364154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Destructor Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Clear the set and manage its memory. </p>
</td></tr>
<tr class="memitem:a02bc88eefcc8809fe77d2e6809a66118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a02bc88eefcc8809fe77d2e6809a66118">CCC_bitset_clear</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset)</td></tr>
<tr class="memdesc:a02bc88eefcc8809fe77d2e6809a66118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the bit set by setting the size to 0 and all bits to 0. The underlying memory capacity remains unchanged.  <br /></td></tr>
<tr class="separator:a02bc88eefcc8809fe77d2e6809a66118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f0f95441281910f95ce681d7d31a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#ad5f0f95441281910f95ce681d7d31a2b">CCC_bitset_clear_and_free</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset)</td></tr>
<tr class="memdesc:ad5f0f95441281910f95ce681d7d31a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the bit set by setting the size to 0 and freeing the underlying memory. Capacity becomes 0 as well.  <br /></td></tr>
<tr class="separator:ad5f0f95441281910f95ce681d7d31a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae5a66486871862896b785e7acaf4fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a7ae5a66486871862896b785e7acaf4fc">CCC_bitset_clear_and_free_reserve</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, <a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *allocate)</td></tr>
<tr class="memdesc:a7ae5a66486871862896b785e7acaf4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the Buffer for the bit set that was previously dynamically reserved with the reserve function.  <br /></td></tr>
<tr class="separator:a7ae5a66486871862896b785e7acaf4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Dynamic Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Allows adding to and removing from the set. </p>
</td></tr>
<tr class="memitem:a850f483c7ea01105667a78b25592f0d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a850f483c7ea01105667a78b25592f0d0">CCC_bitset_push_back</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset, <a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> bit)</td></tr>
<tr class="memdesc:a850f483c7ea01105667a78b25592f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a bit value to the set as the new Most Significant Bit.  <br /></td></tr>
<tr class="separator:a850f483c7ea01105667a78b25592f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4795a5a642bb2a416d774f40598aff24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitset_8h.html#a4795a5a642bb2a416d774f40598aff24">CCC_bitset_pop_back</a> (<a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *bitset)</td></tr>
<tr class="memdesc:a4795a5a642bb2a416d774f40598aff24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the Most Significant Bit from the set.  <br /></td></tr>
<tr class="separator:a4795a5a642bb2a416d774f40598aff24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a644c7dd50e5c82d05b8fd0558a759f7f" name="a644c7dd50e5c82d05b8fd0558a759f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644c7dd50e5c82d05b8fd0558a759f7f">&#9670;&#160;</a></span>CCC_bitset_block_bytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_bitset_block_bytes</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit_cap</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_bitset_block_bytes(bit_cap)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes needed for the desired bit set capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_cap</td><td>the number of bits representing this bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes needed to support the bit capacity. This is the number of bytes occupied by the number of bit blocks that must be allocated. </dd></dl>

</div>
</div>
<a id="a8d2f30efc17a3bf86e36bee6adf94f5b" name="a8d2f30efc17a3bf86e36bee6adf94f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2f30efc17a3bf86e36bee6adf94f5b">&#9670;&#160;</a></span>CCC_bitset_block_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_bitset_block_count</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit_cap</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_bitset_block_count(bit_cap)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bit blocks needed for the desired bit set capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_cap</td><td>the number of bits representing this bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of blocks needed for the desired bit set. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>bit_cap must be &gt;= 1. </dd></dl>

</div>
</div>
<a id="a872da66828891cfed4872081d7f3a83f" name="a872da66828891cfed4872081d7f3a83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872da66828891cfed4872081d7f3a83f">&#9670;&#160;</a></span>CCC_bitset_blocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_bitset_blocks</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit_cap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_storage_duration...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_bitset_blocks(bit_cap, optional_storage_duration)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the necessary number of blocks at compile or runtime on the stack or data segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_cap</td><td>the desired number of bits to store in the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_storage_duration</td><td>an optional storage duration specifier such as static or automatic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal array of the necessary bit block type allocated in the scope it is created with any storage duration specifiers added.</dd></dl>
<p>This method can be used for compile time initialization of bit set. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structCCC__Bitset.html">CCC_Bitset</a> bit = <a class="code hl_define" href="bitset_8h.html#a9fb5907bb970fe865b8cba478308a95c">CCC_bitset_initialize</a>(</div>
<div class="line">    <a class="code hl_define" href="bitset_8h.html#a872da66828891cfed4872081d7f3a83f">CCC_bitset_blocks</a>(256, <span class="keyword">static</span>),</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    256</div>
<div class="line">);</div>
<div class="ttc" id="abitset_8h_html_a872da66828891cfed4872081d7f3a83f"><div class="ttname"><a href="bitset_8h.html#a872da66828891cfed4872081d7f3a83f">CCC_bitset_blocks</a></div><div class="ttdeci">#define CCC_bitset_blocks(bit_cap, optional_storage_duration...)</div><div class="ttdoc">Allocate the necessary number of blocks at compile or runtime on the stack or data segment.</div><div class="ttdef"><b>Definition:</b> bitset.h:144</div></div>
<div class="ttc" id="abitset_8h_html_a9fb5907bb970fe865b8cba478308a95c"><div class="ttname"><a href="bitset_8h.html#a9fb5907bb970fe865b8cba478308a95c">CCC_bitset_initialize</a></div><div class="ttdeci">#define CCC_bitset_initialize(bitblock_pointer, allocate, context, cap, optional_count...)</div><div class="ttdoc">Initialize the bit set with memory and allocation permissions.</div><div class="ttdef"><b>Definition:</b> bitset.h:185</div></div>
<div class="ttc" id="astructCCC__Bitset_html"><div class="ttname"><a href="structCCC__Bitset.html">CCC_Bitset</a></div><div class="ttdef"><b>Definition:</b> private_bitset.h:33</div></div>
</div><!-- fragment --><p>The above example also illustrates the benefits of a static compound literal to encapsulate the bits within the bit set array to prevent dangling references. If the compiler does not support storage duration of compound literals the more traditional example follows:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structCCC__Bitset.html">CCC_Bitset</a> bit = <a class="code hl_define" href="bitset_8h.html#a9fb5907bb970fe865b8cba478308a95c">CCC_bitset_initialize</a>(</div>
<div class="line">    <a class="code hl_define" href="bitset_8h.html#a872da66828891cfed4872081d7f3a83f">CCC_bitset_blocks</a>(256),</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    256</div>
<div class="line">);</div>
</div><!-- fragment --><p>This macro is required for any initialization where the bit block memory comes from the stack or data segment. For one time dynamic reservations of bit block memory see the CCC_bitset_reserve and CCC_bitset_clear_and_free_reserve interface. </p>

</div>
</div>
<a id="a492bd828d24d634c201c573ff373d732" name="a492bd828d24d634c201c573ff373d732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492bd828d24d634c201c573ff373d732">&#9670;&#160;</a></span>CCC_bitset_from</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_bitset_from</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start_string_index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit_on_char, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_string, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_capacity...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_bitset_from(allocate, context, start_string_index, count,      \</div>
<div class="line">                            bit_on_char, input_string, optional_capacity)</div>
</div><!-- fragment -->
<p>Initialize the bit set with a custom input string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function for the dynamic bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>context data needed for allocation of the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_string_index</td><td>the index of the input string to start reading is CCC_Tribool input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to read from start_string_index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_on_char</td><td>the character that when encountered equates to CCC_TRUE and results in the corresponding bit in the bit set being set CCC_TRUE. Any other character encountered results in the corresponding bit being set to CCC_FALSE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_string</td><td>the string literal or pointer to a string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_capacity</td><td>the custom capacity other than the count passed to this initializer. If a greater capacity than the input string is desired because more bits will be pushed later, specify with this input. If this input is less than count, count becomes the capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized bit set on the right hand side of an equality operator with count bits pushed. If the string ends early due to a null terminator, the count will be less than that passed as input. This can be checked by checking the <a class="el" href="bitset_8h.html#a28da7dd2afe24ee3313454fdc74254ab" title="Return total number of bits actively tracked by the user and set.">CCC_bitset_count()</a> function. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the input string is assumed to adhere to the count. If the string is shorter than the count input and not null terminated the behavior is undefined.</dd></dl>
<p>A dynamic bit set with input string pushed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line">Bitset bitset = bitset_from(std_allocate, NULL, 0, 4, <span class="charliteral">&#39;1&#39;</span>, <span class="stringliteral">&quot;1011&quot;</span>);</div>
</div><!-- fragment --><p> A dynamic bit set that allocates greater capacity.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line">Bitset bitset = bitset_from(std_allocate, NULL, 0, 4, <span class="charliteral">&#39;A&#39;</span>, <span class="stringliteral">&quot;GCAT&quot;</span>, 4096);</div>
</div><!-- fragment --><p>This initializer is only available to dynamic bit sets due to the inability to run such input code at compile time. </p>

</div>
</div>
<a id="a9fb5907bb970fe865b8cba478308a95c" name="a9fb5907bb970fe865b8cba478308a95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb5907bb970fe865b8cba478308a95c">&#9670;&#160;</a></span>CCC_bitset_initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_bitset_initialize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bitblock_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_count...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_bitset_initialize(bitblock_pointer, allocate, context, cap,    \</div>
<div class="line">                                  optional_count)</div>
</div><!-- fragment -->
<p>Initialize the bit set with memory and allocation permissions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitblock_pointer</td><td>the pointer to existing blocks or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function for a dynamic bit set or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>context data needed for allocation of the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>the number of bits that will be stored in this bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_count</td><td>an optional starting size &lt;= capacity. This value defaults to the same value as capacity which is appropriate for most cases. For any case where this is not desirable, set the size manually (for example, a fixed size bit set that is pushed to dynamically would have a non-zero capacity and 0 size). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized bit set on the right hand side of an equality operator </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the user must use the CCC_bitset_blocks macro to help determine the size of the bitblock array if a fixed size bitblock array is provided at compile time; the necessary conversion from bits requested to number of blocks required to store those bits must occur before use. If capacity is zero the helper macro is not needed.</dd></dl>
<p>A fixed size bit set with size equal to capacity.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line">Bitset bitset = bitset_initialize(bitset_blocks(9), NULL, NULL, 9);</div>
</div><!-- fragment --><p> A fixed size bit set with dynamic push and pop.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line">Bitset bitset = bitset_initialize(bitset_blocks(9), NULL, NULL, 9, 0);</div>
</div><!-- fragment --><p>A dynamic bit set initialization.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line">Bitset bitset = bitset_initialize(NULL, std_allocate, NULL, 0);</div>
</div><!-- fragment --><p>See <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a> for more on allocation functions. </p>

</div>
</div>
<a id="aeabf8c741a270d166c51a5eaa31d45b1" name="aeabf8c741a270d166c51a5eaa31d45b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabf8c741a270d166c51a5eaa31d45b1">&#9670;&#160;</a></span>CCC_bitset_with_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_bitset_with_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optional_count...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_bitset_with_capacity(allocate, context, capacity,              \</div>
<div class="line">                                     optional_count)</div>
</div><!-- fragment -->
<p>Initialize the bit set with a starting capacity and size at runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function for a dynamic bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>context data needed for allocation of the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>the number of bits that will be stored in this bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optional_count</td><td>an optional starting size &lt;= capacity. This value defaults to the same value as capacity which is appropriate for most cases. For any case where this is not desirable, set the size manually (for example, a bit set that will push bits back would have a non-zero capacity and 0 size). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized bit set on the right hand side of an equality operator</dd></dl>
<p>A fixed size bit set with size equal to capacity.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Bitset bitset = bitset_with_capacity(std_allocate, NULL, 4096);</div>
<div class="line">}</div>
</div><!-- fragment --><p> A bit set with dynamic push and pop.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Bitset bitset = bitset_with_capacity(std_allocate, NULL, 4096, 0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This initialization can only be used at runtime. See the normal initializer for static and stack based initialization options. </p>

</div>
</div>
<a id="abc1aaa3bf1fa56eb68eb6ed821c8f1e6" name="abc1aaa3bf1fa56eb68eb6ed821c8f1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1aaa3bf1fa56eb68eb6ed821c8f1e6">&#9670;&#160;</a></span>CCC_bitset_with_compound_literal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_bitset_with_compound_literal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal_array&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_bitset_with_compound_literal(count, compound_literal_array)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the bit set with a starting capacity and size at runtime or compile time with no allocation permissions or context from a compound literal of bitset blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the count of bits &lt;= capacity of this bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal_array</td><td>the compound literal of bitset blocks. Use the <a class="el" href="bitset_8h.html#a872da66828891cfed4872081d7f3a83f" title="Allocate the necessary number of blocks at compile or runtime on the stack or data segment.">CCC_bitset_blocks()</a> macro to help construct this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized bit set on the right hand side of an equality operator Capacity will be set to the full capacity available for the compound literal. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Use the <a class="el" href="bitset_8h.html#a872da66828891cfed4872081d7f3a83f" title="Allocate the necessary number of blocks at compile or runtime on the stack or data segment.">CCC_bitset_blocks()</a> macro to help construct the compound literal array.</dd></dl>
<p>A fixed size bit set.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Bitset bitset = bitset_with_compound_literal(</div>
<div class="line">    4096,</div>
<div class="line">    bitset_blocks(4096, <span class="keyword">static</span>)</div>
<div class="line">);</div>
</div><!-- fragment --><p>This saves some initialization boilerplate. </p>

</div>
</div>
<a id="abb4597e5558b2c24d7f95847e5b5eb7b" name="abb4597e5558b2c24d7f95847e5b5eb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4597e5558b2c24d7f95847e5b5eb7b">&#9670;&#160;</a></span>CCC_bitset_with_context_compound_literal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_bitset_with_context_compound_literal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compound_literal_array&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_bitset_with_context_compound_literal(count,                    \</div>
<div class="line">                                                     compound_literal_array)</div>
</div><!-- fragment -->
<p>Initialize the bit set with a starting capacity and size at runtime or compile time with no allocation permissions from a compound literal of bitset blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>context for the bitset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the count of bits &lt;= capacity of this bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compound_literal_array</td><td>the compound literal of bitset blocks. Use the <a class="el" href="bitset_8h.html#a872da66828891cfed4872081d7f3a83f" title="Allocate the necessary number of blocks at compile or runtime on the stack or data segment.">CCC_bitset_blocks()</a> macro to help construct this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized bit set on the right hand side of an equality operator. Capacity will be set to the full capacity available for the compound literal. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Use the <a class="el" href="bitset_8h.html#a872da66828891cfed4872081d7f3a83f" title="Allocate the necessary number of blocks at compile or runtime on the stack or data segment.">CCC_bitset_blocks()</a> macro to help construct the compound literal array.</dd></dl>
<p>A fixed size bit set.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Bitset bitset = bitset_with_context_compound_literal(</div>
<div class="line">    &amp;module_context,</div>
<div class="line">    4096,</div>
<div class="line">    bitset_blocks(4096, <span class="keyword">static</span>)</div>
<div class="line">);</div>
</div><!-- fragment --><p>This saves some initialization boilerplate. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa7609a9830b1b4af9389ad76a55f438f" name="aa7609a9830b1b4af9389ad76a55f438f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7609a9830b1b4af9389ad76a55f438f">&#9670;&#160;</a></span>CCC_Bitset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> <a class="el" href="structCCC__Bitset.html">CCC_Bitset</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bit set type that may be stored and initialized on the stack, heap, or data segment at compile or run time. </p>
<p>A bit set offers fast membership testing and bit range manipulations when the data can be modeled as a 0-indexed key value data set. In the case of a bit set the key is the index in the bit set and the value is 1 or 0. Operations on single bits occur in O(1) time. All scanning operations operate in O(N) time. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a52c429148b439f77564a95b3edc3b452" name="a52c429148b439f77564a95b3edc3b452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c429148b439f77564a95b3edc3b452">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : size_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a52c429148b439f77564a95b3edc3b452a1caf09195736db544353b8098c3f5346" name="a52c429148b439f77564a95b3edc3b452a1caf09195736db544353b8098c3f5346"></a>CCC_BITSET_BLOCK_BITS&#160;</td><td class="fielddoc"><p>The number of bits in a block of the bit set. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5a01edefe6dee85fdb545a69274b9b98" name="a5a01edefe6dee85fdb545a69274b9b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a01edefe6dee85fdb545a69274b9b98">&#9670;&#160;</a></span>CCC_bitset_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all bits in set are 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if all bits are 1, CCC_FALSE if any bits are 0, CCC_TRIBOOL_ERROR if bitset is NULL. </dd></dl>

</div>
</div>
<a id="a57d51c7b5e8e8e8c27679780f9112dd4" name="a57d51c7b5e8e8e8c27679780f9112dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d51c7b5e8e8e8c27679780f9112dd4">&#9670;&#160;</a></span>CCC_bitset_all_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_all_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all bits are set to 1 in the range <code>[index, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if all bits are 1, CCC_FALSE if any bits are 0, CCC_TRIBOOL_ERROR if bitset is NULL, index is invalid, count is invalid, or both index and count are invalid. </dd></dl>

</div>
</div>
<a id="a480043e5486200fa84b5f4eb8f96fab2" name="a480043e5486200fa84b5f4eb8f96fab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480043e5486200fa84b5f4eb8f96fab2">&#9670;&#160;</a></span>CCC_bitset_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise AND destination set with source set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>the set to modified with the AND operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the set to be read as the source bits for the AND operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK result if the operation is successful or an input error if destination or source are NULL. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>sets behave identically to integers for the AND operation when widening occurs. If destination is larger than source, source is padded with zeros in its Most Significant Bits. This means a bitwise AND operations will occur with the higher order bits in destination and 0's in this padded range (this results in all bits in destination being set to 0 in that range).</dd></dl>
<p>Note that sets are aligned from their Least Significant Bit and a smaller source set is conceptually padded with 0's in its higher order bits to align with the larger destination set (no modifications to the smaller set are performed to achieve this). This is done to stay consistent with integer promotion and widening rules in C. </p>

</div>
</div>
<a id="a54014b7bc57c24948ac11bf59425e727" name="a54014b7bc57c24948ac11bf59425e727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54014b7bc57c24948ac11bf59425e727">&#9670;&#160;</a></span>CCC_bitset_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_any </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if any bits in set are 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if any bits are 1, CCC_FALSE if no bits are 1, CCC_TRIBOOL_ERROR if bitset is NULL. </dd></dl>

</div>
</div>
<a id="a8a74673967ca72009ee04f15f38f7304" name="a8a74673967ca72009ee04f15f38f7304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a74673967ca72009ee04f15f38f7304">&#9670;&#160;</a></span>CCC_bitset_any_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_any_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if any bits are 1 in the range <code>[index, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if any bits are 1, CCC_FALSE if no bits are 1, CCC_TRIBOOL_ERROR if bitset is NULL, index is invalid, count is invalid, or both index and count are invalid. </dd></dl>

</div>
</div>
<a id="ab0b8365bd55738bc0685e1847dfe8a84" name="ab0b8365bd55738bc0685e1847dfe8a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b8365bd55738bc0685e1847dfe8a84">&#9670;&#160;</a></span>CCC_bitset_blocks_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_blocks_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of CCC_bitblocks used by bit set for capacity bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the capacity in number of bit blocks used to hold the entire capacity of bits in the set. If bs is NULL an argument error is set.</dd></dl>
<p>Capacity may be greater than or equal to size. </p>

</div>
</div>
<a id="a3e02c49979ab7107acdd4f118634fbb1" name="a3e02c49979ab7107acdd4f118634fbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e02c49979ab7107acdd4f118634fbb1">&#9670;&#160;</a></span>CCC_bitset_blocks_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_blocks_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of CCC_bitblocks used by the bit set for size bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in number of bit blocks used to hold the current size of bits in the set. An argument error is set if bitset is NULL.</dd></dl>
<p>Size may be less than or equal to capacity. </p>

</div>
</div>
<a id="aeba9fddb65eda291de0f105e3fb82ecc" name="aeba9fddb65eda291de0f105e3fb82ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba9fddb65eda291de0f105e3fb82ecc">&#9670;&#160;</a></span>CCC_bitset_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return total number of bits the capacity of the set can hold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the capacity of bits capable of being stored in the current set. If bitset is NULL an argument error is set. </dd></dl>

</div>
</div>
<a id="a02bc88eefcc8809fe77d2e6809a66118" name="a02bc88eefcc8809fe77d2e6809a66118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bc88eefcc8809fe77d2e6809a66118">&#9670;&#160;</a></span>CCC_bitset_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the bit set by setting the size to 0 and all bits to 0. The underlying memory capacity remains unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the clear operation, error is returned if bs is NULL . </dd></dl>

</div>
</div>
<a id="ad5f0f95441281910f95ce681d7d31a2b" name="ad5f0f95441281910f95ce681d7d31a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f0f95441281910f95ce681d7d31a2b">&#9670;&#160;</a></span>CCC_bitset_clear_and_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_clear_and_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the bit set by setting the size to 0 and freeing the underlying memory. Capacity becomes 0 as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the clear operation, error is returned if bs is NULL or the set cannot be freed because no allocation function was provided upon initialization. </dd></dl>

</div>
</div>
<a id="a7ae5a66486871862896b785e7acaf4fc" name="a7ae5a66486871862896b785e7acaf4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae5a66486871862896b785e7acaf4fc">&#9670;&#160;</a></span>CCC_bitset_clear_and_free_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_clear_and_free_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the Buffer for the bit set that was previously dynamically reserved with the reserve function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>the bitset to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the required allocation function to provide to a dynamically reserved bs. Any context data provided upon initialization will be passed to the allocation function when called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of free operation. OK if success, or an error status to indicate the error. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is an error to call this function on a bitset that was not reserved with the provided CCC_Allocator. The bitset must have existing memory to free.</dd></dl>
<p>This function covers the edge case of reserving a dynamic capacity for a bitset at runtime but denying the bitset allocation permission to resize. This can help prevent a bitset from growing untree. The user in this case knows the bitset does not have allocation permission and therefore no further memory will be dedicated to the bs.</p>
<p>However, to free the bitset in such a case this function must be used because the bitset has no ability to free itself. Just as the allocation function is required to reserve memory so to is it required to free memory.</p>
<p>This function will work normally if called on a bitset with allocation permission however the normal CCC_bitset_clear_and_free is sufficient for that use case. </p>

</div>
</div>
<a id="a1e536b16b4fdcbfccc6bb1bef30fd620" name="a1e536b16b4fdcbfccc6bb1bef30fd620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e536b16b4fdcbfccc6bb1bef30fd620">&#9670;&#160;</a></span>CCC_bitset_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the bit set at source to destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>the initialized destination for the copy of the source set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the initialized source of the set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the optional allocation function if resizing is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the copy operation. If the destination capacity is less than the source capacity and no allocation function is provided an input error is returned. If resizing is required and resizing of destination fails a memory error is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>destination must have capacity greater than or equal to source. If destination capacity is less than source, an allocation function must be provided with the allocate argument.</dd></dl>
<p>Note that there are two ways to copy data from source to destination: provide sufficient memory and pass NULL as allocate, or allow the copy function to take care of allocation for the copy.</p>
<p>Manual memory management with no allocation function provided.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Bitset source = bitset_initialize(</div>
<div class="line">    bitset_blocks(11, <span class="keyword">static</span>),</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    11</div>
<div class="line">);</div>
<div class="line">set_rand_bits(&amp;source);</div>
<div class="line"><span class="keyword">static</span> Bitset source = bitset_initialize(</div>
<div class="line">    bitset_blocks(13, <span class="keyword">static</span>),</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    13</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = bitset_copy(&amp;destination, &amp;source, NULL);</div>
<div class="ttc" id="atypes_8h_html_aa1ded61d294b114942f11e711b331dcf"><div class="ttname"><a href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a></div><div class="ttdeci">CCC_Result</div><div class="ttdoc">A result of actions on containers.</div><div class="ttdef"><b>Definition:</b> types.h:148</div></div>
</div><!-- fragment --><p>The above requires destination capacity be greater than or equal to source capacity. Here is memory management handed over to the copy function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Bitset source = bitset_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line">push_rand_bits(&amp;source);</div>
<div class="line"><span class="keyword">static</span> Bitset source = bitset_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = bitset_copy(&amp;destination, &amp;source, std_allocate);</div>
</div><!-- fragment --><p>The above allows destination to have a capacity less than that of the source as long as copy has been provided an allocation function to resize destination. Note that this would still work if copying to a destination that the user wants as a fixed size map.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BITSET_USING_NAMESPACE_CCC</span></div>
<div class="line"><span class="keyword">static</span> Bitset source = bitset_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    std_allocate,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line">push_rand_bits(&amp;source);</div>
<div class="line"><span class="keyword">static</span> Bitset source = bitset_initialize(</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    0</div>
<div class="line">);</div>
<div class="line"><a class="code hl_enumeration" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> res = bitset_copy(&amp;destination, &amp;source, std_allocate);</div>
</div><!-- fragment --><p>The above sets up destination with fixed size while source is a dynamic map. Because an allocation function is provided, the destination is resized once for the copy and retains its fixed size after the copy is complete. This would require the user to manually free the underlying Buffer at destination eventually if this method is used. Usually it is better to allocate the memory explicitly before the copy if copying between maps without allocation permission.</p>
<p>These options allow users to stay consistent across containers with their memory management strategies. </p>

</div>
</div>
<a id="a28da7dd2afe24ee3313454fdc74254ab" name="a28da7dd2afe24ee3313454fdc74254ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28da7dd2afe24ee3313454fdc74254ab">&#9670;&#160;</a></span>CCC_bitset_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return total number of bits actively tracked by the user and set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the total number of bits currently tracked by the set regardless of true or false state of each. If bitset is NULL an argument error is set. </dd></dl>

</div>
</div>
<a id="ae4b72853b6626dee7393da3f6a0482c2" name="ae4b72853b6626dee7393da3f6a0482c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b72853b6626dee7393da3f6a0482c2">&#9670;&#160;</a></span>CCC_bitset_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CCC_bitset_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the base of the underlying block array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the base of the first block of the bit set block array or NULL if bitset is NULL or has no capacity.</dd></dl>
<p>Every block populates bits from Least Significant Bit (LSB) to Most Significant Bit (MSB) so this reference is to the base or LSB of the entire set. </p>

</div>
</div>
<a id="a63436cf0e5be9db6a0197578ec9dd9db" name="a63436cf0e5be9db6a0197578ec9dd9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63436cf0e5be9db6a0197578ec9dd9db">&#9670;&#160;</a></span>CCC_bitset_first_leading_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_leading_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first leading bit set to 1 in the set, starting from the Most Significant Bit at index size - 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first leading bit set to 1 or CCC_RESULT_FAIL if no 1 bit is found or bitset in NULL. </dd></dl>

</div>
</div>
<a id="a457922476cd74a0c9819c3c8061714e0" name="a457922476cd74a0c9819c3c8061714e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457922476cd74a0c9819c3c8061714e0">&#9670;&#160;</a></span>CCC_bitset_first_leading_one_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_leading_one_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first leading bit set to 1 in the range <code>[i, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the starting index to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the size of the range to check from index towards index 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first leading bit set to 1 or CCC_RESULT_FAIL if no 1 bit is found, bitset is NULL, or the range is invalid. </dd></dl>

</div>
</div>
<a id="a97fc87cb3e78836e42650a75f1bfcdad" name="a97fc87cb3e78836e42650a75f1bfcdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fc87cb3e78836e42650a75f1bfcdad">&#9670;&#160;</a></span>CCC_bitset_first_leading_ones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_leading_ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ones_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the start of the first leading bit_count contiguous 1 bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ones_count</td><td>the number of leading contiguous 1 bits to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the starting index of the count of requested bits within the provided set. The returned index is the most significant bit in the range <code>[returned_index, returned_index - ones_count)</code>. If such a sequence cannot be found CCC_RESULT_FAIL is set. If bitset is NULL or any argument is out of range an argument error is set. </dd></dl>

</div>
</div>
<a id="af34ac4e33541358bb5f8a146cdf74cc3" name="af34ac4e33541358bb5f8a146cdf74cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34ac4e33541358bb5f8a146cdf74cc3">&#9670;&#160;</a></span>CCC_bitset_first_leading_ones_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_leading_ones_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ones_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the start of the first leading bit_count contiguous 1 bits in the range <code>[i, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ones_count</td><td>the number of leading contiguous 1 bits to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the starting index of the count of requested bits within the provided range. The returned index is the most significant bit in the range <code>[returned_index, returned_index - ones_count)</code>. If such a sequence cannot be found CCC_RESULT_FAIL is set. If bitset is NULL or any argument is out of range an argument error is set. </dd></dl>

</div>
</div>
<a id="a101936145c300579b382114d3ed16e61" name="a101936145c300579b382114d3ed16e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101936145c300579b382114d3ed16e61">&#9670;&#160;</a></span>CCC_bitset_first_leading_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_leading_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first leading bit set to 0 in the set, starting from the Most Significant Bit at index size - 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the index of the first bit set to 0 or CCC_RESULT_FAIL if no 1 bit is found. If bitset in NULL an argument error is set. </dd></dl>

</div>
</div>
<a id="a9b357b7bf63e0d1591578646fd799710" name="a9b357b7bf63e0d1591578646fd799710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b357b7bf63e0d1591578646fd799710">&#9670;&#160;</a></span>CCC_bitset_first_leading_zero_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_leading_zero_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first leading bit set to 0 in the range <code>[i, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to search for a 0 bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>size to search from Most Significant Bit to Least in range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the index of the first bit set to 0 in the specified range CCC_RESULT_FAIL if no 0 bit is found. If bs in NULL an argument error is set. </dd></dl>

</div>
</div>
<a id="a3ef46f59affeb6f9ab07aea7e1336e44" name="a3ef46f59affeb6f9ab07aea7e1336e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef46f59affeb6f9ab07aea7e1336e44">&#9670;&#160;</a></span>CCC_bitset_first_leading_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_leading_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zeros_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the start of the first leading number of contiguous 0 bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeros_count</td><td>the number of leading contiguous 0 bits to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the starting index of the count of requested bits within the provided set. The returned index is the most significant bit in the range <code>[returned_index, returned_index - zeros_count)</code>. If such a sequence cannot be found CCC_RESULT_FAIL is set. If bitset is NULL or any argument is out of range an argument error is set. </dd></dl>

</div>
</div>
<a id="ae3b9a38adf50ddb4d6c2a0666b5ecf66" name="ae3b9a38adf50ddb4d6c2a0666b5ecf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b9a38adf50ddb4d6c2a0666b5ecf66">&#9670;&#160;</a></span>CCC_bitset_first_leading_zeros_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_leading_zeros_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zeros_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the start of the first leading number of contiguous 0 bits in the range <code>[i, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeros_count</td><td>the number of leading contiguous 0 bits to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the starting index of the count of requested bits within the provided range. The returned index is the most significant bit in the range <code>[returned_index, returned_index - zeros_count)</code>. If such a sequence cannot be found CCC_RESULT_FAIL is set. If bitset is NULL or any argument is out of range an argument error is set. </dd></dl>

</div>
</div>
<a id="a66e104831cf9b2779d2dfe14f24ba3ec" name="a66e104831cf9b2779d2dfe14f24ba3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e104831cf9b2779d2dfe14f24ba3ec">&#9670;&#160;</a></span>CCC_bitset_first_trailing_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_trailing_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first trailing bit set to 1 in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and index of the first trailing bit set to 1 or an error set to CCC_RESULT_FAIL if no 1 bit is found. Argument error is set if bitset is NULL. </dd></dl>

</div>
</div>
<a id="aac534fdc0ea82be1e9a61f8f92f11a64" name="aac534fdc0ea82be1e9a61f8f92f11a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac534fdc0ea82be1e9a61f8f92f11a64">&#9670;&#160;</a></span>CCC_bitset_first_trailing_one_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_trailing_one_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first trailing bit set to 1 in the range <code>[i, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the index of the first trailing bit set to 1 or CCC_RESULT_FAIL if no 1 bit is found. Argument error is returned bitset is NULL, or the range is invalid. </dd></dl>

</div>
</div>
<a id="a8fe8947f8009685d53b12a53e1e7258e" name="a8fe8947f8009685d53b12a53e1e7258e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe8947f8009685d53b12a53e1e7258e">&#9670;&#160;</a></span>CCC_bitset_first_trailing_ones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_trailing_ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ones_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the start of the first trailing number of contiguous 1 bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ones_count</td><td>the number of trailing contiguous 1 bits to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the index in a search starting from the Least Significant Bit of the set of the first 1 in a sequence of bit_count 1 bits. If such a sequence cannot be found CCC_RESULT_FAIL result error is set. If bitset is NULL or bit_count is too large an argument error is set. </dd></dl>

</div>
</div>
<a id="afd72500d8ca93b17d2eee31e1f028980" name="afd72500d8ca93b17d2eee31e1f028980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd72500d8ca93b17d2eee31e1f028980">&#9670;&#160;</a></span>CCC_bitset_first_trailing_ones_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_trailing_ones_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ones_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the start of the first trailing number of contiguous 1 bits in the range <code>[index, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ones_count</td><td>the number of trailing contiguous 1 bits to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the starting index of the first 1 in a sequence of bit_count 1 bits. If no range is found CCC_RESULT_FAIL error is set. If bitset is NULL or arguments are out of range an argument error is set. </dd></dl>

</div>
</div>
<a id="a4c1ea7dbef6cc3b55619c3e650807129" name="a4c1ea7dbef6cc3b55619c3e650807129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1ea7dbef6cc3b55619c3e650807129">&#9670;&#160;</a></span>CCC_bitset_first_trailing_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_trailing_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first bit set to 0 in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the index of the first bit set to 0 or CCC_RESULT_FAIL if no 0 bit is found. If bitset is NULL an argument error is set. </dd></dl>

</div>
</div>
<a id="aafc517388b3d8f24ca135186288854c4" name="aafc517388b3d8f24ca135186288854c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc517388b3d8f24ca135186288854c4">&#9670;&#160;</a></span>CCC_bitset_first_trailing_zero_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_trailing_zero_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first bit set to 0 in the range <code>[i, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the index of the first bit set to 0 or CCC_RESULT_FAIL if no 0 bit is found. If bitset is NULL, or the range is invalid, an argument error is set. </dd></dl>

</div>
</div>
<a id="ac42b56e4b2a9285eb0ee05efd3f2be00" name="ac42b56e4b2a9285eb0ee05efd3f2be00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42b56e4b2a9285eb0ee05efd3f2be00">&#9670;&#160;</a></span>CCC_bitset_first_trailing_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_trailing_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zeros_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the start of the first trailing number of contiguous 0 bits in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeros_count</td><td>the number of trailing contiguous 0 bits to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK(0) status and the index in a search, starting from the Least Significant Bit of the set, of the first 0 in a sequence of zeros_count 0 bits. If such a sequence cannot be found CCC_RESULT_FAIL is returned. If bitset is NULL or num zeros is too large an argument error is set. </dd></dl>

</div>
</div>
<a id="ad7da0671d0b1697bb4883b26088c249d" name="ad7da0671d0b1697bb4883b26088c249d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7da0671d0b1697bb4883b26088c249d">&#9670;&#160;</a></span>CCC_bitset_first_trailing_zeros_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_first_trailing_zeros_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zeros_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the start of the first trailing zeros_count contiguous 0 bits in the range <code>[i, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeros_count</td><td>the number of trailing contiguous 0 bits to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index in a search, starting from the Least Significant Bit of the range, of the first 0 in a sequence of zeros_count 0 bits. If the input is invalid or such a sequence cannot be found CCC_RESULT_FAIL is returned. </dd></dl>

</div>
</div>
<a id="a5d90c10c9bc2372cf441ed73a2b7c8cd" name="a5d90c10c9bc2372cf441ed73a2b7c8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d90c10c9bc2372cf441ed73a2b7c8cd">&#9670;&#160;</a></span>CCC_bitset_flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the bit at index i. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index identifying the bit to toggle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state of the bit before the toggle operation, true if it was previously true, false if it was previously false, or error if bitset is NULL or index is out of range. </dd></dl>

</div>
</div>
<a id="a2281f20c700dd16a3436ab8cdcae3174" name="a2281f20c700dd16a3436ab8cdcae3174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2281f20c700dd16a3436ab8cdcae3174">&#9670;&#160;</a></span>CCC_bitset_flip_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_flip_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle all of the bits to their opposing boolean value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation. OK if successful, or an input error if bitset is NULL. </dd></dl>

</div>
</div>
<a id="a72290ab5aa5ba19f73375143b93269f9" name="a72290ab5aa5ba19f73375143b93269f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72290ab5aa5ba19f73375143b93269f9">&#9670;&#160;</a></span>CCC_bitset_flip_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_flip_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flip all the bits in the range, starting at the Least Significant Bit in range and ending at the Most Significant Bit, to their opposite value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to reset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the count of bits starting at index to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation. OK if successful, or an input error if bitset is NULL or the range is invalid by position, count, or both.</dd></dl>
<p>Note that a range is defined from index to index + count, where <code>index + count</code> is the exclusive end of the range. This is equivalent to moving from Least to Most Significant Bit in an integer. </p>

</div>
</div>
<a id="ae841c1c5aa6bbef00139d676bf7ba283" name="ae841c1c5aa6bbef00139d676bf7ba283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae841c1c5aa6bbef00139d676bf7ba283">&#9670;&#160;</a></span>CCC_bitset_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if no bits are actively tracked by the user and set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if the size of the set is 0 meaning no bits, regardless of 0 or 1 status, are tracked by the set. CCC_TRIBOOL_ERROR is returned if bitset is NULL. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if the number of bits set to 1 is desired see <a class="el" href="bitset_8h.html#a43dececa4fb2154379a9ce98ac61f03a" title="Return the number of bits set to CCC_TRUE. O(n).">CCC_bitset_popcount()</a>. </dd></dl>

</div>
</div>
<a id="a077ab1f869509d48c4dc2da2be8071fe" name="a077ab1f869509d48c4dc2da2be8071fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077ab1f869509d48c4dc2da2be8071fe">&#9670;&#160;</a></span>CCC_bitset_is_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_is_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks two bit sets of the same size (not capacity) for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>pointer to a bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>pointer to another bit set of equal size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bit sets are of equal size with identical bit values at every position, false if the sets are different sizes or have mismatched bits. A bool error is returned if either pointer is NULL. </dd></dl>

</div>
</div>
<a id="a3de23d6bc1c42f00570427616dea864e" name="a3de23d6bc1c42f00570427616dea864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de23d6bc1c42f00570427616dea864e">&#9670;&#160;</a></span>CCC_bitset_is_proper_subset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_is_proper_subset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return CCC_TRUE if subset is a proper subset of set (subset ⊂ set). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subset</td><td>the subset to confirm as a proper subset of set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set</td><td>the set to check subset against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if all bit positions in subset share the same value&ndash;0 or 1&ndash;as the bit positions in set and set is of greater size than subset. A CCC_TRIBOOL_ERROR is returned if set or subset is NULL.</dd></dl>
<p>If set is of size 0 the function returns CCC_FALSE regardless of the size of subset. If set is not of size 0 and subset is of size 0 the function returns CCC_TRUE. </p>

</div>
</div>
<a id="ad827812efab1e5a9dcd9932ebf495854" name="ad827812efab1e5a9dcd9932ebf495854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad827812efab1e5a9dcd9932ebf495854">&#9670;&#160;</a></span>CCC_bitset_is_subset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_is_subset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return CCC_TRUE if subset is a subset of set (subset ⊆ set). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>subset to confirm as a subset of set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>set to check subset against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if all bit positions in subset share the same value&ndash;0 or 1&ndash;as the bit positions in set. A CCC_TRIBOOL_ERROR is returned if set or subset is NULL.</dd></dl>
<p>If set is size zero subset must also be of size 0 to return CCC_TRUE. If subset is size 0 the function returns CCC_TRUE regardless of the size of set. </p>

</div>
</div>
<a id="ad4909d4df97f0d94e238d89c489a2ea3" name="ad4909d4df97f0d94e238d89c489a2ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4909d4df97f0d94e238d89c489a2ea3">&#9670;&#160;</a></span>CCC_bitset_none()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_none </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all bits are set to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if all bits are 0, CCC_FALSE if any bits are 1, CCC_TRIBOOL_ERROR if bitset is NULL. </dd></dl>

</div>
</div>
<a id="ad998717cb0e8f09b643f409251c81953" name="ad998717cb0e8f09b643f409251c81953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad998717cb0e8f09b643f409251c81953">&#9670;&#160;</a></span>CCC_bitset_none_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_none_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all bits are 0 in the range <code>[index, index + count)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCC_TRUE if all bits are 0, CCC_FALSE if any bits are 1, CCC_TRIBOOL_ERROR if bitset is NULL, index is invalid, count is invalid, or both index and count are invalid. </dd></dl>

</div>
</div>
<a id="ac86132b20d327de28c5747c804cb9675" name="ac86132b20d327de28c5747c804cb9675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86132b20d327de28c5747c804cb9675">&#9670;&#160;</a></span>CCC_bitset_or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise OR destination set with source set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>the set to modified with the OR operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the set to be read as the source bits for the OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK result if the operation is successful or an input error if destination or source are NULL.</dd></dl>
<p>Note that sets are aligned from their Least Significant Bit and a smaller source set is conceptually padded with 0's in its higher order bits to align with the larger destination set (no modifications to the smaller set are performed to achieve this). This is done to stay consistent with how the operation would work on a smaller integer stored in a larger integer to align with the larger. </p>

</div>
</div>
<a id="a4795a5a642bb2a416d774f40598aff24" name="a4795a5a642bb2a416d774f40598aff24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4795a5a642bb2a416d774f40598aff24">&#9670;&#160;</a></span>CCC_bitset_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the Most Significant Bit from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the Most Significant Bit (CCC_TRUE or CCC_FALSE) or a bool error if bitset is NULL or bitset is empty. </dd></dl>

</div>
</div>
<a id="a43dececa4fb2154379a9ce98ac61f03a" name="a43dececa4fb2154379a9ce98ac61f03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dececa4fb2154379a9ce98ac61f03a">&#9670;&#160;</a></span>CCC_bitset_popcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_popcount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bits set to CCC_TRUE. O(n). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of bits currently set to CCC_TRUE. CCC_RESULT_FAIL is returned if bitset is NULL. </dd></dl>

</div>
</div>
<a id="aedf3a9e7db10e051718c3311dc364154" name="aedf3a9e7db10e051718c3311dc364154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf3a9e7db10e051718c3311dc364154">&#9670;&#160;</a></span>CCC_bitset_popcount_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCCC__Count.html">CCC_Count</a> CCC_bitset_popcount_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bits set to CCC_TRUE in the range. O(n). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the size of the range to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of bits currently set in the range to CCC_TRUE. An argument error is set if bitset is NULL, index is invalid, count is invalid, or both index and count are invalid. </dd></dl>

</div>
</div>
<a id="a850f483c7ea01105667a78b25592f0d0" name="a850f483c7ea01105667a78b25592f0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850f483c7ea01105667a78b25592f0d0">&#9670;&#160;</a></span>CCC_bitset_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a bit value to the set as the new Most Significant Bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>the value to push at the Most Significant Bit CCC_TRUE/CCC_FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation, ok if successful or an error if bad parameters are provided or resizing is required to accommodate a new bit but resizing fails. </dd></dl>

</div>
</div>
<a id="a4e9bf7eb0b390fc4066e9b2c45f239e6" name="a4e9bf7eb0b390fc4066e9b2c45f239e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9bf7eb0b390fc4066e9b2c45f239e6">&#9670;&#160;</a></span>CCC_bitset_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aac6280c471e14b9c0d50b1c5577394d3">CCC_Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves space for at least to_add more bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_add</td><td>the number of elements to add to the current size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate</td><td>the allocation function to use to reserve memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the reservation. OK if successful, otherwise an error status is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see the CCC_bitset_clear_and_free_reserve function if this function is being used for a one-time dynamic reservation.</dd></dl>
<p>This function can be used for a dynamic bit set with or without allocation permission. If the bit set has allocation permission, it will reserve the required space and later resize if more space is needed.</p>
<p>If the bit set has been initialized with no allocation permission and no memory this function can serve as a one-time reservation. This is helpful when a fixed size is needed but that size is only known dynamically at runtime. To free the bit set in such a case see the <a class="el" href="bitset_8h.html#a7ae5a66486871862896b785e7acaf4fc" title="Frees the Buffer for the bit set that was previously dynamically reserved with the reserve function.">CCC_bitset_clear_and_free_reserve()</a> function. </p>

</div>
</div>
<a id="a047e880bfd157c60b37a34f6434e16d7" name="a047e880bfd157c60b37a34f6434e16d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047e880bfd157c60b37a34f6434e16d7">&#9670;&#160;</a></span>CCC_bitset_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bit at valid index index to boolean value b (true or false). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the valid index identifying the bit to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state of the bit before the set operation, true if it was previously true, false if it was previously false, or error if bitset is NULL or index is out of range. </dd></dl>

</div>
</div>
<a id="a10b3c66d273ef72f387041452f6a243a" name="a10b3c66d273ef72f387041452f6a243a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b3c66d273ef72f387041452f6a243a">&#9670;&#160;</a></span>CCC_bitset_reset_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_reset_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the bits to CCC_FALSE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation. OK if successful, or an input error if bitset is NULL. </dd></dl>

</div>
</div>
<a id="aa8c9b7c36eeab27ad7615215c9e61467" name="aa8c9b7c36eeab27ad7615215c9e61467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c9b7c36eeab27ad7615215c9e61467">&#9670;&#160;</a></span>CCC_bitset_reset_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_reset_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the bits in the specified range starting at the Least Significant Bit of the range and ending at the Most Significant Bit of the range to CCC_FALSE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to reset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the count of bits starting at index to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation. OK if successful, or an input error if bitset is NULL or the range is invalid by position, count, or both.</dd></dl>
<p>Note that a range is defined from <code>[index, index + count)</code>. This is equivalent to moving from Least to Most Significant bit in an integer. </p>

</div>
</div>
<a id="a90a1d625bc0744805ccac9e4184f90ae" name="a90a1d625bc0744805ccac9e4184f90ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a1d625bc0744805ccac9e4184f90ae">&#9670;&#160;</a></span>CCC_bitset_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bit at valid index index to value bit (true or false). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the valid index identifying the bit to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>the value to set at position index (CCC_TRUE or CCC_FALSE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state of the bit before the set operation, true if it was previously true, false if it was previously false, or error if bitset is NULL or index is out of range. </dd></dl>

</div>
</div>
<a id="a9045164b4f6d585973945f3003c30b68" name="a9045164b4f6d585973945f3003c30b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9045164b4f6d585973945f3003c30b68">&#9670;&#160;</a></span>CCC_bitset_set_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_set_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the bits to the provided value (CCC_TRUE or CCC_FALSE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>the value to set (CCC_TRUE or CCC_FALSE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation. OK if successful, or an input error if bitset is NULL. </dd></dl>

</div>
</div>
<a id="abb57e8abbbdbacb6813779c0730371e3" name="abb57e8abbbdbacb6813779c0730371e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb57e8abbbdbacb6813779c0730371e3">&#9670;&#160;</a></span>CCC_bitset_set_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_set_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range_bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the bits in the specified range starting at the Least Significant Bit of the range and ending at the Most Significant Bit of the range (CCC_TRUE or CCC_FALSE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start_index</td><td>the starting index to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_bit_count</td><td>the count of bits starting at index to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>the value to set (CCC_TRUE or CCC_FALSE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation. OK if successful, or an input error if bitset is NULL or the range is invalid by position, count, or both.</dd></dl>
<p>Note that a range is defined from <code>[index, index + count)</code>. This is equivalent to moving from Least to Most Significant bit in an integer. </p>

</div>
</div>
<a id="ad567c0204d2ce3195b00f4f99525a1b3" name="ad567c0204d2ce3195b00f4f99525a1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad567c0204d2ce3195b00f4f99525a1b3">&#9670;&#160;</a></span>CCC_bitset_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_shift_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>left_shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the bit set left by left_shifts amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_shifts</td><td>the number of left shifts to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an ok result if the operation was successful or an error if the Bitset is NULL.</dd></dl>
<p>Note that if the number of shifts is greater than the bit set size the bit set is zeroed out rather than exhibiting undefined behavior as in the equivalent integer operation. </p>

</div>
</div>
<a id="a8f8a489b9547073f07827808ad8437c2" name="a8f8a489b9547073f07827808ad8437c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8a489b9547073f07827808ad8437c2">&#9670;&#160;</a></span>CCC_bitset_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_shift_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>right_shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the bit set right by right_shifts amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_shifts</td><td>the number of right shifts to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an ok result if the operation was successful or an error if the Bitset is NULL.</dd></dl>
<p>Note that if the number of shifts is greater than the bit set size the bit set is zeroed out rather than exhibiting undefined behavior as in the equivalent integer operation. </p>

</div>
</div>
<a id="a0e64a6ca5e9ca50345a25a8de4059813" name="a0e64a6ca5e9ca50345a25a8de4059813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e64a6ca5e9ca50345a25a8de4059813">&#9670;&#160;</a></span>CCC_bitset_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8dbb03cfc2070934832841f50f146bcd">CCC_Tribool</a> CCC_bitset_test </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>bitset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the bit at index index for boolean status (CCC_TRUE or CCC_FALSE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitset</td><td>a pointer to the bit set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index identifying the bit to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state of the bit, or CCC_TRIBOOL_ERROR if bitset is NULL or index is out of range. </dd></dl>

</div>
</div>
<a id="a1657bb8880562c5ed4e3e99d798ecb9b" name="a1657bb8880562c5ed4e3e99d798ecb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1657bb8880562c5ed4e3e99d798ecb9b">&#9670;&#160;</a></span>CCC_bitset_xor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#aa1ded61d294b114942f11e711b331dcf">CCC_Result</a> CCC_bitset_xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCCC__Bitset.html">CCC_Bitset</a> const *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise XOR destination set with source set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>the set to modified with the XOR operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the set to be read as the source bits for the XOR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an OK result if the operation is successful or an input error if destination or source are NULL.</dd></dl>
<p>Note that sets are aligned from their Least Significant Bit and a smaller source set is conceptually padded with 0's in its higher order bits to align with the larger destination set (no modifications to the smaller set are performed to achieve this). This is done to stay consistent with how the operation would work on a smaller integer stored in a larger integer to align with the larger. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="bitset_8h.html">bitset.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
