<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/ordered_multimap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ordered__multimap_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">ordered_multimap.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Ordered Multimap Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;impl_ordered_multimap.h&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ordered_multimap.h:</div>
<div class="dyncontent">
<div class="center"><img src="ordered__multimap_8h__incl.png" border="0" usemap="#accc_2ordered__multimap_8h" alt=""/></div>
<map name="accc_2ordered__multimap_8h" id="accc_2ordered__multimap_8h">
<area shape="rect" title="The Ordered Multimap Interface." alt="" coords="78,5,257,31"/>
<area shape="rect" href="impl__ordered__multimap_8h_source.html" title=" " alt="" coords="5,79,196,104"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="163,225,233,251"/>
<area shape="rect" href="impl__tree_8h_source.html" title=" " alt="" coords="77,152,173,177"/>
<area shape="rect" href="impl__types_8h_source.html" title=" " alt="" coords="107,299,214,324"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ordered__multimap_8h__dep__incl.png" border="0" usemap="#accc_2ordered__multimap_8hdep" alt=""/></div>
<map name="accc_2ordered__multimap_8hdep" id="accc_2ordered__multimap_8hdep">
<area shape="rect" title="The Ordered Multimap Interface." alt="" coords="5,5,184,31"/>
<area shape="rect" href="impl__traits_8h_source.html" title=" " alt="" coords="30,79,159,104"/>
<area shape="rect" href="traits_8h.html" title="The C Container Collection Traits Interface." alt="" coords="48,152,141,177"/>
</map>
</div>
</div>
<p><a href="ordered__multimap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab0a4874d3d0e1c089b8a11e37a3167f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ab0a4874d3d0e1c089b8a11e37a3167f6">ccc_omm_init</a>(omm_name,  user_struct_name,  ommap_elem_field,  key_field,  alloc_fn,  key_cmp_fn,  aux)</td></tr>
<tr class="memdesc:ab0a4874d3d0e1c089b8a11e37a3167f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a ordered multimap of the user specified type.  <br /></td></tr>
<tr class="separator:ab0a4874d3d0e1c089b8a11e37a3167f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2689cf9c610ca8b3a6b680ae2cf39a54"><td class="memItemLeft" align="right" valign="top">typedef union ccc_ordered_multimap_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a></td></tr>
<tr class="memdesc:a2689cf9c610ca8b3a6b680ae2cf39a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for membership testing by key field, allowing duplicate keys.  <br /></td></tr>
<tr class="separator:a2689cf9c610ca8b3a6b680ae2cf39a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ca25836d1807cc92289c600a40673"><td class="memItemLeft" align="right" valign="top">typedef union ccc_ommap_elem_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a></td></tr>
<tr class="memdesc:a193ca25836d1807cc92289c600a40673"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrusive element for the user defined type stored in the multimap.  <br /></td></tr>
<tr class="separator:a193ca25836d1807cc92289c600a40673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b29c8dbbd10827d07c041fbfff7e2b4"><td class="memItemLeft" align="right" valign="top">typedef union ccc_ommap_entry_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a></td></tr>
<tr class="memdesc:a3b29c8dbbd10827d07c041fbfff7e2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container specific type to support the Entry Interface.  <br /></td></tr>
<tr class="separator:a3b29c8dbbd10827d07c041fbfff7e2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Entry Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and operate on container entries for efficient queries when non-trivial control flow is needed. </p>
</td></tr>
<tr class="memitem:a62f29a40d5db3f9c0ecc62e960ce8f92"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a62f29a40d5db3f9c0ecc62e960ce8f92">ccc_omm_try_insert_w</a>(ordered_multimap_ptr,  key,  lazy_value...)</td></tr>
<tr class="memdesc:a62f29a40d5db3f9c0ecc62e960ce8f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new key-value into the multimap only if none exists. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a62f29a40d5db3f9c0ecc62e960ce8f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac253833cbe0f1b91687067f36fd196e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ac253833cbe0f1b91687067f36fd196e8">ccc_omm_insert_or_assign_w</a>(ordered_multimap_ptr,  key,  lazy_value...)</td></tr>
<tr class="memdesc:ac253833cbe0f1b91687067f36fd196e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value pair into the multimap either as the first entry or overwriting the oldest existing entry at key. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ac253833cbe0f1b91687067f36fd196e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0cb99173678a3dd75b9cb1517ef40d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a6b0cb99173678a3dd75b9cb1517ef40d">ccc_omm_entry_r</a>(ordered_multimap_ptr,  key_ptr)</td></tr>
<tr class="memdesc:a6b0cb99173678a3dd75b9cb1517ef40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a compound literal reference to the entry generated from a search. No manual management of a compound literal reference is necessary. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a6b0cb99173678a3dd75b9cb1517ef40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62175c278b698ffafb684d2f6a2f920f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a62175c278b698ffafb684d2f6a2f920f">ccc_omm_and_modify_w</a>(ordered_multimap_entry_ptr,  mod_fn,  lazy_aux_data...)</td></tr>
<tr class="memdesc:a62175c278b698ffafb684d2f6a2f920f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the ordered multimap entry with a modification function requiring auxiliary data. If auxiliary data is passed as a function call, it will only execute if the entry is occupied.  <br /></td></tr>
<tr class="separator:a62175c278b698ffafb684d2f6a2f920f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93bb13a6d30e0cf569764cc004e85b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ae93bb13a6d30e0cf569764cc004e85b3">ccc_omm_or_insert_w</a>(ordered_multimap_entry_ptr,  lazy_key_value...)&#160;&#160;&#160;    ccc_impl_omm_or_insert_w(ordered_multimap_entry_ptr, lazy_key_value)</td></tr>
<tr class="memdesc:ae93bb13a6d30e0cf569764cc004e85b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an initial key value into the multimap if none is present, otherwise return the oldest user type stored at the specified key. O(1).  <br /></td></tr>
<tr class="separator:ae93bb13a6d30e0cf569764cc004e85b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62bdbb6605efeb5abbbda3a6f1ca54c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ae62bdbb6605efeb5abbbda3a6f1ca54c">ccc_omm_insert_entry_w</a>(ordered_multimap_entry_ptr,  lazy_key_value...)&#160;&#160;&#160;    ccc_impl_omm_insert_entry_w(ordered_multimap_entry_ptr, lazy_key_value)</td></tr>
<tr class="memdesc:ae62bdbb6605efeb5abbbda3a6f1ca54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly writes the specified compound literal directly to the existing or newly allocated entry. O(1).  <br /></td></tr>
<tr class="separator:ae62bdbb6605efeb5abbbda3a6f1ca54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4e9fa3bd0e6c9510b8a0d32e3dbcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a8bd4e9fa3bd0e6c9510b8a0d32e3dbcf">ccc_omm_insert</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle)</td></tr>
<tr class="memdesc:a8bd4e9fa3bd0e6c9510b8a0d32e3dbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an entry pointing to the newly inserted element and a status indicating if the map has already been Occupied at the given key. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a8bd4e9fa3bd0e6c9510b8a0d32e3dbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e43551d709dfd5300936783bbc92e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a9e43551d709dfd5300936783bbc92e32">ccc_omm_try_insert</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle)</td></tr>
<tr class="memdesc:a9e43551d709dfd5300936783bbc92e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new key-value into the multimap only if none exists. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a9e43551d709dfd5300936783bbc92e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42136f8a3255764c895d27c817ab595d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a42136f8a3255764c895d27c817ab595d">ccc_omm_insert_or_assign</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle)</td></tr>
<tr class="memdesc:a42136f8a3255764c895d27c817ab595d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly inserts the key value pair into the multimap either as the first entry or overwriting the oldest existing entry at key. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a42136f8a3255764c895d27c817ab595d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adc45910c0cfc51516e96ab1c7399db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a8adc45910c0cfc51516e96ab1c7399db">ccc_omm_remove</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *out_handle)</td></tr>
<tr class="memdesc:a8adc45910c0cfc51516e96ab1c7399db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry specified at key of the type containing out_handle preserving the old value if possible. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a8adc45910c0cfc51516e96ab1c7399db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155e54fd97aa520dacfca655d2b7decf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a155e54fd97aa520dacfca655d2b7decf">ccc_omm_entry</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, void const *key)</td></tr>
<tr class="memdesc:a155e54fd97aa520dacfca655d2b7decf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a container specific entry for the given search for key. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a155e54fd97aa520dacfca655d2b7decf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb0585616dbb6b64e1fb3062daef6e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a2cb0585616dbb6b64e1fb3062daef6e5">ccc_omm_and_modify</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> *e, <a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *fn)</td></tr>
<tr class="memdesc:a2cb0585616dbb6b64e1fb3062daef6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the provided entry modified with fn if Occupied.  <br /></td></tr>
<tr class="separator:a2cb0585616dbb6b64e1fb3062daef6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd6c55fe7483ae6955fdeb1e174869f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#acbd6c55fe7483ae6955fdeb1e174869f">ccc_omm_and_modify_aux</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> *e, <a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *fn, void *aux)</td></tr>
<tr class="memdesc:acbd6c55fe7483ae6955fdeb1e174869f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the provided entry modified with fn and auxiliary data aux if Occupied.  <br /></td></tr>
<tr class="separator:acbd6c55fe7483ae6955fdeb1e174869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492d3c9a89862156aa7ff3ef073972ab"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a492d3c9a89862156aa7ff3ef073972ab">ccc_omm_or_insert</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *e, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle)</td></tr>
<tr class="memdesc:a492d3c9a89862156aa7ff3ef073972ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an initial key value into the multimap if none is present, otherwise return the oldest user type stored at the specified key. O(1).  <br /></td></tr>
<tr class="separator:a492d3c9a89862156aa7ff3ef073972ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629cde21e7bb2d5977952dc456185560"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a629cde21e7bb2d5977952dc456185560">ccc_omm_insert_entry</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *e, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle)</td></tr>
<tr class="memdesc:a629cde21e7bb2d5977952dc456185560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invariantly writes the specified key value directly to the existing or newly allocated entry. O(1).  <br /></td></tr>
<tr class="separator:a629cde21e7bb2d5977952dc456185560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae4bdac07cf7c71c7cf5f67d7e7064d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a9ae4bdac07cf7c71c7cf5f67d7e7064d">ccc_omm_remove_entry</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> *e)</td></tr>
<tr class="memdesc:a9ae4bdac07cf7c71c7cf5f67d7e7064d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry if it is Occupied. O(1).  <br /></td></tr>
<tr class="separator:a9ae4bdac07cf7c71c7cf5f67d7e7064d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15aa0cd534d3e175c97ee5b1ef4ea04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ac15aa0cd534d3e175c97ee5b1ef4ea04">ccc_omm_occupied</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *e)</td></tr>
<tr class="memdesc:ac15aa0cd534d3e175c97ee5b1ef4ea04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if an entry is Occupied or Vacant.  <br /></td></tr>
<tr class="separator:ac15aa0cd534d3e175c97ee5b1ef4ea04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6b118b83a25331821664a38fc12666"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#acf6b118b83a25331821664a38fc12666">ccc_omm_unwrap</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *e)</td></tr>
<tr class="memdesc:acf6b118b83a25331821664a38fc12666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps the provided entry. An Occupied entry will point to the user type stored in the map, a Vacant entry will be NULL.  <br /></td></tr>
<tr class="separator:acf6b118b83a25331821664a38fc12666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa307320e2d455da9e035126e11fa2449"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#aa307320e2d455da9e035126e11fa2449">ccc_omm_insert_error</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *e)</td></tr>
<tr class="memdesc:aa307320e2d455da9e035126e11fa2449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if an insertion error occurs.  <br /></td></tr>
<tr class="separator:aa307320e2d455da9e035126e11fa2449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9accc84eb0ed234c86dc8a04b1f34d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ac9accc84eb0ed234c86dc8a04b1f34d1">ccc_omm_input_error</a> (<a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *e)</td></tr>
<tr class="memdesc:ac9accc84eb0ed234c86dc8a04b1f34d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a function used to generate the provided entry encountered bad arguments that prevented the operation of the function.  <br /></td></tr>
<tr class="separator:ac9accc84eb0ed234c86dc8a04b1f34d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iterator Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and manage iterators over the container. </p>
</td></tr>
<tr class="memitem:a620fad51c394d2a0a27bc641bdeb74f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a620fad51c394d2a0a27bc641bdeb74f7">ccc_omm_equal_range_r</a>(ordered_multimap_ptr,  begin_and_end_key_ptrs...)</td></tr>
<tr class="memdesc:a620fad51c394d2a0a27bc641bdeb74f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compound literal reference to the desired range. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a620fad51c394d2a0a27bc641bdeb74f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a97a7ca1b8dc4559529da0845e8ba59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a2a97a7ca1b8dc4559529da0845e8ba59">ccc_omm_equal_rrange_r</a>(ordered_multimap_ptr,  rbegin_and_rend_key_ptrs...)</td></tr>
<tr class="memdesc:a2a97a7ca1b8dc4559529da0845e8ba59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compound literal reference to the desired rrange. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a2a97a7ca1b8dc4559529da0845e8ba59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc92ac4c7779edd7f6ef056810396ca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#abc92ac4c7779edd7f6ef056810396ca5">ccc_omm_equal_range</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, void const *begin_key, void const *end_key)</td></tr>
<tr class="memdesc:abc92ac4c7779edd7f6ef056810396ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterable range of values from [begin_key, end_key). Amortized O(lg N).  <br /></td></tr>
<tr class="separator:abc92ac4c7779edd7f6ef056810396ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a3a364d4f32667648e4a7ff14c1fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ab2a3a364d4f32667648e4a7ff14c1fb6">ccc_omm_equal_rrange</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, void const *rbegin_key, void const *rend_key)</td></tr>
<tr class="memdesc:ab2a3a364d4f32667648e4a7ff14c1fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterable rrange of values from [begin_key, end_key). Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ab2a3a364d4f32667648e4a7ff14c1fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30494817d552e630926fd4441330eee1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a30494817d552e630926fd4441330eee1">ccc_omm_begin</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm)</td></tr>
<tr class="memdesc:a30494817d552e630926fd4441330eee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start of an inorder traversal of the multimap. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a30494817d552e630926fd4441330eee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99015395c791eabb52de1b2fb911d063"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a99015395c791eabb52de1b2fb911d063">ccc_omm_rbegin</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm)</td></tr>
<tr class="memdesc:a99015395c791eabb52de1b2fb911d063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start of a reverse inorder traversal of the multimap. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a99015395c791eabb52de1b2fb911d063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea61d95a0bc096038175192b8512c496"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#aea61d95a0bc096038175192b8512c496">ccc_omm_next</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> const *iter_handle)</td></tr>
<tr class="memdesc:aea61d95a0bc096038175192b8512c496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next element in an inorder traversal of the multimap. O(1).  <br /></td></tr>
<tr class="separator:aea61d95a0bc096038175192b8512c496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1941cffa5bf8db8a2eb153c320e0a5be"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a1941cffa5bf8db8a2eb153c320e0a5be">ccc_omm_rnext</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> const *iter_handle)</td></tr>
<tr class="memdesc:a1941cffa5bf8db8a2eb153c320e0a5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rnext element in a reverse inorder traversal of the multimap. O(1).  <br /></td></tr>
<tr class="separator:a1941cffa5bf8db8a2eb153c320e0a5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1a77090968a266287c22f518a6a995"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a2f1a77090968a266287c22f518a6a995">ccc_omm_end</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm)</td></tr>
<tr class="memdesc:a2f1a77090968a266287c22f518a6a995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end of an inorder traversal of the multimap. O(1).  <br /></td></tr>
<tr class="separator:a2f1a77090968a266287c22f518a6a995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681598607b150e97a02957a4b64fdadb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a681598607b150e97a02957a4b64fdadb">ccc_omm_rend</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm)</td></tr>
<tr class="memdesc:a681598607b150e97a02957a4b64fdadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rend of a reverse inorder traversal of the multimap. O(1).  <br /></td></tr>
<tr class="separator:a681598607b150e97a02957a4b64fdadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Membership Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Test membership or obtain references to stored user types directly. </p>
</td></tr>
<tr class="memitem:add4e50102f710992eba723530d8960df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#add4e50102f710992eba723530d8960df">ccc_omm_contains</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, void const *key)</td></tr>
<tr class="memdesc:add4e50102f710992eba723530d8960df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the membership of key in the multimap. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:add4e50102f710992eba723530d8960df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050dc19c7e841bdaf4bcae729c516a44"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a050dc19c7e841bdaf4bcae729c516a44">ccc_omm_get_key_val</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, void const *key)</td></tr>
<tr class="memdesc:a050dc19c7e841bdaf4bcae729c516a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the user type stored at key. Amortized O(lg
N).  <br /></td></tr>
<tr class="separator:a050dc19c7e841bdaf4bcae729c516a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Push and Pop Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>An interface to enhance the priority queue capabilities of a multimap. </p>
</td></tr>
<tr class="memitem:ad5808788286dbf7b29238feb25279427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ad5808788286dbf7b29238feb25279427">ccc_omm_pop_max</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm)</td></tr>
<tr class="memdesc:ad5808788286dbf7b29238feb25279427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the oldest maximum key value user type from the map. Elements are stored in ascending order, smallest as defined by the comparison function is min and largest is max. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ad5808788286dbf7b29238feb25279427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab705e30e50374c6127d0e22e60d177d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ab705e30e50374c6127d0e22e60d177d8">ccc_omm_pop_min</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm)</td></tr>
<tr class="memdesc:ab705e30e50374c6127d0e22e60d177d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the oldest minimum element from the map. Elements are stored in ascending order, smallest as defined by the comparison function is min and largest is max. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:ab705e30e50374c6127d0e22e60d177d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66717e7a67dc331ec1db7ff041439abb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a66717e7a67dc331ec1db7ff041439abb">ccc_omm_max</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm)</td></tr>
<tr class="memdesc:a66717e7a67dc331ec1db7ff041439abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the oldest maximum key value user type from the map. Elements are stored in ascending order, smallest as defined by the comparison function is min and largest is max. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a66717e7a67dc331ec1db7ff041439abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1ceeb1955b3d223057631667e7519b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a8b1ceeb1955b3d223057631667e7519b">ccc_omm_min</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm)</td></tr>
<tr class="memdesc:a8b1ceeb1955b3d223057631667e7519b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the oldest minimum key value user type from the map. Elements are stored in ascending order, smallest as defined by the comparison function is min and largest is max. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a8b1ceeb1955b3d223057631667e7519b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cccc31a6c0503e8ac4340459adfbee"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ab6cccc31a6c0503e8ac4340459adfbee">ccc_omm_extract</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle)</td></tr>
<tr class="memdesc:ab6cccc31a6c0503e8ac4340459adfbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a user type known to be stored in the map with key_val_handle as an element currently in use by the map. O(1).  <br /></td></tr>
<tr class="separator:ab6cccc31a6c0503e8ac4340459adfbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f378b0bdedf3d1b9454016ed68f5be5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a1f378b0bdedf3d1b9454016ed68f5be5">ccc_omm_update</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle, <a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *fn, void *aux)</td></tr>
<tr class="memdesc:a1f378b0bdedf3d1b9454016ed68f5be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an element key that is currently tracked directly as a member of the map. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a1f378b0bdedf3d1b9454016ed68f5be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d62a5ec7b584249a5bd9620bd47b5f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a9d62a5ec7b584249a5bd9620bd47b5f3">ccc_omm_increase</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle, <a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *fn, void *aux)</td></tr>
<tr class="memdesc:a9d62a5ec7b584249a5bd9620bd47b5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases an element key that is currently tracked directly as a member of the map. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:a9d62a5ec7b584249a5bd9620bd47b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabce7eb8fc409b1b67d13e3ca4fbb95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#acabce7eb8fc409b1b67d13e3ca4fbb95">ccc_omm_decrease</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *key_val_handle, <a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *fn, void *aux)</td></tr>
<tr class="memdesc:acabce7eb8fc409b1b67d13e3ca4fbb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases an element key that is currently tracked directly as a member of the map. Amortized O(lg N).  <br /></td></tr>
<tr class="separator:acabce7eb8fc409b1b67d13e3ca4fbb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deallocation Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Deallocate the container. </p>
</td></tr>
<tr class="memitem:ae82b53c6b679358bb217f58dd46c5ee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#ae82b53c6b679358bb217f58dd46c5ee6">ccc_omm_clear</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *mm, <a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *destructor)</td></tr>
<tr class="memdesc:ae82b53c6b679358bb217f58dd46c5ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops every element from the map calling destructor if destructor is non-NULL. O(N).  <br /></td></tr>
<tr class="separator:ae82b53c6b679358bb217f58dd46c5ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain the container state. </p>
</td></tr>
<tr class="memitem:aa12982d7ae7b24c28535f9304d7b529d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#aa12982d7ae7b24c28535f9304d7b529d">ccc_omm_is_empty</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm)</td></tr>
<tr class="memdesc:aa12982d7ae7b24c28535f9304d7b529d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the multimap is empty. O(1).  <br /></td></tr>
<tr class="separator:aa12982d7ae7b24c28535f9304d7b529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9513e80b1d5e1d47c928271bafb4d753"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#a9513e80b1d5e1d47c928271bafb4d753">ccc_omm_size</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm)</td></tr>
<tr class="memdesc:a9513e80b1d5e1d47c928271bafb4d753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the multimap is empty. O(1).  <br /></td></tr>
<tr class="separator:a9513e80b1d5e1d47c928271bafb4d753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41ea459ee93002659c8b5cf407b7e08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ordered__multimap_8h.html#aa41ea459ee93002659c8b5cf407b7e08">ccc_omm_validate</a> (<a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *mm)</td></tr>
<tr class="memdesc:aa41ea459ee93002659c8b5cf407b7e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the multimap is empty.  <br /></td></tr>
<tr class="separator:aa41ea459ee93002659c8b5cf407b7e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Ordered Multimap Interface. </p>
<p>A multimap offers storage and retrieval by key. However, duplicate keys are allowed to be stored in the map.</p>
<p>This multimap orders duplicate keys by a round robin scheme. This means the oldest key-value inserted into the multimap will be the one found on any queries or removed first when popped from the multimap. Therefore, this multimap is equivalent to a double ended priority queue with round robin fairness among duplicate key elements. There are helper functions to make this use case simpler. The multimap is a self-optimizing data structure and therefore does not offer read-only searching. The runtime for all search, insert, and remove operations is amortized O(lg N) and may not meet the requirements of realtime systems.</p>
<p>This container offers pointer stability. Also, if the container is not permitted to allocate all insertion code assumes that the user has allocated memory appropriately for the element to be inserted; it will not allocate or free in this case. If allocation is permitted upon initialization the container will manage the memory as expected on insert or erase operations as defined by the interface; memory is allocated for insertions and freed for removals.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ORDERED_MULTIMAP_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All types and functions can then be written without the <code>ccc_</code> prefix. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a62175c278b698ffafb684d2f6a2f920f" name="a62175c278b698ffafb684d2f6a2f920f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62175c278b698ffafb684d2f6a2f920f">&#9670;&#160;</a></span>ccc_omm_and_modify_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_and_modify_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ordered_multimap_entry_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mod_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_aux_data...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a>)                                                         \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_impl_omm_and_modify_w(ordered_multimap_entry_ptr, mod_fn,          \</div>
<div class="line">                                  lazy_aux_data)                               \</div>
<div class="line">    }</div>
<div class="ttc" id="aordered__multimap_8h_html_a3b29c8dbbd10827d07c041fbfff7e2b4"><div class="ttname"><a href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a></div><div class="ttdeci">union ccc_ommap_entry_ ccc_ommap_entry</div><div class="ttdoc">The container specific type to support the Entry Interface.</div><div class="ttdef"><b>Definition:</b> ordered_multimap.h:67</div></div>
</div><!-- fragment -->
<p>Modify the ordered multimap entry with a modification function requiring auxiliary data. If auxiliary data is passed as a function call, it will only execute if the entry is occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_multimap_entry_ptr</td><td>the address of the multimap entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_fn</td><td>the ccc_update_fn used to update a stored value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_aux_data</td><td>the rvalue that this operation will construct and pass to the modification function if the entry is occupied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new entry. This is a compound literal reference, not a pointer that requires any manual memory management.</dd></dl>
<p>Note that keys should not be modified by the modify operation, only values or other struct members. </p>

</div>
</div>
<a id="a6b0cb99173678a3dd75b9cb1517ef40d" name="a6b0cb99173678a3dd75b9cb1517ef40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0cb99173678a3dd75b9cb1517ef40d">&#9670;&#160;</a></span>ccc_omm_entry_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_entry_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ordered_multimap_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a>)                                                         \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_omm_entry((ordered_multimap_ptr), (key_ptr)).impl_                 \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return a compound literal reference to the entry generated from a search. No manual management of a compound literal reference is necessary. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_multimap_ptr</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_ptr</td><td>a ponter to the key to be searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to a container specific entry associated with the enclosing scope. This reference is always non-NULL.</dd></dl>
<p>Note this is useful for nested calls where an entry pointer is requested by further operations in the Entry Interface, avoiding uneccessary intermediate values and references (e.g. struct val *v = or_insert(entry_r(...), ...)); </p>

</div>
</div>
<a id="a620fad51c394d2a0a27bc641bdeb74f7" name="a620fad51c394d2a0a27bc641bdeb74f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620fad51c394d2a0a27bc641bdeb74f7">&#9670;&#160;</a></span>ccc_omm_equal_range_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_equal_range_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ordered_multimap_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">begin_and_end_key_ptrs...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_omm_equal_range(ordered_multimap_ptr, begin_and_end_key_ptrs)      \</div>
<div class="line">            .impl_                                                             \</div>
<div class="line">    }</div>
<div class="ttc" id="atypes_8h_html_a3bf43522fb22e6e499ea327fecf35c55"><div class="ttname"><a href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a></div><div class="ttdeci">union ccc_range_ ccc_range</div><div class="ttdoc">The result of a range query on iterable containers.</div><div class="ttdef"><b>Definition:</b> types.h:26</div></div>
</div><!-- fragment -->
<p>Returns a compound literal reference to the desired range. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_multimap_ptr</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_and_end_key_ptrs</td><td>two pointers, one to the beginning of the range and one to the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the produced range associated with the enclosing scope. This reference is always non-NULL. </dd></dl>

</div>
</div>
<a id="a2a97a7ca1b8dc4559529da0845e8ba59" name="a2a97a7ca1b8dc4559529da0845e8ba59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a97a7ca1b8dc4559529da0845e8ba59">&#9670;&#160;</a></span>ccc_omm_equal_rrange_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_equal_rrange_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ordered_multimap_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rbegin_and_rend_key_ptrs...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_typedef" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a>)                                                              \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_omm_equal_rrange(ordered_multimap_ptr, rbegin_and_rend_key_ptrs)   \</div>
<div class="line">            .impl_                                                             \</div>
<div class="line">    }</div>
<div class="ttc" id="atypes_8h_html_abbe513ff2fb6678559bcbe22e5faca65"><div class="ttname"><a href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a></div><div class="ttdeci">union ccc_rrange_ ccc_rrange</div><div class="ttdoc">The result of a rrange query on iterable containers.</div><div class="ttdef"><b>Definition:</b> types.h:34</div></div>
</div><!-- fragment -->
<p>Returns a compound literal reference to the desired rrange. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_multimap_ptr</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbegin_and_rend_key_ptrs</td><td>two pointers, one to the beginning of the rrange and one to the end of the rrange. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the produced rrange associated with the enclosing scope. This reference is always non-NULL. </dd></dl>

</div>
</div>
<a id="ab0a4874d3d0e1c089b8a11e37a3167f6" name="ab0a4874d3d0e1c089b8a11e37a3167f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a4874d3d0e1c089b8a11e37a3167f6">&#9670;&#160;</a></span>ccc_omm_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">omm_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">user_struct_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ommap_elem_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alloc_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_cmp_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">aux&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ccc_impl_omm_init(omm_name, user_struct_name, ommap_elem_field, key_field, \</div>
<div class="line">                      alloc_fn, key_cmp_fn, aux)</div>
</div><!-- fragment -->
<p>Initialize a ordered multimap of the user specified type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">omm_name</td><td>the name of the ordered multimap being initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_struct_name</td><td>the struct the user intends to store. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ommap_elem_field</td><td>the name of the field with the intrusive element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_field</td><td>the name of the field used as the multimap key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_fn</td><td>the ccc_alloc_fn (<a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a>) used to allocate nodes or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_cmp_fn</td><td>the ccc_key_cmp_fn (<a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a>) used to compare the key to the current stored element under considertion during a map operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>any aux data needed for compare, print, or destruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the initialized ordered multimap. Use this initializer on the right hand side of the variable at compile or run time (e.g. ccc_ordered_multimap m = <a class="el" href="ordered__multimap_8h.html#ab0a4874d3d0e1c089b8a11e37a3167f6" title="Initialize a ordered multimap of the user specified type.">ccc_omm_init(...)</a>;) </dd></dl>

</div>
</div>
<a id="ae62bdbb6605efeb5abbbda3a6f1ca54c" name="ae62bdbb6605efeb5abbbda3a6f1ca54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62bdbb6605efeb5abbbda3a6f1ca54c">&#9670;&#160;</a></span>ccc_omm_insert_entry_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_insert_entry_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ordered_multimap_entry_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_key_value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_omm_insert_entry_w(ordered_multimap_entry_ptr, lazy_key_value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly writes the specified compound literal directly to the existing or newly allocated entry. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_multimap_entry_ptr</td><td>the address of the multimap entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_key_value</td><td>the compound literal that is constructed directly at the existing or newly allocated memory in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type written to the existing map entry or newly inserted. If NULL is returned, an allocator error has occured or allocation was disallowed on initialization to prevent inserting a new element </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the key in the lazy_key_value compound literal must match the key used for the initial entry generation.</dd></dl>
<p>Note that it only makes sense to use this method when the container is permitted to allocate memory. </p>

</div>
</div>
<a id="ac253833cbe0f1b91687067f36fd196e8" name="ac253833cbe0f1b91687067f36fd196e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac253833cbe0f1b91687067f36fd196e8">&#9670;&#160;</a></span>ccc_omm_insert_or_assign_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_insert_or_assign_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ordered_multimap_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#aa6dc7577080398fd18623d2c6a464723">ccc_entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_impl_omm_insert_or_assign_w(ordered_multimap_ptr, key, lazy_value) \</div>
<div class="line">    }</div>
<div class="ttc" id="atraits_8h_html_aa6dc7577080398fd18623d2c6a464723"><div class="ttname"><a href="traits_8h.html#aa6dc7577080398fd18623d2c6a464723">ccc_entry</a></div><div class="ttdeci">#define ccc_entry(container_ptr, key_ptr...)</div><div class="ttdoc">Obtain a container specific entry for the Entry Interface.</div><div class="ttdef"><b>Definition:</b> traits.h:99</div></div>
</div><!-- fragment -->
<p>Invariantly inserts the key value pair into the multimap either as the first entry or overwriting the oldest existing entry at key. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_multimap_ptr</td><td>a pointer to the multimap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the direct key r-value to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_value</td><td>the compound literal for the type to be directly written to the existing or newly allocated map entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the entry in the map. The status is Occupied if this entry shows the oldest existing entry at key with the newly written value, or Vacant if no prior entry existed and this is the first insertion at key.</dd></dl>
<p>Note that only the value, and any other supplementary fields, need to be specified in the struct compound literal as this method ensures the struct key and searched key match. </p>

</div>
</div>
<a id="ae93bb13a6d30e0cf569764cc004e85b3" name="ae93bb13a6d30e0cf569764cc004e85b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93bb13a6d30e0cf569764cc004e85b3">&#9670;&#160;</a></span>ccc_omm_or_insert_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_or_insert_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ordered_multimap_entry_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_key_value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ccc_impl_omm_or_insert_w(ordered_multimap_entry_ptr, lazy_key_value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an initial key value into the multimap if none is present, otherwise return the oldest user type stored at the specified key. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_multimap_entry_ptr</td><td>the address of the multimap entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_key_value</td><td>the compound literal of the user struct stored in the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type stored in the map either existing or newly inserted. If NULL is returned, an allocator error has occured or allocation was disallowed on initialization to prevent inserting a new element. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the key in the lazy_key_value compound literal must match the key used for the initial entry generation.</dd></dl>
<p>Note that it only makes sense to use this method when the container is permitted to allocate memory. </p>

</div>
</div>
<a id="a62f29a40d5db3f9c0ecc62e960ce8f92" name="a62f29a40d5db3f9c0ecc62e960ce8f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f29a40d5db3f9c0ecc62e960ce8f92">&#9670;&#160;</a></span>ccc_omm_try_insert_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ccc_omm_try_insert_w</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ordered_multimap_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lazy_value...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    &amp;(<a class="code hl_define" href="traits_8h.html#aa6dc7577080398fd18623d2c6a464723">ccc_entry</a>)                                                               \</div>
<div class="line">    {                                                                          \</div>
<div class="line">        ccc_impl_omm_try_insert_w(ordered_multimap_ptr, key, lazy_value)       \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a new key-value into the multimap only if none exists. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_multimap_ptr</td><td>a pointer to the multimap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the direct key r-value to be searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lazy_value</td><td>the compound literal for the type to be directly written to a new allocation if an entry does not already exist at key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a compound literal reference to the entry in the map. The status is Occupied if this entry shows the oldest existing entry at key, or Vacant if no prior entry existed and this is the first insertion at key.</dd></dl>
<p>Note that only the value, and any other supplementary fields, need be specified in the struct compound literal as this method ensures the struct key and searched key match. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a193ca25836d1807cc92289c600a40673" name="a193ca25836d1807cc92289c600a40673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193ca25836d1807cc92289c600a40673">&#9670;&#160;</a></span>ccc_ommap_elem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union ccc_ommap_elem_ <a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intrusive element for the user defined type stored in the multimap. </p>
<p>The ordered multimap element can occupy a single field anywhere in the user struct. Note that if allocation is not permitted, insertions functions accepting this type as an argument assume it to exist in pre-allocated memory that will exist with the appropriate lifetime and scope for the user's needs; the container does not allocate or free in this case. </p>

</div>
</div>
<a id="a3b29c8dbbd10827d07c041fbfff7e2b4" name="a3b29c8dbbd10827d07c041fbfff7e2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b29c8dbbd10827d07c041fbfff7e2b4">&#9670;&#160;</a></span>ccc_ommap_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union ccc_ommap_entry_ <a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The container specific type to support the Entry Interface. </p>
<p>An Entry Interface offers efficient conditional searching, saving multiple searches. Entries are views of Vacant or Occupied multimap elements allowing further operations to be performed once they are obtained without a second search, insert, or remove query. </p>

</div>
</div>
<a id="a2689cf9c610ca8b3a6b680ae2cf39a54" name="a2689cf9c610ca8b3a6b680ae2cf39a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2689cf9c610ca8b3a6b680ae2cf39a54">&#9670;&#160;</a></span>ccc_ordered_multimap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union ccc_ordered_multimap_ <a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A container for membership testing by key field, allowing duplicate keys. </p>
<dl class="section warning"><dt>Warning</dt><dd>it is undefined behavior to use an uninitialized container.</dd></dl>
<p>A ordered multimap may be stored on the stack, heap, or data segment. It can be initialized at compile time or runtime. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2cb0585616dbb6b64e1fb3062daef6e5" name="a2cb0585616dbb6b64e1fb3062daef6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb0585616dbb6b64e1fb3062daef6e5">&#9670;&#160;</a></span>ccc_omm_and_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> * ccc_omm_and_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the provided entry modified with fn if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the container specific entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the update function to modify the type in the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the same entry provided. The update function will be called on the entry with NULL as the auxiliary argument if the entry is Occupied, otherwise the function is not called. If either arguments to the function are NULL, NULL is returned. </dd></dl>

</div>
</div>
<a id="acbd6c55fe7483ae6955fdeb1e174869f" name="acbd6c55fe7483ae6955fdeb1e174869f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd6c55fe7483ae6955fdeb1e174869f">&#9670;&#160;</a></span>ccc_omm_and_modify_aux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> * ccc_omm_and_modify_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the provided entry modified with fn and auxiliary data aux if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the container specific entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the update function to modify the type in the entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>a pointer to auxiliary data needed for the modification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the same entry provided. The update function will be called on the entry with aux as the auxiliary argument if the entry is Occupied, otherwise the function is not called. If any arguments to the function are NULL, NULL is returned. </dd></dl>

</div>
</div>
<a id="a30494817d552e630926fd4441330eee1" name="a30494817d552e630926fd4441330eee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30494817d552e630926fd4441330eee1">&#9670;&#160;</a></span>ccc_omm_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the start of an inorder traversal of the multimap. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the oldest minimum element of the map.</dd></dl>
<p>Note that duplicate keys will be traversed starting at the oldest element in round robin order and ending at the newest before progressing to the next key of stored in the multimap. </p>

</div>
</div>
<a id="ae82b53c6b679358bb217f58dd46c5ee6" name="ae82b53c6b679358bb217f58dd46c5ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82b53c6b679358bb217f58dd46c5ee6">&#9670;&#160;</a></span>ccc_omm_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_omm_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa2bb6262f220473dc47f4c73711a6ec5">ccc_destructor_fn</a> *&#160;</td>
          <td class="paramname"><em>destructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops every element from the map calling destructor if destructor is non-NULL. O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>a destructor function if required. NULL if unneeded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an input error if mm points to NULL otherwise ok.</dd></dl>
<p>Note that if the multimap has been given permission to allocate, the destructor will be called on each element before it uses the provided allocator to free the element. Therefore, the destructor should not free the element or a double free will occur.</p>
<p>If the container has not been given allocation permission, then the destructor may free elements or not depending on how and when the user wishes to free elements of the map according to their own memory management schemes. </p>

</div>
</div>
<a id="add4e50102f710992eba723530d8960df" name="add4e50102f710992eba723530d8960df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4e50102f710992eba723530d8960df">&#9670;&#160;</a></span>ccc_omm_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the membership of key in the multimap. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>a pointer to the key to be searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the multimap contains at least one entry at key, else false. </dd></dl>

</div>
</div>
<a id="acabce7eb8fc409b1b67d13e3ca4fbb95" name="acabce7eb8fc409b1b67d13e3ca4fbb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabce7eb8fc409b1b67d13e3ca4fbb95">&#9670;&#160;</a></span>ccc_omm_decrease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_decrease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decreases an element key that is currently tracked directly as a member of the map. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>the pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a pointer to the intrusive element embedded in a user type that the user knows is currently in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the function used to decrease an element key in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>any auxiliary data needed for the key decrease. Usually a new value but NULL is possible if aux is not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key decrease was successful, false if bad arguments are provided, it is possible to prove the key_val_handle is not tracked by the map, or the map is empty. </dd></dl>

</div>
</div>
<a id="a2f1a77090968a266287c22f518a6a995" name="a2f1a77090968a266287c22f518a6a995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1a77090968a266287c22f518a6a995">&#9670;&#160;</a></span>ccc_omm_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the end of an inorder traversal of the multimap. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newest maximum element of the map.</dd></dl>
<p>Note that duplicate keys will be traversed starting at the oldest element in round robin order and ending at the newest before progressing to the next key of stored in the multimap. </p>

</div>
</div>
<a id="a155e54fd97aa520dacfca655d2b7decf" name="a155e54fd97aa520dacfca655d2b7decf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155e54fd97aa520dacfca655d2b7decf">&#9670;&#160;</a></span>ccc_omm_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> ccc_omm_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a container specific entry for the given search for key. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>a pointer to the key to be searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific entry for status, unwrapping, or further Entry Interface operations. Occupied indicates at least one user type with key exists and can be unwrapped to view. Vacant indicates no user type at key exists. </dd></dl>

</div>
</div>
<a id="abc92ac4c7779edd7f6ef056810396ca5" name="abc92ac4c7779edd7f6ef056810396ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc92ac4c7779edd7f6ef056810396ca5">&#9670;&#160;</a></span>ccc_omm_equal_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a3bf43522fb22e6e499ea327fecf35c55">ccc_range</a> ccc_omm_equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>begin_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>end_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterable range of values from [begin_key, end_key). Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_key</td><td>a pointer to the key intended as the start of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_key</td><td>a pointer to the key intended as the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range containing the first element NOT LESS than the begin_key and the first element GREATER than end_key.</dd></dl>
<p>Note that due to the variety of values that can be returned in the range, using the provided range iteration functions from <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a> is recommended for example:</p>
<p>for (struct val *i = range_begin(&amp;range); i != end_range(&amp;range); i = next(&amp;omm, &amp;i-&gt;elem)) {}</p>
<p>This avoids any possible errors in handling an end range element that is in the map versus the end map sentinel. </p>

</div>
</div>
<a id="ab2a3a364d4f32667648e4a7ff14c1fb6" name="ab2a3a364d4f32667648e4a7ff14c1fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a3a364d4f32667648e4a7ff14c1fb6">&#9670;&#160;</a></span>ccc_omm_equal_rrange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abbe513ff2fb6678559bcbe22e5faca65">ccc_rrange</a> ccc_omm_equal_rrange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>rbegin_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>rend_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterable rrange of values from [begin_key, end_key). Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbegin_key</td><td>a pointer to the key intended as the start of the rrange. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rend_key</td><td>a pointer to the key intended as the end of the rrange. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a rrange containing the first element NOT GREATER than the begin_key and the first element LESS than rend_key.</dd></dl>
<p>Note that due to the variety of values that can be returned in the rrange, using the provided rrange iteration functions from <a class="el" href="types_8h.html" title="The C Container Collection Fundamental Types.">types.h</a> is recommended for example:</p>
<p>for (struct val *i = rrange_begin(&amp;rrange); i != rend_rrange(&amp;rrange); i = rnext(&amp;omm, &amp;i-&gt;elem)) {}</p>
<p>This avoids any possible errors in handling an rend rrange element that is in the map versus the end map sentinel. </p>

</div>
</div>
<a id="ab6cccc31a6c0503e8ac4340459adfbee" name="ab6cccc31a6c0503e8ac4340459adfbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cccc31a6c0503e8ac4340459adfbee">&#9670;&#160;</a></span>ccc_omm_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a user type known to be stored in the map with key_val_handle as an element currently in use by the map. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>the pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a pointer to the intrusive element embedded in a user type that the user knows is currently in the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the extracted element. NULL is returned if it is possible to prove the key_val_handle is not tracked by the map or the map is empty.</dd></dl>
<p>Note that the element that is extracted is not freed, even if allocation permission is given to the container. It is the user's responsibility to free the element that has been extracted. </p>

</div>
</div>
<a id="a050dc19c7e841bdaf4bcae729c516a44" name="a050dc19c7e841bdaf4bcae729c516a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050dc19c7e841bdaf4bcae729c516a44">&#9670;&#160;</a></span>ccc_omm_get_key_val()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_get_key_val </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the user type stored at key. Amortized O(lg
N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>a pointer to the key to be searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the oldest existing user type at key, NULL if absent. </dd></dl>

</div>
</div>
<a id="a9d62a5ec7b584249a5bd9620bd47b5f3" name="a9d62a5ec7b584249a5bd9620bd47b5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d62a5ec7b584249a5bd9620bd47b5f3">&#9670;&#160;</a></span>ccc_omm_increase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_increase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases an element key that is currently tracked directly as a member of the map. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>the pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a pointer to the intrusive element embedded in a user type that the user knows is currently in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the function used to increase an element key in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>any auxiliary data needed for the key increase. Usually a new value but NULL is possible if aux is not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key increase was successful, false if bad arguments are provided, it is possible to prove the key_val_handle is not tracked by the map, or the map is empty. </dd></dl>

</div>
</div>
<a id="ac9accc84eb0ed234c86dc8a04b1f34d1" name="ac9accc84eb0ed234c86dc8a04b1f34d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9accc84eb0ed234c86dc8a04b1f34d1">&#9670;&#160;</a></span>ccc_omm_input_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_input_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a function used to generate the provided entry encountered bad arguments that prevented the operation of the function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the multimap entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if bad function arguments were provided, otherwise false.</dd></dl>
<p>Note bad arguments usually mean NULL pointers were passed to functions expecting non-NULL arguments. </p>

</div>
</div>
<a id="a8bd4e9fa3bd0e6c9510b8a0d32e3dbcf" name="a8bd4e9fa3bd0e6c9510b8a0d32e3dbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd4e9fa3bd0e6c9510b8a0d32e3dbcf">&#9670;&#160;</a></span>ccc_omm_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> ccc_omm_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an entry pointing to the newly inserted element and a status indicating if the map has already been Occupied at the given key. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a handle to the new key value to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry that can be unwrapped to view the inserted element. The status will be Occupied if this element is a duplicate added to a duplicate list or Vacant if this key is the first of its value inserted into the multimap. If the element cannot be added due to an allocator error, an insert error is set.</dd></dl>
<p>Note that if allocation has been prohibited the address of the key_val_handle is used directly. This means the container assumes the memory provided for the user type containing key_val_handle has been allocated with appropriate lifetime by the user, for the user's intended use case. </p>

</div>
</div>
<a id="a629cde21e7bb2d5977952dc456185560" name="a629cde21e7bb2d5977952dc456185560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629cde21e7bb2d5977952dc456185560">&#9670;&#160;</a></span>ccc_omm_insert_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly writes the specified key value directly to the existing or newly allocated entry. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the multimap entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a pointer to the intrusive element in the user type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type written to the existing map entry or newly inserted. NULL is returned if allocation is permitted but the allocator encounters an error.</dd></dl>
<p>Note that if allocation has been prohibited the address of the key_val_handle is used directly. This means the container assumes the memory provided for the user type containing key_val_handle has been allocated with appropriate lifetime by the user, for the user's intended use case. </p>

</div>
</div>
<a id="aa307320e2d455da9e035126e11fa2449" name="aa307320e2d455da9e035126e11fa2449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa307320e2d455da9e035126e11fa2449">&#9670;&#160;</a></span>ccc_omm_insert_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_insert_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if an insertion error occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the multimap entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an insertion error occured preventing completing of an Entry Interface series of operations.</dd></dl>
<p>Note that this will most commonly occur if the container is permitted to allocate but the allocation has failed. </p>

</div>
</div>
<a id="a42136f8a3255764c895d27c817ab595d" name="a42136f8a3255764c895d27c817ab595d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42136f8a3255764c895d27c817ab595d">&#9670;&#160;</a></span>ccc_omm_insert_or_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> ccc_omm_insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invariantly inserts the key value pair into the multimap either as the first entry or overwriting the oldest existing entry at key. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a pointer to the intrusive element in the user type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry of the user type in the map. The status is Occupied if this entry shows the oldest existing entry at key with the newly written value, or Vacant if no prior entry existed and this is the first insertion at key.</dd></dl>
<p>Note that if allocation has been prohibited the address of the key_val_handle is used directly. This means the container assumes the memory provided for the user type containing key_val_handle has been allocated with appropriate lifetime by the user, for the user's intended use case. </p>

</div>
</div>
<a id="aa12982d7ae7b24c28535f9304d7b529d" name="aa12982d7ae7b24c28535f9304d7b529d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12982d7ae7b24c28535f9304d7b529d">&#9670;&#160;</a></span>ccc_omm_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the multimap is empty. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty, false if mm is NULL or mm is empty. </dd></dl>

</div>
</div>
<a id="a66717e7a67dc331ec1db7ff041439abb" name="a66717e7a67dc331ec1db7ff041439abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66717e7a67dc331ec1db7ff041439abb">&#9670;&#160;</a></span>ccc_omm_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the oldest maximum key value user type from the map. Elements are stored in ascending order, smallest as defined by the comparison function is min and largest is max. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>the pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the oldest maximum key value user type in the map.</dd></dl>
<p>Note that because the map is self optimizing, a search for the maximum element followed by a pop of the maximum element results in one amortized O(lg N) search followed by one O(1) pop. If there are duplicate max keys stored in the map, all subsequent max search and pop operations are O(1) until duplicates are exhausted and if no intervening search, insert, or erase operations occur for non-max keys. </p>

</div>
</div>
<a id="a8b1ceeb1955b3d223057631667e7519b" name="a8b1ceeb1955b3d223057631667e7519b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1ceeb1955b3d223057631667e7519b">&#9670;&#160;</a></span>ccc_omm_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the oldest minimum key value user type from the map. Elements are stored in ascending order, smallest as defined by the comparison function is min and largest is max. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>the pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the oldest minimum key value user type in the map.</dd></dl>
<p>Note that because the map is self optimizing, a search for the minimum element followed by a pop of the minimum element results in one amortized O(lg N) search followed by one O(1) pop. If there are duplicate min keys stored in the map, all subsequent min search and pop operations are O(1) until duplicates are exhausted and if no intervening search, insert, or erase operations occur for non-min keys. </p>

</div>
</div>
<a id="aea61d95a0bc096038175192b8512c496" name="aea61d95a0bc096038175192b8512c496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea61d95a0bc096038175192b8512c496">&#9670;&#160;</a></span>ccc_omm_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> const *&#160;</td>
          <td class="paramname"><em>iter_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next element in an inorder traversal of the multimap. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_handle</td><td>a pointer to the intrusive multimap element of the current iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next user type stored in the map in an inorder traversal.</dd></dl>
<p>Note that duplicate keys will be traversed starting at the oldest element in round robin order and ending at the newest before progressing to the next key of stored in the multimap. </p>

</div>
</div>
<a id="ac15aa0cd534d3e175c97ee5b1ef4ea04" name="ac15aa0cd534d3e175c97ee5b1ef4ea04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15aa0cd534d3e175c97ee5b1ef4ea04">&#9670;&#160;</a></span>ccc_omm_occupied()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_occupied </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if an entry is Occupied or Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the multimap entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry is Occupied, false if it is Vacant. </dd></dl>

</div>
</div>
<a id="a492d3c9a89862156aa7ff3ef073972ab" name="a492d3c9a89862156aa7ff3ef073972ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492d3c9a89862156aa7ff3ef073972ab">&#9670;&#160;</a></span>ccc_omm_or_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_or_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an initial key value into the multimap if none is present, otherwise return the oldest user type stored at the specified key. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the multimap entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a pointer to the intrusive element in the user type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type stored in the map either existing or newly inserted. If NULL is returned, an allocator error has occured when allocation was allowed for the container.</dd></dl>
<p>Note that if allocation has been prohibited the address of the key_val_handle is used directly. This means the container assumes the memory provided for the user type containing key_val_handle has been allocated with appropriate lifetime by the user, for the user's intended use case. </p>

</div>
</div>
<a id="ad5808788286dbf7b29238feb25279427" name="ad5808788286dbf7b29238feb25279427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5808788286dbf7b29238feb25279427">&#9670;&#160;</a></span>ccc_omm_pop_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_omm_pop_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the oldest maximum key value user type from the map. Elements are stored in ascending order, smallest as defined by the comparison function is min and largest is max. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>the pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the status of the pop operation. If NULL pointer is provided or the map is empty a bad input result is returned otherwise ok.</dd></dl>
<p>Note that continual pop max operations emptying a full queue with few to no intervening search or insert operations is a good use case for this container due to its self optimization. </p>

</div>
</div>
<a id="ab705e30e50374c6127d0e22e60d177d8" name="ab705e30e50374c6127d0e22e60d177d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab705e30e50374c6127d0e22e60d177d8">&#9670;&#160;</a></span>ccc_omm_pop_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1493dc76581f8c71eb96202fb1671ae1">ccc_result</a> ccc_omm_pop_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the oldest minimum element from the map. Elements are stored in ascending order, smallest as defined by the comparison function is min and largest is max. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>the pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the status of the pop operation. If NULL pointer is provided or the map is empty a bad input result is returned otherwise ok.</dd></dl>
<p>Note that continual pop min operations emptying a full queue with few to no intervening search or insert operations is a good use case for this container due to its self optimization. </p>

</div>
</div>
<a id="a99015395c791eabb52de1b2fb911d063" name="a99015395c791eabb52de1b2fb911d063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99015395c791eabb52de1b2fb911d063">&#9670;&#160;</a></span>ccc_omm_rbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the start of a reverse inorder traversal of the multimap. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the oldest maximum element of the map.</dd></dl>
<p>Note that duplicate keys will be traversed starting at the oldest element in round robin order and ending at the newest before progressing to the next key of stored in the multimap. </p>

</div>
</div>
<a id="a8adc45910c0cfc51516e96ab1c7399db" name="a8adc45910c0cfc51516e96ab1c7399db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adc45910c0cfc51516e96ab1c7399db">&#9670;&#160;</a></span>ccc_omm_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> ccc_omm_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>out_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the entry specified at key of the type containing out_handle preserving the old value if possible. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_handle</td><td>the pointer to the intrusive element in the user type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry indicating if one of the elements stored at key has been removed. The status is Occupied if at least one element at key existed and was removed, or Vacant if no element existed at key. If the container has been given permission to allocate, the oldest user type stored at key will be written to the struct containing out_handle; the original data has been freed. If allocation has been denied the container will return the user struct directly and the user must unwrap and free their type themselves. </dd></dl>

</div>
</div>
<a id="a9ae4bdac07cf7c71c7cf5f67d7e7064d" name="a9ae4bdac07cf7c71c7cf5f67d7e7064d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae4bdac07cf7c71c7cf5f67d7e7064d">&#9670;&#160;</a></span>ccc_omm_remove_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> ccc_omm_remove_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the entry if it is Occupied. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the multimap entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry indicating the status of the removal. If the entry was Vacant, a Vacant entry with NULL is returned. If the entry is Occupied and allocation is permitted, the stored user type is freed, the entry points to NULL, and the status indicates the entry was Occupied but contains NULL. If allocation is prohibited the entry is removed from the map and returned to be unwrapped and freed by the user. </dd></dl>

</div>
</div>
<a id="a681598607b150e97a02957a4b64fdadb" name="a681598607b150e97a02957a4b64fdadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681598607b150e97a02957a4b64fdadb">&#9670;&#160;</a></span>ccc_omm_rend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the rend of a reverse inorder traversal of the multimap. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newest minimum element of the map.</dd></dl>
<p>Note that duplicate keys will be traversed starting at the oldest element in round robin order and ending at the newest before progressing to the next key of stored in the multimap. </p>

</div>
</div>
<a id="a1941cffa5bf8db8a2eb153c320e0a5be" name="a1941cffa5bf8db8a2eb153c320e0a5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1941cffa5bf8db8a2eb153c320e0a5be">&#9670;&#160;</a></span>ccc_omm_rnext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_rnext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> const *&#160;</td>
          <td class="paramname"><em>iter_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the rnext element in a reverse inorder traversal of the multimap. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_handle</td><td>a pointer to the intrusive multimap element of the current iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rnext user type stored in the map in a reverse inorder traversal.</dd></dl>
<p>Note that duplicate keys will be traversed starting at the oldest element in round robin order and ending at the newest before progressing to the rnext key of stored in the multimap. </p>

</div>
</div>
<a id="a9513e80b1d5e1d47c928271bafb4d753" name="a9513e80b1d5e1d47c928271bafb4d753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9513e80b1d5e1d47c928271bafb4d753">&#9670;&#160;</a></span>ccc_omm_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ccc_omm_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the multimap is empty. O(1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the container or 0 if empty or mm is NULL. </dd></dl>

</div>
</div>
<a id="a9e43551d709dfd5300936783bbc92e32" name="a9e43551d709dfd5300936783bbc92e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e43551d709dfd5300936783bbc92e32">&#9670;&#160;</a></span>ccc_omm_try_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a70feefd55fafc84e06d2f2a1dfd4f389">ccc_entry</a> ccc_omm_try_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new key-value into the multimap only if none exists. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a pointer to the intrusive element in the user type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry of the user type in the map. The status is Occupied if this entry shows the oldest existing entry at key, or Vacant if no prior entry existed and this is the first insertion at key.</dd></dl>
<p>Note that if allocation has been prohibited the address of the key_val_handle is used directly. This means the container assumes the memory provided for the user type containing key_val_handle has been allocated with appropriate lifetime by the user, for the user's intended use case. </p>

</div>
</div>
<a id="acf6b118b83a25331821664a38fc12666" name="acf6b118b83a25331821664a38fc12666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6b118b83a25331821664a38fc12666">&#9670;&#160;</a></span>ccc_omm_unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ccc_omm_unwrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a3b29c8dbbd10827d07c041fbfff7e2b4">ccc_ommap_entry</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwraps the provided entry. An Occupied entry will point to the user type stored in the map, a Vacant entry will be NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>a pointer to the multimap entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user type if Occupied, otherwise NULL. </dd></dl>

</div>
</div>
<a id="a1f378b0bdedf3d1b9454016ed68f5be5" name="a1f378b0bdedf3d1b9454016ed68f5be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f378b0bdedf3d1b9454016ed68f5be5">&#9670;&#160;</a></span>ccc_omm_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a193ca25836d1807cc92289c600a40673">ccc_ommap_elem</a> *&#160;</td>
          <td class="paramname"><em>key_val_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a15cf33ea819ae97e1cfdcaf1d55a99b0">ccc_update_fn</a> *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates an element key that is currently tracked directly as a member of the map. Amortized O(lg N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>the pointer to the multimap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_val_handle</td><td>a pointer to the intrusive element embedded in a user type that the user knows is currently in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the function used to update an element key in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aux</td><td>any auxiliary data needed for the update. Usually a new value but NULL is possible if aux is not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key update was successful, false if bad arguments are provided, it is possible to prove the key_val_handle is not tracked by the map, or the map is empty. </dd></dl>

</div>
</div>
<a id="aa41ea459ee93002659c8b5cf407b7e08" name="aa41ea459ee93002659c8b5cf407b7e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41ea459ee93002659c8b5cf407b7e08">&#9670;&#160;</a></span>ccc_omm_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccc_omm_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ordered__multimap_8h.html#a2689cf9c610ca8b3a6b680ae2cf39a54">ccc_ordered_multimap</a> const *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the multimap is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>a pointer to the multimap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if invariants of the data structure are preserved, else false. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="ordered__multimap_8h.html">ordered_multimap.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
